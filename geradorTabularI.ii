# 1 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp"
# 1 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp"
# 1 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.h" 1



# 1 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\GeradorTabular.h" 1




# 1 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/calculador.h" 1



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 1 3
# 58 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 3
       
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 1 3
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 1 3
# 236 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 3

# 236 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 258 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/os_defines.h" 1 3
# 509 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 2 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
# 512 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 60 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functexcept.h" 1 3
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functexcept.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_defines.h" 1 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functexcept.h" 2 3

namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cpp_type_traits.h" 1 3
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cpp_type_traits.h" 3
       
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cpp_type_traits.h" 3
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/type_traits.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/type_traits.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/numeric_traits.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/numeric_traits.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

# 54 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 1 3
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/concept_check.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/concept_check.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/concept_check.h" 3
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 2 3

namespace std
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std
{

# 68 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }






    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 192 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 324 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 352 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
# 724 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 759 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1463 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1520 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1607 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<short unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1726 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1776 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1813 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1852 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1872 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1911 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };
# 2329 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename...> using __void_t = void;
# 2338 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2382 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2587 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 2947 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/type_traits" 3

}
# 56 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 2 3

namespace std
{

# 72 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 116 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 136 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 176 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 2 3





namespace std
{

# 76 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };
# 197 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 241 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 269 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __not_<__and_<is_copy_assignable<_T1>,
                is_copy_assignable<_T2>>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p) = delete;

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 516 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 535 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_pair.h" 3

}
# 65 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 1 3
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
       
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3







namespace std
{

# 89 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 1 3
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 3
       
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/debug/assertions.h" 1 3
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 1 3
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ptr_traits.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ptr_traits.h" 3
namespace std
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 198 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ptr_traits.h" 3

}
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 2 3





namespace std
{

# 100 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 167 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 297 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 387 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 422 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 451 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 486 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 528 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 543 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 577 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 619 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 638 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 689 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 734 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{

# 758 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 858 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }
# 1003 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 1268 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_iterator.h" 3

}
# 68 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/debug/debug.h" 1 3
# 48 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/predefined_ops.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

 
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
       
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 2 3

namespace std
{

# 118 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
   
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
   
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
   
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
   
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
        && __is_pointer<_II>::__value
        && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
        && __is_pointer<_BI1>::__value
        && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __is_pointer<_II1>::__value
        && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1037 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1069 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1219 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1255 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1298 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1331 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 1431 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_algobase.h" 3


}
# 61 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 1 3
# 46 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++allocator.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++allocator.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 3

#pragma GCC visibility push(default)


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception.h" 3
       
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 111 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 3
}

namespace __gnu_cxx
{

# 133 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_init_exception.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_init_exception.h" 3
       
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4






# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 1 3 4
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 12 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3 4
# 98 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 107 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 13 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3 4
# 44 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_secapi.h" 3 4
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 282 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/vadefs.h" 1 3 4
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/vadefs.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 578 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sdks/_mingw_directx.h" 1 3 4
# 579 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3 4
# 580 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/vadefs.h" 2 3 4




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/vadefs.h" 3 4
}



#pragma pack(pop)
# 283 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 541 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
extern "C" {
# 552 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 2 3 4




#pragma pack(push,_CRT_PACKING)
# 35 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
__extension__ typedef unsigned long long size_t;
# 45 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
# 62 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
__extension__ typedef long long intptr_t;
# 75 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
__extension__ typedef unsigned long long uintptr_t;
# 88 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
__extension__ typedef long long ptrdiff_t;
# 106 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
# 138 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
typedef __time64_t time_t;
# 422 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 8 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 2 3 4





extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
# 423 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_init_exception.h" 2 3
# 50 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/hash_bytes.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/hash_bytes.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }





    bool before(const type_info& __arg) const noexcept;
    bool operator==(const type_info& __arg) const noexcept;
# 136 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 1 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {

          void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
          (void)__cxxabiv1::__cxa_init_primary_exception(
       __e, const_cast<std::type_info*>(&typeid(__ex)),
       __exception_ptr::__dest_thunk<_Ex>);
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);



 }
      catch(...)
 {
   return current_exception();
 }



    }


}

}

#pragma GCC visibility pop
# 144 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/nested_exception.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 145 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/exception" 2 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));






void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/new" 3
#pragma GCC visibility pop
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 2 3






namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 111 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++allocator.h" 2 3


namespace std
{
# 47 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/memoryfwd.h" 1 3
# 46 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/memoryfwd.h" 3
       
# 47 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/memoryfwd.h" 3



namespace std
{

# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 48 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 2 3
# 57 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 3
namespace std
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }



  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_construct.h" 1 3
# 61 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_construct.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/alloc_traits.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/alloc_traits.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/alloc_traits.h" 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 1 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
namespace std
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };



  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;



}
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/alloc_traits.h" 2 3




namespace __gnu_cxx
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/alloc_traits.h" 3
  };


}
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_construct.h" 2 3

namespace std
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 232 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_construct.h" 3

}
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 1 3
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
namespace std
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 882 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_uninitialized.h" 3

}
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 1 3
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/initializer_list" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/initializer_list" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 2 3
# 74 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
namespace std
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
# 231 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 338 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 351 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 414 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 427 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 458 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 476 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 515 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 541 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 565 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 581 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 595 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 616 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 635 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 652 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 680 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 823 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 843 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 875 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 914 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 929 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 947 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 978 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 996 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1054 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1073 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1111 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1133 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1149 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1179 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1196 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1221 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1263 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1315 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1342 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1366 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1419 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1497 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1584 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1724 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
    };
# 1746 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1763 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



}
# 65 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 1 3
# 61 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 3



namespace std
{

# 49 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 2 3


namespace std
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
     || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl()
     noexcept(noexcept(_Bit_alloc_type()))
   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std
{


# 587 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 710 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 801 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1017 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));



 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1203 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, ++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/range_access.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/range_access.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/range_access.h" 3



namespace std
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }
# 323 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/range_access.h" 3

}
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/vector.tcc" 1 3
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/vector.tcc" 3
namespace std
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   ;
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     ;
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }
      ;
      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = __size;
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    __new_finish =
      std::__uninitialized_default_n_a(__new_finish, __n,
           _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  ;
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/vector" 2 3
# 5 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stringfwd.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stringfwd.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stringfwd.h" 3




namespace std
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 1 3
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3
       
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3




# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 25 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 41 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;



__attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __acrt_iob_func(unsigned index);


  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 81 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };
# 186 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pctype;
# 201 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__wctype;
# 216 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pwctype;
# 262 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);
  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);


  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);
# 409 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;



# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
# 424 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_stat64.h" 1 3
# 28 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
# 425 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
# 443 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);





                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);


                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);
# 525 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int swscanf(const wchar_t *__source, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vswscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int wscanf(const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwscanf( (__acrt_iob_func(0)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int fwscanf(FILE *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vswscanf (const wchar_t *__source, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vswscanf( __source, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwscanf( (__acrt_iob_func(0)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwscanf( __stream, __format, __local_argv );
}




static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int fwprintf (FILE *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int wprintf (const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwprintf( (__acrt_iob_func(1)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vfwprintf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int vwprintf (const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwprintf( (__acrt_iob_func(1)), __format, __local_argv );
}


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int snwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vsnwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
}
# 768 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);
# 831 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_l(wchar_t * __restrict__ ,size_t _SizeInWords,const wchar_t * __restrict__ _Format,_locale_t _Locale,... ) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;
# 1145 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,_locale_t _Plocinfo,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_l(wchar_t * __restrict__ _Dest,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,_locale_t _Plocinfo,va_list _Args) ;



# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/swprintf.inl" 1 3
# 25 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{

  return __mingw_vswprintf( __stream, __format, __local_argv );



}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
# 1179 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 1188 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 1235 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);

  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;




  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;





  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
# 1404 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
# 1416 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef int mbstate_t;
  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);
  int __attribute__((__cdecl__)) mbsinit(const mbstate_t *ps);
  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
# 1491 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 1505 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 1514 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);




}


#pragma pack(pop)

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 1 3
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 2 3
# 23 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
extern "C" {




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _waccess_s (const wchar_t *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wmktemp_s (wchar_t *_TemplateName,size_t _SizeInWords);




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _cgetws_s (wchar_t *_Buffer,size_t _SizeInWords,size_t *_SizeRead);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s (const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s (const wchar_t *_Format,va_list _ArgList);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline wchar_t* __attribute__((__cdecl__)) _getws_s(wchar_t (&_DstBuf)[__size]) { return _getws_s(_DstBuf,__size); } }
# 229 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  int __attribute__((__cdecl__)) fwprintf_s(FILE *_File,const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) swprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,...);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,...);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) swscanf_s(const wchar_t *_Src,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);


  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vswprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, va_list _ArgList) { return vswprintf_s(_Dst,__size,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) swprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vswprintf_s(_Dst,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, va_list _ArgList) { return _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t (&_DstBuf)[__size]) { return _wtmpnam_s(_DstBuf,__size); } }




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itow_s(int _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _itow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltow_s(long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ltow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultow_s(unsigned long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ultow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t* _ReturnSize, wchar_t (&_DstBuf)[__size], const wchar_t* _VarName) { return _wgetenv_s(_ReturnSize, _DstBuf, __size, _VarName); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);





  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t (&_PathResult)[__size], const wchar_t* _Drive, const wchar_t* _Dir, const wchar_t* _Filename, const wchar_t* _Ext) { return _wmakepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t* _Filename, const wchar_t* _EnvVar, wchar_t (&_ResultPath)[__size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, __size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }






  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val, size_t _Count,_locale_t _Locale);

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);
# 354 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t *_Retval,wchar_t *_Dst,size_t _SizeInWords,const char **_PSrc,size_t _N,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dst)[__size], const char** _PSrc, size_t _N, mbstate_t _State) { return mbsrtowcs_s(_Retval, _Dst, __size, _PSrc, _N, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,wchar_t _Ch,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t* _Retval, char (&_Dst)[__size], wchar_t _Ch, mbstate_t _State) { return wcrtomb_s(_Retval, _Dst, __size, _Ch, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,const wchar_t **_Src,size_t _Size,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t _Retval, char (&_Dst)[__size], const wchar_t** _Src, size_t _Size, mbstate_t _State) { return wcsrtombs_s(_Retval, _Dst, __size, _Src, _Size, _State); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemcpy_s (wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemmove_s(wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);



}
# 1525 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1527 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 45 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 2 3
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 2 3
# 68 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3
namespace std
{

# 90 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 2 3





namespace __gnu_cxx
{

# 61 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };



  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{

# 268 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {





   return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((wint_t)(0xFFFF)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdint" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdint" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdint" 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdint" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdint.h" 1 3 4
# 9 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdint.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdint.h" 1 3 4
# 32 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdint.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 33 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 10 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdint.h" 2 3 4
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 502 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/char_traits.h" 2 3

namespace std
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++locale.h" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++locale.h" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++locale.h" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/clocale" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/clocale" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/clocale" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/locale.h" 1 3
# 12 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/locale.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 12 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)


extern "C" {
# 82 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
__attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __acrt_iob_func(unsigned index);


  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 104 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ typedef long long fpos_t;
# 162 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
# 262 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
extern "C++" {


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sscanf(const char *__source, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int scanf(const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfscanf( (__acrt_iob_func(0)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fscanf(FILE *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsscanf (const char *__source, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsscanf( __source, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vscanf(const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfscanf( (__acrt_iob_func(0)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfscanf( __stream, __format, __local_argv );
}


#pragma GCC diagnostic pop





static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fprintf (FILE *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int printf (const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfprintf( (__acrt_iob_func(1)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sprintf (char *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfprintf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vprintf (const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfprintf( (__acrt_iob_func(1)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsprintf (char *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
int snprintf (char *__stream, size_t __n, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
int vsnprintf (char *__stream, size_t __n, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnprintf( __stream, __n, __format, __local_argv );
}
# 411 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
}
# 571 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);
  long __attribute__((__cdecl__)) ftell(FILE *_File);
# 631 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
# 654 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);


  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
# 712 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;

  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);
# 734 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;
# 811 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);
# 1290 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
# 1385 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);



}


#pragma pack(pop)

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 1 3
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 2 3
# 23 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) clearerr_s(FILE *_File);

  size_t __attribute__((__cdecl__)) fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
# 471 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
  int __attribute__((__cdecl__)) fprintf_s(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) printf_s(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_s_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) sscanf_s(const char *_Src,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s(const char *_Src,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) vfprintf_s(FILE *_File,const char *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf_s(const char *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__((dllimport)) int __attribute__((__cdecl__)) vsprintf_s(char *_DstBuf,size_t _Size,const char *_Format,va_list _ArgList);

  __attribute__((dllimport)) int __attribute__((__cdecl__)) sprintf_s(char *_DstBuf,size_t _DstSize,const char *_Format,...);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,...);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p(FILE *_File,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p(const char *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_l(char *_DstBuf,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_l(char *_DstBuf,const char *_Format,_locale_t,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_s_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *,_locale_t _Locale,va_list _ArgList);


  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsprintf_s(char (&_DstBuf)[__size], const char* _Format, va_list _ArgList) { return vsprintf_s(_DstBuf,__size,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) sprintf_s(char (&_DstBuf)[__size], const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vsprintf_s(_DstBuf,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) fopen_s(FILE **_File,const char *_Filename,const char *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) freopen_s(FILE** _File, const char *_Filename, const char *_Mode, FILE *_Stream);

  __attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) gets_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline char* __attribute__((__cdecl__)) get_s(char (&_DstBuf)[__size]) { return get_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) tmpnam_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) tmpnam_s(char (&_DstBuf)[__size]) { return tmpnam_s(_DstBuf,__size); } }
# 818 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);


}
# 1398 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1400 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdio.h" 2 3
# 13 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/locale.h" 2 3


#pragma pack(push,_CRT_PACKING)


extern "C" {
# 45 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/locale.h" 3
  struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
  };
# 79 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/locale.h" 3
  int __attribute__((__cdecl__)) _configthreadlocale(int _Flag);
  char *__attribute__((__cdecl__)) setlocale(int _Category,const char *_Locale);
  __attribute__ ((__dllimport__)) struct lconv *__attribute__((__cdecl__)) localeconv(void);
  __attribute__ ((__dllimport__)) _locale_t __attribute__((__cdecl__)) _get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) _create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) _free_locale(_locale_t _Locale);
  _locale_t __attribute__((__cdecl__)) __get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) __create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) __free_locale(_locale_t _Locale);







}


#pragma pack(pop)
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/clocale" 2 3
# 51 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __mingw_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iosfwd" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iosfwd" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iosfwd" 3





namespace std
{

# 74 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 1 3
# 12 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 3
extern "C" {
# 80 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 3
  extern const unsigned char __newclmap[];
  extern const unsigned char __newcumap[];
  extern pthreadlocinfo __ptlocinfo;
  extern pthreadmbcinfo __ptmbcinfo;
  extern int __globallocalestatus;
  extern int __locale_changed;
  extern struct threadlocaleinfostruct __initiallocinfo;
  extern _locale_tstruct __initiallocalestructinfo;
  pthreadlocinfo __attribute__((__cdecl__)) __updatetlocinfo(void);
  pthreadmbcinfo __attribute__((__cdecl__)) __updatetmbcinfo(void);
# 108 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype(int _C,int _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype_l(int _C,int _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalpha(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalpha_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) islower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _islower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isxdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isxdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isspace(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isspace_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ispunct(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ispunct_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalnum(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalnum_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isprint(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isprint_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isgraph(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isgraph_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) iscntrl(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iscntrl_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __isascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __toascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsymf(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsym(int _C);


int __attribute__((__cdecl__)) isblank(int _C);
# 203 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 3
  extern int * __imp___mb_cur_max;




__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
# 286 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/ctype.h" 3
}
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 2 3
# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 2 3

namespace std
{

# 55 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream_insert.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream_insert.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream_insert.h" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_forced.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_forced.h" 3
       
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 1 3
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
namespace std
{

# 104 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 166 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 350 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x > __y))
   return __x > __y;
 return (long long unsigned int)__x > (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x < __y))
   return __x < __y;
 return (long long unsigned int)__x < (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x >= __y))
   return __x >= __y;
 return (long long unsigned int)__x >= (long long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x <= __y))
   return __x <= __y;
 return (long long unsigned int)__x <= (long long unsigned int)__y;
      }
    };
# 761 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 854 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
   
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
# 978 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
     
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
   
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
     
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
   
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1055 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1178 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward/binders.h" 1 3
# 60 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{

# 107 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1369 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_function.h" 2 3
# 49 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 3


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr.h" 1 3
# 30 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 1 3
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 1 3
# 62 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 63 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/errno.h" 1 3
# 12 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/errno.h" 3
extern "C" {
# 239 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/errno.h" 3
}
# 64 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/types.h" 1 3
# 62 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/types.h" 3
__extension__
typedef long long _pid_t;




typedef _pid_t pid_t;





typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef unsigned int useconds_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};





__extension__
typedef unsigned long long _sigset_t;
# 65 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/corecrt_startup.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/corecrt_startup.h" 3
extern "C" {


__attribute__ ((__dllimport__)) char **__attribute__((__cdecl__)) __p__acmdln(void);


__attribute__ ((__dllimport__)) wchar_t **__attribute__((__cdecl__)) __p__wcmdln(void);


typedef void (__attribute__((__cdecl__)) *_PVFV)(void);
typedef int (__attribute__((__cdecl__)) *_PIFV)(void);
typedef void (__attribute__((__cdecl__)) *_PVFI)(int);

typedef struct _onexit_table_t {
    _PVFV* _first;
    _PVFV* _last;
    _PVFV* _end;
} _onexit_table_t;

typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);

__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _initialize_onexit_table(_onexit_table_t*);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _register_onexit_function(_onexit_table_t*,_onexit_t);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _execute_onexit_table(_onexit_table_t*);


}
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 2 3






extern "C" {
# 32 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 3
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthread(void (__attribute__((__cdecl__)) *_StartAddress) (void *),unsigned _StackSize,void *_ArgList);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthread(void) __attribute__ ((__noreturn__));
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthreadex(void *_Security,unsigned _StackSize,unsigned ( *_StartAddress) (void *),void *_ArgList,unsigned _InitFlag,unsigned *_ThrdAddr);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthreadex(unsigned _Retval) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));






       

  void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) abort(void);
       



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _cexit(void);
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _c_exit(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getpid(void);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _cwait(int *_TermStat,intptr_t _ProcHandle,int _Action);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execl(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execle(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlp(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlpe(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execv(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execve(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvp(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvpe(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnl(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnle(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlp(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlpe(int _Mode,const char *_Filename,const char *_ArgList,...);
# 85 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 3
  int __attribute__((__cdecl__)) system(const char *_Command);
# 117 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 3
  void __attribute__((__cdecl__)) __security_init_cookie(void);




  void __attribute__((__cdecl__)) __security_check_cookie(uintptr_t _StackCookie);
  __attribute__ ((__noreturn__)) void __attribute__((__cdecl__)) __report_gsfailure(uintptr_t _StackCookie);

  extern uintptr_t __security_cookie;

  intptr_t __attribute__((__cdecl__)) _loaddll(char *_Filename);
  int __attribute__((__cdecl__)) _unloaddll(intptr_t _Handle);
  int (__attribute__((__cdecl__)) *__attribute__((__cdecl__)) _getdllprocaddr(intptr_t _Handle,char *_ProcedureName,intptr_t _Ordinal))(void);
# 155 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/process.h" 3
  intptr_t __attribute__((__cdecl__)) cwait(int *_TermStat,intptr_t _ProcHandle,int _Action) ;

  int __attribute__((__cdecl__)) execl(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execle(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlp(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlpe(const char *_Filename,const char *_ArgList,...) ;






  intptr_t __attribute__((__cdecl__)) spawnl(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnle(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlp(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlpe(int,const char *_Filename,const char *_ArgList,...) ;


  int __attribute__((__cdecl__)) getpid(void) ;






  int __attribute__((__cdecl__)) execv(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execve(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  int __attribute__((__cdecl__)) execvp(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execvpe(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;






  intptr_t __attribute__((__cdecl__)) spawnv(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnve(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvp(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvpe(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;



}
# 67 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/syslimits.h" 1 3 4






# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 194 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/limits.h" 1 3 4
# 195 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 2 3 4
# 8 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/syslimits.h" 2 3 4
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 2 3 4
# 68 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/signal.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/signal.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread_signal.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/signal.h" 2 3


extern "C" {




  typedef int sig_atomic_t;
# 48 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/signal.h" 3
  typedef void (*__p_sig_fn_t)(int);
# 57 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/signal.h" 3
  extern void **__attribute__((__cdecl__)) __pxcptinfoptrs(void);


  __p_sig_fn_t __attribute__((__cdecl__)) signal(int _SigNum,__p_sig_fn_t _Func);
  int __attribute__((__cdecl__)) raise(int _SigNum);


}
# 69 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 15 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 53 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 3
  struct __timeb32 {
    __time32_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct __timeb64 {
    __time64_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime64(struct __timeb64 *_Time);



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime(struct __timeb64 *);
# 102 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 3
  void __attribute__((__cdecl__)) ftime (struct timeb *);
# 119 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 3
}


#pragma pack(pop)

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 2 3


extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime_s(struct __timeb32 *_Time);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime64_s(struct __timeb64 *_Time);







}
# 125 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/timeb.h" 2 3
# 71 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread_compat.h" 1 3 4
# 73 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3


extern "C" {
# 160 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
void * pthread_timechange_handler_np(void * dummy);
int pthread_delay_np (const struct timespec *interval);
int pthread_num_processors_np(void);
int pthread_set_num_processors_np(int n);
# 180 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
typedef long pthread_once_t;
typedef unsigned pthread_mutexattr_t;
typedef unsigned pthread_key_t;
typedef void *pthread_barrierattr_t;
typedef int pthread_condattr_t;
typedef int pthread_rwlockattr_t;
# 196 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
typedef uintptr_t pthread_t;

typedef struct _pthread_cleanup _pthread_cleanup;
struct _pthread_cleanup
{
    void (*func)(void *);
    void *arg;
    _pthread_cleanup *next;
};
# 239 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
struct sched_param {
  int sched_priority;
};

int sched_yield(void);
int sched_get_priority_min(int pol);
int sched_get_priority_max(int pol);
int sched_getscheduler(pid_t pid);
int sched_setscheduler(pid_t pid, int pol, const struct sched_param *param);



typedef struct pthread_attr_t pthread_attr_t;
struct pthread_attr_t
{
    unsigned p_state;
    void *stack;
    size_t s_size;
    struct sched_param param;
};

int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
int pthread_getschedparam(pthread_t thread, int *pol, struct sched_param *param);
int pthread_setschedparam(pthread_t thread, int pol, const struct sched_param *param);
int pthread_attr_setschedpolicy (pthread_attr_t *attr, int pol);
int pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *pol);


typedef void *pthread_spinlock_t;
typedef void *pthread_mutex_t;
typedef void *pthread_cond_t;
typedef void *pthread_rwlock_t;
typedef void *pthread_barrier_t;
# 291 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
extern void (**_pthread_key_dest)(void *);
int pthread_key_create(pthread_key_t *key, void (* dest)(void *));
int pthread_key_delete(pthread_key_t key);
void * pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);

pthread_t pthread_self(void);
int pthread_once(pthread_once_t *o, void (*func)(void));
void pthread_testcancel(void);
int pthread_equal(pthread_t t1, pthread_t t2);
void pthread_tls_init(void);
void _pthread_cleanup_dest(pthread_t t);
int pthread_get_concurrency(int *val);
int pthread_set_concurrency(int val);
void pthread_exit(void *res);
void _pthread_invoke_cancel(void);
int pthread_cancel(pthread_t t);
int pthread_kill(pthread_t t, int sig);
unsigned _pthread_get_state(const pthread_attr_t *attr, unsigned flag);
int _pthread_set_state(pthread_attr_t *attr, unsigned flag, unsigned val);
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
int pthread_create_wrapper(void *args);
int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);
int pthread_join(pthread_t t, void **res);
int pthread_detach(pthread_t t);
int pthread_setname_np(pthread_t thread, const char *name);
int pthread_getname_np(pthread_t thread, char *name, size_t len);


int pthread_rwlock_init(pthread_rwlock_t *rwlock_, const pthread_rwlockattr_t *attr);
int pthread_rwlock_wrlock(pthread_rwlock_t *l);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *ts);
int pthread_rwlock_rdlock(pthread_rwlock_t *l);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *l, const struct timespec *ts);
int pthread_rwlock_unlock(pthread_rwlock_t *l);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *l);
int pthread_rwlock_trywrlock(pthread_rwlock_t *l);
int pthread_rwlock_destroy (pthread_rwlock_t *l);

int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *a);
int pthread_cond_destroy(pthread_cond_t *cv);
int pthread_cond_signal (pthread_cond_t *cv);
int pthread_cond_broadcast (pthread_cond_t *cv);
int pthread_cond_wait (pthread_cond_t *cv, pthread_mutex_t *external_mutex);
int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);
int pthread_cond_timedwait_relative_np(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);

int pthread_mutex_lock(pthread_mutex_t *m);
int pthread_mutex_timedlock(pthread_mutex_t *m, const struct timespec *ts);
int pthread_mutex_unlock(pthread_mutex_t *m);
int pthread_mutex_trylock(pthread_mutex_t *m);
int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a);
int pthread_mutex_destroy(pthread_mutex_t *m);

int pthread_barrier_destroy(pthread_barrier_t *b);
int pthread_barrier_init(pthread_barrier_t *b, const void *attr, unsigned int count);
int pthread_barrier_wait(pthread_barrier_t *b);

int pthread_spin_init(pthread_spinlock_t *l, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *l);

int pthread_spin_lock(pthread_spinlock_t *l);
int pthread_spin_trylock(pthread_spinlock_t *l);
int pthread_spin_unlock(pthread_spinlock_t *l);

int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_setdetachstate(pthread_attr_t *a, int flag);
int pthread_attr_getdetachstate(const pthread_attr_t *a, int *flag);
int pthread_attr_setinheritsched(pthread_attr_t *a, int flag);
int pthread_attr_getinheritsched(const pthread_attr_t *a, int *flag);
int pthread_attr_setscope(pthread_attr_t *a, int flag);
int pthread_attr_getscope(const pthread_attr_t *a, int *flag);
int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stack);
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size);

int pthread_mutexattr_init(pthread_mutexattr_t *a);
int pthread_mutexattr_destroy(pthread_mutexattr_t *a);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t * a, int type);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *a, int * prio);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio);
int pthread_getconcurrency(void);
int pthread_setconcurrency(int new_level);

int pthread_condattr_destroy(pthread_condattr_t *a);
int pthread_condattr_init(pthread_condattr_t *a);
int pthread_condattr_getpshared(const pthread_condattr_t *a, int *s);
int pthread_condattr_setpshared(pthread_condattr_t *a, int s);


typedef int clockid_t;



int pthread_condattr_getclock (const pthread_condattr_t *attr,
       clockid_t *clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
       clockid_t clock_id);
int __pthread_clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

int pthread_barrierattr_init(void **attr);
int pthread_barrierattr_destroy(void **attr);
int pthread_barrierattr_setpshared(void **attr, int s);
int pthread_barrierattr_getpshared(void **attr, int *s);


struct _pthread_cleanup ** pthread_getclean (void);
void * pthread_gethandle (pthread_t t);
void * pthread_getevent ();

unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts);
unsigned long long _pthread_time_in_ms(void);
unsigned long long _pthread_time_in_ms_from_timespec(const struct timespec *ts);
int _pthread_tryjoin (pthread_t t, void **res);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s);
int pthread_rwlockattr_init(pthread_rwlockattr_t *a);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s);
# 428 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread_unistd.h" 1 3
# 429 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 2 3
# 689 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread.h" 3
}
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 2 3
# 47 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3



































# 298 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 658 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}



static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         2);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
# 149 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/atomic_word.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 2 3

namespace __gnu_cxx
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 2 3
# 52 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
namespace std
{



namespace __cxx11 {
# 76 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;
# 139 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 531 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 599 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 646 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 703 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 721 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 806 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 935 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 948 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 997 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1026 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1043 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1064 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1085 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1148 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1201 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1218 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1260 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1284 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1329 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1360 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1383 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1399 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1415 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1432 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1445 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1513 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1555 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1591 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1611 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1634 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1657 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1676 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1700 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1718 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1778 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1797 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1816 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1860 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1882 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1907 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1932 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1956 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1974 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1994 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2016 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2037 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2062 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2094 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2153 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2212 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2250 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2260 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2270 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2282 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2301 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2317 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2331 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2363 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2380 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2393 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2427 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2441 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2458 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2472 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2507 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2521 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2541 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2556 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2591 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2605 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2625 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2639 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2674 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2688 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2706 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2721 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2756 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2770 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2788 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2804 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2823 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2916 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2942 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2960 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 2984 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3011 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5886 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6007 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6054 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6092 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6130 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6168 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6206 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6244 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6264 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6282 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6305 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6322 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
# 75 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 25 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 49 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 59 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;

       


  typedef struct {
    long double x;
  } _LONGDOUBLE;

       

#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 142 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 158 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);
# 172 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;





  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p___argv(void);
  __attribute__ ((__dllimport__)) int *__attribute__((__cdecl__)) __p__fmode(void);
# 190 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);
# 281 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___argc;



  extern char *** __imp___argv;



  extern wchar_t *** __imp___wargv;





  extern char *** __imp__environ;




  extern wchar_t *** __imp__wenviron;





  extern char ** __imp__pgmptr;




  extern wchar_t ** __imp__wpgmptr;




  extern unsigned int * __imp__osplatform;




  extern unsigned int * __imp__osver;




  extern unsigned int * __imp__winver;




  extern unsigned int * __imp__winmajor;




  extern unsigned int * __imp__winminor;





  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }
# 379 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);


  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));


  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);

  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 449 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);







  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);




  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);


       
       


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);
       
       

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);
# 579 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 609 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);





       
       


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);
       
       
       
       


  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);
       
       
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);
# 656 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 680 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);
# 735 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 3
}


#pragma pack(pop)

# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 30 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 31 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 2 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 2 3




extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itoa_s(int _Value, char (&_Dest)[__size], int _Radix) { return _itoa_s(_Value, _Dest, __size, _Radix); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);
# 42 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }
# 65 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
# 741 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 1 3
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 65 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
       
       
# 97 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
       
       




void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/malloc.h" 3
}


#pragma pack(pop)
# 742 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 76 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/std_abs.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/std_abs.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/std_abs.h" 3
# 46 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/std_abs.h" 3
extern "C++"
{
namespace std
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 106 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/std_abs.h" 3

}
}
# 78 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 2 3
# 121 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwchar" 3
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 3
# 96 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;


  using ::gets;

  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 3
namespace __gnu_cxx
{
# 175 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 3
# 45 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/string_conversions.h" 2 3

namespace __gnu_cxx
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*_errno())) { (*_errno()) = 0; }
 ~_Save_errno() { if ((*_errno()) == 0) (*_errno()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*_errno()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6362 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 2 3

namespace std
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 6700 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.h" 3

}
# 53 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.tcc" 1 3
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.tcc" 3
       
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.tcc" 3



namespace std
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/string" 2 3
# 6 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../padroes/baseobject.h" 1





# 5 "..\\..\\CalculadorNumerico/calculador/../padroes/baseobject.h"
class BaseObject
{
    public:
        virtual ~BaseObject() {}
};
# 7 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h" 1



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/list" 1 3
# 58 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/list" 3
       
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/list" 3




# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 1 3
# 63 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocated_ptr.h" 1 3
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocated_ptr.h" 3

# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/allocated_ptr.h" 3
namespace std
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return std::__to_address(_M_ptr); }

    private:
      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/aligned_buffer.h" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/aligned_buffer.h" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 87 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 65 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 2 3


namespace std
{


  namespace __detail
  {







    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };


    struct _List_node_header : public _List_node_base
    {

      std::size_t _M_size;


      _List_node_header() noexcept
      { _M_init(); }


      _List_node_header(_List_node_header&& __x) noexcept
      : _List_node_base{ __x._M_next, __x._M_prev }

      , _M_size(__x._M_size)

      {
 if (__x._M_base()->_M_next == __x._M_base())
   this->_M_next = this->_M_prev = this;
 else
   {
     this->_M_next->_M_prev = this->_M_prev->_M_next = this->_M_base();
     __x._M_init();
   }
      }

      void
      _M_move_nodes(_List_node_header&& __x)
      {
 _List_node_base* const __xnode = __x._M_base();
 if (__xnode->_M_next == __xnode)
   _M_init();
 else
   {
     _List_node_base* const __node = this->_M_base();
     __node->_M_next = __xnode->_M_next;
     __node->_M_prev = __xnode->_M_prev;
     __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;

     _M_size = __x._M_size;

     __x._M_init();
   }
      }


      void
      _M_init() noexcept
      {
 this->_M_next = this->_M_prev = this;

 this->_M_size = 0;

      }

    private:
      _List_node_base* _M_base() { return this; }
    };
  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      __gnu_cxx::__aligned_membuf<_Tp> _M_storage;
      _Tp* _M_valptr() { return _M_storage._M_ptr(); }
      _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }





    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() noexcept
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) noexcept
      : _M_node(__x) { }

      _Self
      _M_const_cast() const noexcept
      { return *this; }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() noexcept
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      noexcept
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) noexcept
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }


      reference
      operator*() const noexcept
      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

namespace __cxx11 {

  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tp_alloc_traits;
      typedef typename _Tp_alloc_traits::template
 rebind<_List_node<_Tp> >::other _Node_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;


      static size_t
      _S_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last)
      {
 size_t __n = 0;
 while (__first != __last)
   {
     __first = __first->_M_next;
     ++__n;
   }
 return __n;
      }


      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_header _M_node;

 _List_impl() noexcept(noexcept(_Node_alloc_type()))
 : _Node_alloc_type()
 { }

 _List_impl(const _Node_alloc_type& __a) noexcept
 : _Node_alloc_type(__a)
 { }


 _List_impl(_List_impl&&) = default;

 _List_impl(_Node_alloc_type&& __a, _List_impl&& __x)
 : _Node_alloc_type(std::move(__a)), _M_node(std::move(__x._M_node))
 { }

 _List_impl(_Node_alloc_type&& __a) noexcept
 : _Node_alloc_type(std::move(__a))
 { }

      };

      _List_impl _M_impl;


      size_t _M_get_size() const { return _M_impl._M_node._M_size; }

      void _M_set_size(size_t __n) { _M_impl._M_node._M_size = __n; }

      void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }

      void _M_dec_size(size_t __n) { _M_impl._M_node._M_size -= __n; }


      size_t
      _M_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last) const
      { return _S_distance(__first, __last); }


      size_t _M_node_count() const { return _M_get_size(); }
# 447 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      typename _Node_alloc_traits::pointer
      _M_get_node()
      { return _Node_alloc_traits::allocate(_M_impl, 1); }

      void
      _M_put_node(typename _Node_alloc_traits::pointer __p) noexcept
      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return _M_impl; }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return _M_impl; }


      _List_base() = default;




      _List_base(const _Node_alloc_type& __a) noexcept
      : _M_impl(__a)
      { }


      _List_base(_List_base&&) = default;


      _List_base(_List_base&& __x, _Node_alloc_type&& __a)
      : _M_impl(std::move(__a))
      {
 if (__x._M_get_Node_allocator() == _M_get_Node_allocator())
   _M_move_nodes(std::move(__x));

      }



      _List_base(_Node_alloc_type&& __a, _List_base&& __x)
      : _M_impl(std::move(__a), std::move(__x._M_impl))
      { }


      _List_base(_Node_alloc_type&& __a)
      : _M_impl(std::move(__a))
      { }

      void
      _M_move_nodes(_List_base&& __x)
      { _M_impl._M_node._M_move_nodes(std::move(__x._M_impl._M_node)); }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear() noexcept;

      void
      _M_init() noexcept
      { this->_M_impl._M_node._M_init(); }
    };
# 562 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {
# 575 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::list must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::list must have the same value_type as its allocator");



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Tp_alloc_traits _Tp_alloc_traits;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;
      typedef typename _Base::_Node_alloc_traits _Node_alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_traits::pointer pointer;
      typedef typename _Tp_alloc_traits::const_pointer const_pointer;
      typedef typename _Tp_alloc_traits::reference reference;
      typedef typename _Tp_alloc_traits::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Node_allocator;
# 637 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename... _Args>
 _Node*
 _M_create_node(_Args&&... __args)
 {
   auto __p = this->_M_get_node();
   auto& __alloc = _M_get_Node_allocator();
   __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
   _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
     std::forward<_Args>(__args)...);
   __guard = nullptr;
   return __p;
 }



      static size_t
      _S_distance(const_iterator __first, const_iterator __last)
      { return std::distance(__first, __last); }


      size_t
      _M_node_count() const
      { return this->_M_get_size(); }
# 672 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
    public:







      list() = default;
# 689 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      explicit
      list(const allocator_type& __a) noexcept
      : _Base(_Node_alloc_type(__a)) { }
# 702 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      explicit
      list(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_default_initialize(__n); }
# 715 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 742 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(_Node_alloc_traits::
       _S_select_on_copy(__x._M_get_Node_allocator()))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 755 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list(list&&) = default;
# 765 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }

      list(const list& __x, const allocator_type& __a)
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }

    private:
      list(list&& __x, const allocator_type& __a, true_type) noexcept
      : _Base(_Node_alloc_type(__a), std::move(__x))
      { }

      list(list&& __x, const allocator_type& __a, false_type)
      : _Base(_Node_alloc_type(__a))
      {
 if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())
   this->_M_move_nodes(std::move(__x));
 else
   insert(begin(), std::__make_move_if_noexcept_iterator(__x.begin()),
     std::__make_move_if_noexcept_iterator(__x.end()));
      }

    public:
      list(list&& __x, const allocator_type& __a)
      noexcept(_Node_alloc_traits::_S_always_equal())
      : list(std::move(__x), __a,
      typename _Node_alloc_traits::is_always_equal{})
      { }
# 808 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 834 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      ~list() = default;
# 845 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 859 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      noexcept(_Node_alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Node_alloc_traits::_S_propagate_on_move_assign()
   || _Node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 877 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 895 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 912 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 936 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->_M_assign_dispatch(__l.begin(), __l.end(), __false_type()); }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_Base::_M_get_Node_allocator()); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return _M_node_count(); }


      size_type
      max_size() const noexcept
      { return _Node_alloc_traits::max_size(_M_get_Node_allocator()); }
# 1085 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      resize(size_type __new_size);
# 1098 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 1120 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1167 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>



 void

 emplace_front(_Args&&... __args)
 {
   this->_M_insert(begin(), std::forward<_Args>(__args)...);



 }
# 1203 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      pop_front() noexcept
      { this->_M_erase(begin()); }
# 1217 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   this->_M_insert(end(), std::forward<_Args>(__args)...);



 }
# 1252 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      pop_back() noexcept
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1269 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args);
# 1284 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1314 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1333 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1353 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
# 1392 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last);
# 1436 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator

      erase(const_iterator __position) noexcept;
# 1461 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last) noexcept



      {
 while (__first != __last)
   __first = erase(__first);
 return __last._M_const_cast();
      }
# 1484 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      swap(list& __x) noexcept
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);

 size_t __xsize = __x._M_get_size();
 __x._M_set_size(this->_M_get_size());
 this->_M_set_size(__xsize);

 _Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),
           __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
 _Base::_M_clear();
 _Base::_M_init();
      }
# 1523 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void

      splice(const_iterator __position, list&& __x) noexcept



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __x.begin(), __x.end());

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }


      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
# 1559 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
# 1574 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      {
 iterator __j = __i._M_const_cast();
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != std::__addressof(__x))
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position._M_const_cast(),
     __i._M_const_cast(), __j);

 this->_M_inc_size(1);
 __x._M_dec_size(1);
      }
# 1601 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
# 1620 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
      const_iterator __last) noexcept
# 1640 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      {
 if (__first != __last)
   {
     if (this != std::__addressof(__x))
       _M_check_equal_allocators(__x);

     size_t __n = _S_distance(__first, __last);
     this->_M_inc_size(__n);
     __x._M_dec_size(__n);

     this->_M_transfer(__position._M_const_cast(),
         __first._M_const_cast(),
         __last._M_const_cast());
   }
      }
# 1670 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
      const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
# 1687 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1701 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _Predicate>
 void
 remove_if(_Predicate);
# 1715 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      unique();
# 1730 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
 void
 unique(_BinaryPredicate);
# 1744 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
# 1769 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
 void
 merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
 void
 merge(list& __x, _StrictWeakOrdering __comp)
 { merge(std::move(__x), __comp); }
# 1788 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
 void
 sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
# 1866 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
# 1898 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
  this->_M_inc_size(1);
       }



      void
      _M_erase(iterator __position) noexcept
      {
 this->_M_dec_size(1);
 __position._M_node->_M_unhook();
 _Node* __n = static_cast<_Node*>(__position._M_node);

 _Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());




 _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x) noexcept
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __builtin_abort();
      }


      const_iterator
      _M_resize_pos(size_type& __new_size) const;


      void
      _M_move_assign(list&& __x, true_type) noexcept
      {
 this->_M_clear();
 this->_M_move_nodes(std::move(__x));
 std::__alloc_on_move(this->_M_get_Node_allocator(),
        __x._M_get_Node_allocator());
      }

      void
      _M_move_assign(list&& __x, false_type)
      {
 if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())
   _M_move_assign(std::move(__x), true_type{});
 else


   _M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()),
        std::__make_move_if_noexcept_iterator(__x.end()),
        __false_type{});
      }

    };
# 1972 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
}
# 1984 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {

      if (__x.size() != __y.size())
 return false;


      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 2018 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }






  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_iterator<_Tp> __first,
        std::_List_iterator<_Tp> __last,
        input_iterator_tag __tag)
    {
      typedef std::_List_const_iterator<_Tp> _CIter;
      return std::__distance(_CIter(__first), _CIter(__last), __tag);
    }

  template<typename _Tp>
    inline ptrdiff_t
    __distance(std::_List_const_iterator<_Tp> __first,
        std::_List_const_iterator<_Tp> __last,
        input_iterator_tag)
    {
      typedef __detail::_List_node_header _Sentinel;
      std::_List_const_iterator<_Tp> __beyond = __last;
      ++__beyond;
      const bool __whole = __first == __beyond;
      if (__builtin_constant_p (__whole) && __whole)
 return static_cast<const _Sentinel*>(__last._M_node)->_M_size;

      ptrdiff_t __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }



}
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/list" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/list.tcc" 1 3
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/list.tcc" 3
namespace std
{



  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() noexcept
    {
      typedef _List_node<_Tp> _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = static_cast<_Node*>(__cur);
   __cur = __tmp->_M_next;
   _Tp* __val = __tmp->_M_valptr();

   _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_const_cast()._M_node);
 this->_M_inc_size(1);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      this->_M_inc_size(1);
      return iterator(__tmp);
    }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
 {
   list __tmp(__n, __x, get_allocator());
   iterator __it = __tmp.begin();
   splice(__position, __tmp);
   return __it;
 }
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)
      {
 list __tmp(__first, __last, get_allocator());
 if (!__tmp.empty())
   {
     iterator __it = __tmp.begin();
     splice(__position, __tmp);
     return __it;
   }
 return __position._M_const_cast();
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    erase(const_iterator __position) noexcept



    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }
# 173 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::const_iterator
    list<_Tp, _Alloc>::
    _M_resize_pos(size_type& __new_size) const
    {
      const_iterator __i;

      const size_type __len = size();
      if (__new_size < __len)
 {
   if (__new_size <= __len / 2)
     {
       __i = begin();
       std::advance(__i, __new_size);
     }
   else
     {
       __i = end();
       ptrdiff_t __num_erase = __len - __new_size;
       std::advance(__i, -__num_erase);
     }
   __new_size = 0;
   return __i;
 }
      else
 __i = end();





      __new_size -= __len;
      return __i;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
 _M_default_append(__new_size);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      const_iterator __i = _M_resize_pos(__new_size);
      if (__new_size)
        insert(end(), __new_size, __x);
      else
        erase(__i, end());
    }
# 265 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != std::__addressof(__x))
 {

   if (_Node_alloc_traits::_S_propagate_on_copy_assign())
     {
              auto& __this_alloc = this->_M_get_Node_allocator();
              auto& __that_alloc = __x._M_get_Node_allocator();
              if (!_Node_alloc_traits::_S_always_equal()
           && __this_alloc != __that_alloc)
         {

    clear();
  }
       std::__alloc_on_copy(__this_alloc, __that_alloc);
            }

   _M_assign_dispatch(__x.begin(), __x.end(), __false_type());
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != std::__addressof(__x))
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   const size_t __orig_size = __x.size();
   try {
     while (__first1 != __last1 && __first2 != __last2)
       if (*__first2 < *__first1)
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
   catch(...)
     {
       const size_t __dist = std::distance(__first2, __last2);
       this->_M_inc_size(__orig_size - __dist);
       __x._M_set_size(__dist);
       throw;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != std::__addressof(__x))
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     const size_t __orig_size = __x.size();
     try
       {
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1))
      {
        iterator __next = __first2;
        _M_transfer(__first1, __first2, ++__next);
        __first2 = __next;
      }
    else
      ++__first1;
  if (__first2 != __last2)
    _M_transfer(__last1, __first2, __last2);

  this->_M_inc_size(__x._M_get_size());
  __x._M_set_size(0);
       }
     catch(...)
       {
  const size_t __dist = std::distance(__first2, __last2);
  this->_M_inc_size(__orig_size - __dist);
  __x._M_set_size(__dist);
  throw;
       }
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = __tmp;
        list * __counter;
 try
   {
     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = __tmp;
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = __tmp + 1; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1));
     swap( *(__fill - 1) );
   }
 catch(...)
   {
     this->splice(this->end(), __carry);
     for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)
       this->splice(this->end(), __tmp[__i]);
     throw;
   }
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = __tmp;
     list * __counter;
     try
       {
  do
    {
      __carry.splice(__carry.begin(), *this, begin());

      for(__counter = __tmp;
   __counter != __fill && !__counter->empty();
   ++__counter)
        {
   __counter->merge(__carry, __comp);
   __carry.swap(*__counter);
        }
      __carry.swap(*__counter);
      if (__counter == __fill)
        ++__fill;
    }
  while ( !empty() );

  for (__counter = __tmp + 1; __counter != __fill; ++__counter)
    __counter->merge(*(__counter - 1), __comp);
  swap(*(__fill - 1));
       }
     catch(...)
       {
  this->splice(this->end(), __carry);
  for (int __i = 0; __i < sizeof(__tmp)/sizeof(__tmp[0]); ++__i)
    this->splice(this->end(), __tmp[__i]);
  throw;
       }
   }
      }



}
# 65 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/list" 2 3
# 5 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../padroes/observer.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/../padroes/observer.h" 2

 
# 6 "..\\..\\CalculadorNumerico/calculador/../padroes/observer.h"
class Observable;
class Observer
{


  public:


    Observer(Observable *observable);
    Observer( );
    ~Observer( );
    void setObservable(Observable *observable);
    void removeObservable();
    virtual void update() = 0;
    Observable *getObservable()
    {
        return observable;
    }


  protected:

    Observable *observable;




};
# 6 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h" 2
# 1 "C:/temp/ballisticKernelCpp/CalculadorNumerico/padroes/baseobject.h" 1
# 7 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h" 2
using namespace std;
class Observer;



class Observable: public BaseObject
{
 private:
     list <class Observer *> observers;
     void *data;

    BaseObject *datum;

  protected:
        bool isObserved(){if(observers.size() > 0 ) return true; else return false;}

  public:
     Observable();
      ~Observable()
      {
          if(isObserved())
            observers.clear();
      };
    void attach(Observer *obs)
    {
        observers.push_back(obs);
    }

    void detach(Observer *obs)
    {
        observers.remove(obs);
    }

    void setData(void *data)
    {
        this->data = data;

    }

    void *getData()
    {
        return data;
    }

    void setDatum(BaseObject *objeto)
    {
        this->datum = objeto;

    }

    BaseObject *getDatum()
    {
        return datum;
    }
# 71 "..\\..\\CalculadorNumerico/calculador/../padroes/observable.h"
    void notify();

    void unattach(Observer *obs)
    {

    }
};
# 8 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/elementosdisparo.h" 1





class ElementosDisparo: public BaseObject
{
    public:
        ElementosDisparo();
        ElementosDisparo(double elevacao, double correcaoDeriva, bool sucesso = true);
        double getContraderivacao(){return correcaoDeriva;}
        double getElevacao(){return elevacao;}
        bool getSucesso(){return sucesso;}
        void setElementosDisparo(double elevacao, double correcaoDeriva, bool sucesso);
    protected:
    private:
        bool sucesso;
        double elevacao;
        double correcaoDeriva;

};
# 9 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/elementosvoo.h" 1






class ElementosVoo:public BaseObject
{
public:
    void set(double anguloDisparo, double sx, double sy, double sz, double vx, double vy, double vz, double ar, double tempo);
    void setArMax(double ar_max){this->ar_max = ar_max;}
    void setAlturaMax(double altura_max){this->altura_max = altura_max;}
    ElementosVoo( );

    double anguloDisparo;
    double sx, sy, sz;
    double vx, vy, vz;
    double altura_max, ar_max, ar, tempo;
};
# 10 "..\\..\\CalculadorNumerico/calculador/calculador.h" 2







enum class TIPO_TRAJETORIA {MERGULHANTE, VERTICAL};

enum RAMO{ASCENDENTE, DESCENDENTE};

class Calculador
{

    public:

        Calculador();
        ~Calculador();

        void setAnguloInicial(double angulo){this->ang = angulo;}
        int getIntervaloAmostras(){return intervaloAmostras;}
        void setIntervaloAmostras(int i){intervaloAmostras = i;}
        void setCorrecaoLatitude( bool correcaoLatitude){ this->correcaoLatitude = correcaoLatitude; }
        bool isCorrecaoLatitude(){return correcaoLatitude;}
        void setLatitude(double latitude){this->latitude = latitude;}
        void setVo(double vel);
        void setPausado(bool estado);
        bool isPausado();
        void setParado(bool estado);
        bool isParado();
        Observable *getObservable(){return observavel;}
        int intervaloEntreAmostras(double passo);







        virtual vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE) = 0;
        ElementosVoo solucaoDiretaUltimoElemento(double angulo, double vo, double desnivel, double passo, RAMO ramo = DESCENDENTE);
# 61 "..\\..\\CalculadorNumerico/calculador/calculador.h"
        virtual ElementosDisparo solucaoReversa(double alcance, double vo, double desnivel, TIPO_TRAJETORIA trajetoria, double passo, double precisao, double angulo_inicial = 1.0, RAMO ramo = DESCENDENTE) =0;

        std::string getNome(){return nome;};

    protected:
        Observable *observavel;
        std::string nome;
        double gravidadeLocal;

        double calculaGravidadeLocal(double latitude);
        bool ehRamoDeParada(RAMO ramo, double vy);
        double gravx(double distancia);
        double gravy(double altitude);
        double gravz(double lateral);



        double poly(double valor, int grau, double *coef);
        double v(double vx, double vy, double vz);


        double ang ;


        double vo;
        int intervaloAmostras;



        bool correcaoLatitude;

        double latitude;

        bool pausado;
        bool parado;


};
# 5 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../projetil/projetil.h" 1



# 1 "C:/temp/ballisticKernelCpp/CalculadorNumerico/padroes/baseobject.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/../projetil/projetil.h" 2
using namespace std;
enum class TIPO_PROJETIL {PJT_105M1, PJT_155_M107, PJT_155_M483E1};
enum class TIPO_FORCAS {DRAG_LIFT, NORMAL_AXIAL};
class Projetil: public BaseObject
{


    public:
        Projetil(){}
        Projetil(TIPO_PROJETIL tipo);
        string getNome(){return nome;}
        string getTabelaCoeficientesNome(){return tabelaCoeficientesNome;}
        double getDiametro(){return diametro;}
        double getIx(){return ix;}
        double getMassa(){return massa;}
        double getMassaTotal(){return massa + (numero_quadrados - quadrados_padrao)*massa_quadrado;}
        double getNumeroQuadrados(){return numero_quadrados;}
        double getQuadradosPadrao(){return quadrados_padrao;}
        double getMassaQuadrado(){return massa_quadrado;}
        TIPO_PROJETIL getTipo(){return tipo;}
        TIPO_FORCAS getTipoForcas(){return tipoForcas;}

        void setNome(string nome){this->nome = nome;}
        void setNome(char *nomeStr){nome = nomeStr;}
        void setTabelaCoeficientesNome(string tabelaCoeficientesNome){this->tabelaCoeficientesNome = tabelaCoeficientesNome;}
        void setTabelaCoeficientesNome(char *tabelaCoeficientesNomeStr){tabelaCoeficientesNome = tabelaCoeficientesNomeStr;}
        void setDiametro(double diametro){this->diametro = diametro;}
        void setIx(double ix){this->ix =ix;}
        void setMassa(double massa){this->massa = massa;}
        void setNumeroQuadrados(double numero_quadrados){this->numero_quadrados = numero_quadrados;}
        void setNumeroQuadradosPadrao(){numero_quadrados = quadrados_padrao;}
        void setQuadradosPadrao(double quadrados_padrao){this->quadrados_padrao = quadrados_padrao;}
        void setMassaQuadrado(double massa_quadrado){this->massa_quadrado = massa_quadrado;}

        void setTipo(TIPO_PROJETIL tipo){this->tipo = tipo;}
        void setTipoForcas(TIPO_FORCAS tipoForcas){this->tipoForcas = tipoForcas;}

    protected:
    private:
      TIPO_PROJETIL tipo;
      TIPO_FORCAS tipoForcas;
      string nome, tabelaCoeficientesNome;
      double ix, diametro, massa;
      double numero_quadrados, quadrados_padrao, massa_quadrado;
};
# 6 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosfera.h" 1



# 1 "C:/temp/ballisticKernelCpp/CalculadorNumerico/padroes/baseobject.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosfera.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/./pesoDensidade/pesoDensidade.h" 1




class PesoDensidade
{
    public:
        PesoDensidade();
         virtual double getPesoDensidade(double altura)=0;

    protected:

    private:
};
# 6 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosfera.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/./pesoTemperatura/pesoTemperatura.h" 1




class PesoTemperatura
{
    public:
        PesoTemperatura();
        virtual double getPesoTemperatura(double altura)=0;

    protected:

    private:
};
# 7 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosfera.h" 2




class Atmosfera: public BaseObject
{
protected:
    static constexpr double Reynold = 287.04;
    static constexpr double ro_solo = 1.225;
    static constexpr double To = 288.15;
    static constexpr double Po = 101325.0;
    PesoDensidade *pesoDens;
    PesoTemperatura *pesoTemp;

public:
    Atmosfera();
    virtual double temperatura(double altitude) = 0;
    virtual double velocidadeSom(double altitude) = 0;
    virtual double densidade(double altitude) = 0;
    virtual std::string toString() = 0;
    void setPesoDensidade(PesoDensidade *pesoDens){this->pesoDens = pesoDens;}
    void setPesoTemperatura(PesoTemperatura *pesoTemp){this->pesoTemp = pesoTemp;}
    double getRoSolo();

};
# 7 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosferaicao.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosfera.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosferaicao.h" 2


class AtmosferaIcao : public Atmosfera
{
public:
    AtmosferaIcao();
    double temperatura(double altitude);
    double velocidadeSom(double altitude);
    double densidade(double altitude);
    std::string toString(){return "ICAO";}
};
# 8 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosferaisa.h" 1







class AtmosferaIsa: public Atmosfera
{
public:
    AtmosferaIsa();
    double temperatura(double altitude);
    double velocidadeSom(double altitude);
    double densidade(double altitude);
    std::string toString(){return "ISA";}
};
# 9 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/atmosferausstandard.h" 1







class AtmosferaUsStandard: public Atmosfera
{
public:
    AtmosferaUsStandard();
    double temperatura(double altitude);
    double velocidadeSom(double altitude);
    double densidade(double altitude);
    std::string toString(){return "US STANDARD";}
};
# 10 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../atmosfera/vento/vento.h" 1




class Vento
{
    public:
        Vento();
        virtual ~Vento();

        virtual double getVelocidadeVentoTransversal(double altura)=0;
        virtual double getVelocidadeVentoLongitudinal(double altura)=0;


    protected:

    private:
};
# 11 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 2
# 23 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h"
class CalculadorAtmosferico: public Calculador
{
    public:
        CalculadorAtmosferico();
        Atmosfera *getAtmosfera() const {return atmos;}
        double getLimiteHorizontal(){return limiteHorizontal;}
        double getMassaTotal(){return projetil.getMassaTotal();}
        double getNumeroQuadrados(){return projetil.getNumeroQuadrados();}
        double getQuadradosPadrao(){return projetil.getQuadradosPadrao();}
        double getVentoLongitudinal(double altura);
        double getVentoTransversal(double altura);
        bool isChecarLimite(){return checarLimite;}
        bool isLimiteHorizontalAtivo(){return limiteHorizontalAtivo;}
        void setAtmosfera(Atmosfera *atmosfera);
        void setChecarLimite(bool checarLimite){this->checarLimite = checarLimite;}
        void setCoriolis( bool coriolis){this->coriolis = coriolis;}
        void setLancamento(double lancamento){this->lancamento = lancamento;}
        void setLimiteHorizontal(double limite){limiteHorizontal = limite;}
        void setLimiteHorizontalAtivo(bool ativado){limiteHorizontalAtivo = ativado;}
        void setProjetil(Projetil projetil);
        void setNumeroQuadrados(double numeroQuadrados);
        void setNumeroQuadradosPadrao( );
        void setPesoDensidade(PesoDensidade *peso);
        void setPesoTemperatura(PesoTemperatura *peso);
        void setVento(Vento *vento);
        bool isCoriolis(){return coriolis;}
        ElementosVoo limite(double vo, double passo);
        ElementosDisparo solucaoReversa(double alcance, double vo, double desnivel, TIPO_TRAJETORIA trajetoria, double passo, double precisao, double angulo_inicial = 1.0, RAMO ramo = DESCENDENTE);
        void gerarTabela(double vo, TIPO_TRAJETORIA trajetoria, double passo, double precisao);

    protected:
        double vel_som(double temperatura);
        double vel_mach(double vel_absoluta, double altitude);
        double acCoriolisx(double latitude, double lancamento, double vy, double vz);
        double acCoriolisy(double latitude, double lancamento, double vx, double vz);
        double acCoriolisz(double latitude, double lancamento, double vx, double vy);
        void checaCondicaoDeParada(double angulo, double desnivel, bool registrarElementosIntermediarios, double &passo, RAMO ramo);
        double filtroDeltaAngular(double delta);
        Projetil projetil;
        Vento *vento;
        Atmosfera *atmos;


        double k;

        double diametro = 0.1049;

        double A;
        double alcance_normal;
        double velocidade_do_som;

        double lancamento;
        double limiteHorizontal;
        bool limiteHorizontalAtivo;

        bool coriolis;
        bool checarLimite;



        vector <ElementosVoo> elementosVooVector;
        double sx, sy, sz;
        double vx, vy, vz;
        double tempo;
        double ar_atual;

        bool descida;
        bool ultimaIteracao;
        bool terminado;
        double syEsferico;
        double altura_max;
        double ar_max;


    private:
};
# 6 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\GeradorTabular.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 1
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 1
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 1
# 173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/compiler.h" 1
# 174 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 2
# 183 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\lib\\gcc810_x64_dll\\mswud/wx/setup.h" 1
# 184 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 2
# 438 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/libraries.h" 1
# 439 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 2
# 456 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gccpriv.h" 1
# 36 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gccpriv.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw.h" 1 3
# 37 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gccpriv.h" 2
# 83 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gccpriv.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/w32api.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/w32api.h" 3
       
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/w32api.h" 3
# 84 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gccpriv.h" 2
# 457 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 2
# 596 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chkconf.h" 1
# 1222 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chkconf.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/chkconf.h" 1
# 1223 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chkconf.h" 2
# 597 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platform.h" 2
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2
# 193 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/version.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/version.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cpp.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/version.h" 2
# 194 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2
# 239 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef short int WXTYPE;
# 570 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dlimpexp.h" 1
# 571 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2
# 739 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 740 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2





# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/assert.h" 1 3
# 17 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/assert.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cstdlib" 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 2 3


# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 3
using std::abort;
using std::atexit;
using std::exit;
# 51 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 18 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/assert.h" 2 3



extern "C" {
# 45 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 2


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h" 1
# 104 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 105 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 1 3
# 21 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
# 45 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);







  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;
# 187 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 3
}


# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
# 23 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } };
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
# 82 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
}
# 191 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/string.h" 2 3
# 106 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h" 2
# 120 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 1 3
# 16 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 3
extern "C" {
# 89 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 3
}





extern "C" {
# 110 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 3
  typedef wchar_t _TCHAR;
  typedef wchar_t _TSCHAR;
  typedef wchar_t _TUCHAR;
  typedef wchar_t _TXCHAR;
  typedef wint_t _TINT;





  typedef wchar_t TCHAR,*PTCHAR;
  typedef wchar_t TBYTE,*PTBYTE;
# 464 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 3
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) __wcsncnt(const wchar_t *_Str,size_t _MaxCount);
# 1128 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 3
}



# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/tchar_s.h" 1 3
# 9 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/tchar_s.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/tchar_s.h" 2 3




extern "C" {
# 263 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sec_api/tchar_s.h" 3
}
# 1133 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/tchar.h" 2 3
# 121 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h" 2
# 156 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h"
        
# 156 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h"
       typedef wchar_t wxChar;
        typedef wchar_t wxSChar;
        typedef wchar_t wxUChar;
# 208 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/chartype.h"
    typedef wchar_t wxStringCharType;
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 2



class wxString;
class wxCStrData;
# 78 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
typedef void (*wxAssertHandler_t)(const wxString& file,
                                  int line,
                                  const wxString& func,
                                  const wxString& cond,
                                  const wxString& msg);





extern wxAssertHandler_t wxTheAssertHandler;
# 114 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
inline wxAssertHandler_t wxSetAssertHandler(wxAssertHandler_t handler)
{
    const wxAssertHandler_t old = wxTheAssertHandler;
    wxTheAssertHandler = handler;
    return old;
}







extern void wxSetDefaultAssertHandler();
# 145 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
inline void wxDisableAsserts() { wxSetAssertHandler(
# 145 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 3 4
                                                   __null
# 145 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
                                                       ); }
# 180 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
extern void wxOnAssert(const char *file,
                                        int line,
                                        const char *func,
                                        const char *cond);

extern void wxOnAssert(const char *file,
                                        int line,
                                        const char *func,
                                        const char *cond,
                                        const char *msg);

extern void wxOnAssert(const char *file,
                                        int line,
                                        const char *func,
                                        const char *cond,
                                        const wxChar *msg) ;





extern void wxOnAssert(const wxChar *file,
                                        int line,
                                        const char *func,
                                        const wxChar *cond,
                                        const wxChar *msg = 
# 205 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h" 3 4
                                                           __null
# 205 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
                                                               );




extern void wxOnAssert(const wxString& file,
                                        int line,
                                        const wxString& func,
                                        const wxString& cond,
                                        const wxString& msg);

extern void wxOnAssert(const wxString& file,
                                        int line,
                                        const wxString& func,
                                        const wxString& cond);

extern void wxOnAssert(const char *file,
                                        int line,
                                        const char *func,
                                        const char *cond,
                                        const wxCStrData& msg);

extern void wxOnAssert(const char *file,
                                        int line,
                                        const char *func,
                                        const char *cond,
                                        const wxString& msg);
# 262 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
        extern void wxTrap();





    extern bool wxTrapInAssert;
# 332 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
extern void wxAbort();
# 467 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
    extern bool wxIsDebuggerRunning();
# 479 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/debug.h"
extern bool wxAssertIsEqual(int x, int y);



extern const bool wxFalse;
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2


    template <typename T>
    inline void wxDELETE(T*& ptr)
    {
        typedef char TypeIsCompleteCheck[sizeof(T)] __attribute__ ((unused));

        if ( ptr != 
# 753 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 3 4
                   __null 
# 753 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
                        )
        {
            delete ptr;
            ptr = 
# 756 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 3 4
                 __null
# 756 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
                     ;
        }
    }


    template <typename T>
    inline void wxDELETEA(T*& ptr)
    {
        typedef char TypeIsCompleteCheck[sizeof(T)] __attribute__ ((unused));

        if ( ptr != 
# 766 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 3 4
                   __null 
# 766 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
                        )
        {
            delete [] ptr;
            ptr = 
# 769 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 3 4
                 __null
# 769 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
                     ;
        }
    }


    template <typename T>
    inline void wxSwap(T& first, T& second)
    {
        T tmp(first);
        first = second;
        second = tmp;
    }
# 911 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
        template <class T>
            inline void wxUnusedVar(const T& ) { }
# 938 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef int wxCoord;

enum { wxDefaultCoord = -1 };
# 954 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef signed char wxInt8;
typedef unsigned char wxUint8;
typedef wxUint8 wxByte;
# 968 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef signed short wxInt16;
typedef unsigned short wxUint16;

typedef wxUint16 wxWord;
# 998 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
        typedef int wxInt32;
        typedef unsigned int wxUint32;
# 1125 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef wxUint32 wxDword;
# 1215 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    typedef long long wxInt64;
    typedef unsigned long long wxUint64;
# 1312 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    typedef ssize_t wxIntPtr;
    typedef size_t wxUIntPtr;
# 1324 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
inline wxUIntPtr wxPtrToUInt(const void *p)
{
# 1343 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    return reinterpret_cast<wxUIntPtr>(p);




}

inline void *wxUIntToPtr(wxUIntPtr p)
{
# 1364 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    return reinterpret_cast<void *>(p);




}
# 1381 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef float wxFloat32;
typedef double wxFloat64;

typedef double wxDouble;
# 1429 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    typedef wchar_t wxChar16;
# 1438 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    typedef wxUint32 wxChar32;
# 1663 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
enum wxGeometryCentre
{
    wxCENTRE = 0x0001,
    wxCENTER = wxCENTRE
};







enum wxOrientation
{

    wxHORIZONTAL = 0x0004,
    wxVERTICAL = 0x0008,

    wxBOTH = wxVERTICAL | wxHORIZONTAL,


    wxORIENTATION_MASK = wxBOTH
};

enum wxDirection
{
    wxLEFT = 0x0010,
    wxRIGHT = 0x0020,
    wxUP = 0x0040,
    wxDOWN = 0x0080,

    wxTOP = wxUP,
    wxBOTTOM = wxDOWN,

    wxNORTH = wxUP,
    wxSOUTH = wxDOWN,
    wxWEST = wxLEFT,
    wxEAST = wxRIGHT,

    wxALL = (wxUP | wxDOWN | wxRIGHT | wxLEFT),


    wxDIRECTION_MASK = wxALL
};

enum wxAlignment
{





    wxALIGN_INVALID = -1,

    wxALIGN_NOT = 0x0000,
    wxALIGN_CENTER_HORIZONTAL = 0x0100,
    wxALIGN_CENTRE_HORIZONTAL = wxALIGN_CENTER_HORIZONTAL,
    wxALIGN_LEFT = wxALIGN_NOT,
    wxALIGN_TOP = wxALIGN_NOT,
    wxALIGN_RIGHT = 0x0200,
    wxALIGN_BOTTOM = 0x0400,
    wxALIGN_CENTER_VERTICAL = 0x0800,
    wxALIGN_CENTRE_VERTICAL = wxALIGN_CENTER_VERTICAL,

    wxALIGN_CENTER = (wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL),
    wxALIGN_CENTRE = wxALIGN_CENTER,


    wxALIGN_MASK = 0x0f00
};


enum wxSizerFlagBits
{







    wxADJUST_MINSIZE = 0,

    wxFIXED_MINSIZE = 0x8000,
    wxRESERVE_SPACE_EVEN_IF_HIDDEN = 0x0002,


    wxSIZER_FLAG_BITS_MASK = 0x8002
};

enum wxStretch
{
    wxSTRETCH_NOT = 0x0000,
    wxSHRINK = 0x1000,
    wxGROW = 0x2000,
    wxEXPAND = wxGROW,
    wxSHAPED = 0x4000,
    wxTILE = wxSHAPED | wxFIXED_MINSIZE,


    wxSTRETCH_MASK = 0x7000
};


enum wxBorder
{


    wxBORDER_DEFAULT = 0,

    wxBORDER_NONE = 0x00200000,
    wxBORDER_STATIC = 0x01000000,
    wxBORDER_SIMPLE = 0x02000000,
    wxBORDER_RAISED = 0x04000000,
    wxBORDER_SUNKEN = 0x08000000,
    wxBORDER_DOUBLE = 0x10000000,
    wxBORDER_THEME = wxBORDER_DOUBLE,


    wxBORDER_MASK = 0x1f200000
};
# 2129 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
enum wxBackgroundStyle
{





    wxBG_STYLE_ERASE,





    wxBG_STYLE_SYSTEM,






    wxBG_STYLE_PAINT,





    wxBG_STYLE_TRANSPARENT,


    wxBG_STYLE_COLOUR,





    wxBG_STYLE_CUSTOM = wxBG_STYLE_PAINT
};




enum wxKeyType
{
    wxKEY_NONE,
    wxKEY_INTEGER,
    wxKEY_STRING
};






enum wxStandardID
{
# 2195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    wxID_AUTO_LOWEST = -32000,
    wxID_AUTO_HIGHEST = -2000,






    wxID_NONE = -3,


    wxID_SEPARATOR = -2,



    wxID_ANY = -1,



    wxID_LOWEST = 4999,

    wxID_OPEN,
    wxID_CLOSE,
    wxID_NEW,
    wxID_SAVE,
    wxID_SAVEAS,
    wxID_REVERT,
    wxID_EXIT,
    wxID_UNDO,
    wxID_REDO,
    wxID_HELP,
    wxID_PRINT,
    wxID_PRINT_SETUP,
    wxID_PAGE_SETUP,
    wxID_PREVIEW,
    wxID_ABOUT,
    wxID_HELP_CONTENTS,
    wxID_HELP_INDEX,
    wxID_HELP_SEARCH,
    wxID_HELP_COMMANDS,
    wxID_HELP_PROCEDURES,
    wxID_HELP_CONTEXT,
    wxID_CLOSE_ALL,
    wxID_PREFERENCES,

    wxID_EDIT = 5030,
    wxID_CUT,
    wxID_COPY,
    wxID_PASTE,
    wxID_CLEAR,
    wxID_FIND,
    wxID_DUPLICATE,
    wxID_SELECTALL,
    wxID_DELETE,
    wxID_REPLACE,
    wxID_REPLACE_ALL,
    wxID_PROPERTIES,

    wxID_VIEW_DETAILS,
    wxID_VIEW_LARGEICONS,
    wxID_VIEW_SMALLICONS,
    wxID_VIEW_LIST,
    wxID_VIEW_SORTDATE,
    wxID_VIEW_SORTNAME,
    wxID_VIEW_SORTSIZE,
    wxID_VIEW_SORTTYPE,

    wxID_FILE = 5050,
    wxID_FILE1,
    wxID_FILE2,
    wxID_FILE3,
    wxID_FILE4,
    wxID_FILE5,
    wxID_FILE6,
    wxID_FILE7,
    wxID_FILE8,
    wxID_FILE9,


    wxID_OK = 5100,
    wxID_CANCEL,
    wxID_APPLY,
    wxID_YES,
    wxID_NO,
    wxID_STATIC,
    wxID_FORWARD,
    wxID_BACKWARD,
    wxID_DEFAULT,
    wxID_MORE,
    wxID_SETUP,
    wxID_RESET,
    wxID_CONTEXT_HELP,
    wxID_YESTOALL,
    wxID_NOTOALL,
    wxID_ABORT,
    wxID_RETRY,
    wxID_IGNORE,
    wxID_ADD,
    wxID_REMOVE,

    wxID_UP,
    wxID_DOWN,
    wxID_HOME,
    wxID_REFRESH,
    wxID_STOP,
    wxID_INDEX,

    wxID_BOLD,
    wxID_ITALIC,
    wxID_JUSTIFY_CENTER,
    wxID_JUSTIFY_FILL,
    wxID_JUSTIFY_RIGHT,
    wxID_JUSTIFY_LEFT,
    wxID_UNDERLINE,
    wxID_INDENT,
    wxID_UNINDENT,
    wxID_ZOOM_100,
    wxID_ZOOM_FIT,
    wxID_ZOOM_IN,
    wxID_ZOOM_OUT,
    wxID_UNDELETE,
    wxID_REVERT_TO_SAVED,
    wxID_CDROM,
    wxID_CONVERT,
    wxID_EXECUTE,
    wxID_FLOPPY,
    wxID_HARDDISK,
    wxID_BOTTOM,
    wxID_FIRST,
    wxID_LAST,
    wxID_TOP,
    wxID_INFO,
    wxID_JUMP_TO,
    wxID_NETWORK,
    wxID_SELECT_COLOR,
    wxID_SELECT_FONT,
    wxID_SORT_ASCENDING,
    wxID_SORT_DESCENDING,
    wxID_SPELL_CHECK,
    wxID_STRIKETHROUGH,


    wxID_SYSTEM_MENU = 5200,
    wxID_CLOSE_FRAME,
    wxID_MOVE_FRAME,
    wxID_RESIZE_FRAME,
    wxID_MAXIMIZE_FRAME,
    wxID_ICONIZE_FRAME,
    wxID_RESTORE_FRAME,


    wxID_MDI_WINDOW_FIRST = 5230,
    wxID_MDI_WINDOW_CASCADE = wxID_MDI_WINDOW_FIRST,
    wxID_MDI_WINDOW_TILE_HORZ,
    wxID_MDI_WINDOW_TILE_VERT,
    wxID_MDI_WINDOW_ARRANGE_ICONS,
    wxID_MDI_WINDOW_PREV,
    wxID_MDI_WINDOW_NEXT,
    wxID_MDI_WINDOW_LAST = wxID_MDI_WINDOW_NEXT,


    wxID_OSX_MENU_FIRST = 5250,
    wxID_OSX_HIDE = wxID_OSX_MENU_FIRST,
    wxID_OSX_HIDEOTHERS,
    wxID_OSX_SHOWALL,

    wxID_OSX_SERVICES,
    wxID_OSX_MENU_LAST = wxID_OSX_SERVICES,





    wxID_FILEDLGG = 5900,


    wxID_FILECTRL = 5950,

    wxID_HIGHEST = 5999
};
# 2386 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/windowid.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/windowid.h"
typedef int wxWindowID;
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/windowid.h"
class wxWindowIDRef
{
public:

    wxWindowIDRef()
    {
        m_id = wxID_NONE;
    }


    wxWindowIDRef(int id)
    {
        Init(id);
    }

    wxWindowIDRef(long id)
    {
        Init(wxWindowID(id));
    }

    wxWindowIDRef(const wxWindowIDRef& id)
    {
        Init(id.m_id);
    }


    ~wxWindowIDRef()
    {
        Assign(wxID_NONE);
    }


    wxWindowIDRef& operator=(int id)
    {
        Assign(id);
        return *this;
    }

    wxWindowIDRef& operator=(long id)
    {
        Assign(wxWindowID(id));
        return *this;
    }

    wxWindowIDRef& operator=(const wxWindowIDRef& id)
    {
        if (&id != this)
            Assign(id.m_id);
        return *this;
    }


    wxWindowID GetValue() const
    {
        return m_id;
    }

    operator wxWindowID() const
    {
        return m_id;
    }

private:


    void Init(wxWindowID id)
    {

        m_id = wxID_NONE;
        Assign(id);
    }


    void Assign(wxWindowID id);
# 116 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/windowid.h"
    wxWindowID m_id;
};


inline bool operator==(const wxWindowIDRef& lhs, const wxWindowIDRef& rhs)
{
    return lhs.GetValue() == rhs.GetValue();
}

inline bool operator==(const wxWindowIDRef& lhs, int rhs)
{
    return lhs.GetValue() == rhs;
}

inline bool operator==(const wxWindowIDRef& lhs, long rhs)
{
    return lhs.GetValue() == rhs;
}

inline bool operator==(int lhs, const wxWindowIDRef& rhs)
{
    return rhs == lhs;
}

inline bool operator==(long lhs, const wxWindowIDRef& rhs)
{
    return rhs == lhs;
}

inline bool operator!=(const wxWindowIDRef& lhs, const wxWindowIDRef& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const wxWindowIDRef& lhs, int rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(const wxWindowIDRef& lhs, long rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(int lhs, const wxWindowIDRef& rhs)
{
    return !(lhs == rhs);
}

inline bool operator!=(long lhs, const wxWindowIDRef& rhs)
{
    return !(lhs == rhs);
}





class wxIdManager
{
public:




    static wxWindowID ReserveId(int count = 1);




    static void UnreserveId(wxWindowID id, int count = 1);
};
# 2387 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2







enum wxItemKind
{
    wxITEM_SEPARATOR = -1,
    wxITEM_NORMAL,
    wxITEM_CHECK,
    wxITEM_RADIO,
    wxITEM_DROPDOWN,
    wxITEM_MAX
};





enum wxCheckBoxState
{
    wxCHK_UNCHECKED,
    wxCHK_CHECKED,
    wxCHK_UNDETERMINED
};



enum wxHitTest
{
    wxHT_NOWHERE,


    wxHT_SCROLLBAR_FIRST = wxHT_NOWHERE,
    wxHT_SCROLLBAR_ARROW_LINE_1,
    wxHT_SCROLLBAR_ARROW_LINE_2,
    wxHT_SCROLLBAR_ARROW_PAGE_1,
    wxHT_SCROLLBAR_ARROW_PAGE_2,
    wxHT_SCROLLBAR_THUMB,
    wxHT_SCROLLBAR_BAR_1,
    wxHT_SCROLLBAR_BAR_2,
    wxHT_SCROLLBAR_LAST,


    wxHT_WINDOW_OUTSIDE,
    wxHT_WINDOW_INSIDE,
    wxHT_WINDOW_VERT_SCROLLBAR,
    wxHT_WINDOW_HORZ_SCROLLBAR,
    wxHT_WINDOW_CORNER,

    wxHT_MAX
};
# 2472 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
enum wxHatchStyle
{
    wxHATCHSTYLE_INVALID = -1,





    wxHATCHSTYLE_FIRST = 111,
    wxHATCHSTYLE_BDIAGONAL = wxHATCHSTYLE_FIRST,
    wxHATCHSTYLE_CROSSDIAG,
    wxHATCHSTYLE_FDIAGONAL,
    wxHATCHSTYLE_CROSS,
    wxHATCHSTYLE_HORIZONTAL,
    wxHATCHSTYLE_VERTICAL,
    wxHATCHSTYLE_LAST = wxHATCHSTYLE_VERTICAL
};
# 2499 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
enum wxDeprecatedGUIConstants
{

    wxDEFAULT = 70,
    wxDECORATIVE,
    wxROMAN,
    wxSCRIPT,
    wxSWISS,
    wxMODERN,
    wxTELETYPE,


    wxVARIABLE = 80,
    wxFIXED,

    wxNORMAL = 90,
    wxLIGHT,
    wxBOLD,

    wxITALIC,
    wxSLANT,


    wxSOLID = 100,
    wxDOT,
    wxLONG_DASH,
    wxSHORT_DASH,
    wxDOT_DASH,
    wxUSER_DASH,

    wxTRANSPARENT,



    wxSTIPPLE_MASK_OPAQUE,
    wxSTIPPLE_MASK,

    wxSTIPPLE = 110,

    wxBDIAGONAL_HATCH = wxHATCHSTYLE_BDIAGONAL,
    wxCROSSDIAG_HATCH = wxHATCHSTYLE_CROSSDIAG,
    wxFDIAGONAL_HATCH = wxHATCHSTYLE_FDIAGONAL,
    wxCROSS_HATCH = wxHATCHSTYLE_CROSS,
    wxHORIZONTAL_HATCH = wxHATCHSTYLE_HORIZONTAL,
    wxVERTICAL_HATCH = wxHATCHSTYLE_VERTICAL,
    wxFIRST_HATCH = wxHATCHSTYLE_FIRST,
    wxLAST_HATCH = wxHATCHSTYLE_LAST
};



enum
{
    wxTOOL_TOP = 1,
    wxTOOL_BOTTOM,
    wxTOOL_LEFT,
    wxTOOL_RIGHT
};



enum wxDataFormatId
{
    wxDF_INVALID = 0,
    wxDF_TEXT = 1,
    wxDF_BITMAP = 2,
    wxDF_METAFILE = 3,
    wxDF_SYLK = 4,
    wxDF_DIF = 5,
    wxDF_TIFF = 6,
    wxDF_OEMTEXT = 7,
    wxDF_DIB = 8,
    wxDF_PALETTE = 9,
    wxDF_PENDATA = 10,
    wxDF_RIFF = 11,
    wxDF_WAVE = 12,
    wxDF_UNICODETEXT = 13,
    wxDF_ENHMETAFILE = 14,
    wxDF_FILENAME = 15,
    wxDF_LOCALE = 16,
    wxDF_PRIVATE = 20,
    wxDF_HTML = 30,
    wxDF_MAX
};


enum wxKeyCode
{
    WXK_NONE = 0,

    WXK_CONTROL_A = 1,
    WXK_CONTROL_B,
    WXK_CONTROL_C,
    WXK_CONTROL_D,
    WXK_CONTROL_E,
    WXK_CONTROL_F,
    WXK_CONTROL_G,
    WXK_CONTROL_H,
    WXK_CONTROL_I,
    WXK_CONTROL_J,
    WXK_CONTROL_K,
    WXK_CONTROL_L,
    WXK_CONTROL_M,
    WXK_CONTROL_N,
    WXK_CONTROL_O,
    WXK_CONTROL_P,
    WXK_CONTROL_Q,
    WXK_CONTROL_R,
    WXK_CONTROL_S,
    WXK_CONTROL_T,
    WXK_CONTROL_U,
    WXK_CONTROL_V,
    WXK_CONTROL_W,
    WXK_CONTROL_X,
    WXK_CONTROL_Y,
    WXK_CONTROL_Z,

    WXK_BACK = 8,
    WXK_TAB = 9,
    WXK_RETURN = 13,
    WXK_ESCAPE = 27,



    WXK_SPACE = 32,
    WXK_DELETE = 127,
# 2633 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
    WXK_START = 300,
    WXK_LBUTTON,
    WXK_RBUTTON,
    WXK_CANCEL,
    WXK_MBUTTON,
    WXK_CLEAR,
    WXK_SHIFT,
    WXK_ALT,
    WXK_CONTROL,
    WXK_MENU,
    WXK_PAUSE,
    WXK_CAPITAL,
    WXK_END,
    WXK_HOME,
    WXK_LEFT,
    WXK_UP,
    WXK_RIGHT,
    WXK_DOWN,
    WXK_SELECT,
    WXK_PRINT,
    WXK_EXECUTE,
    WXK_SNAPSHOT,
    WXK_INSERT,
    WXK_HELP,
    WXK_NUMPAD0,
    WXK_NUMPAD1,
    WXK_NUMPAD2,
    WXK_NUMPAD3,
    WXK_NUMPAD4,
    WXK_NUMPAD5,
    WXK_NUMPAD6,
    WXK_NUMPAD7,
    WXK_NUMPAD8,
    WXK_NUMPAD9,
    WXK_MULTIPLY,
    WXK_ADD,
    WXK_SEPARATOR,
    WXK_SUBTRACT,
    WXK_DECIMAL,
    WXK_DIVIDE,
    WXK_F1,
    WXK_F2,
    WXK_F3,
    WXK_F4,
    WXK_F5,
    WXK_F6,
    WXK_F7,
    WXK_F8,
    WXK_F9,
    WXK_F10,
    WXK_F11,
    WXK_F12,
    WXK_F13,
    WXK_F14,
    WXK_F15,
    WXK_F16,
    WXK_F17,
    WXK_F18,
    WXK_F19,
    WXK_F20,
    WXK_F21,
    WXK_F22,
    WXK_F23,
    WXK_F24,
    WXK_NUMLOCK,
    WXK_SCROLL,
    WXK_PAGEUP,
    WXK_PAGEDOWN,





    WXK_NUMPAD_SPACE,
    WXK_NUMPAD_TAB,
    WXK_NUMPAD_ENTER,
    WXK_NUMPAD_F1,
    WXK_NUMPAD_F2,
    WXK_NUMPAD_F3,
    WXK_NUMPAD_F4,
    WXK_NUMPAD_HOME,
    WXK_NUMPAD_LEFT,
    WXK_NUMPAD_UP,
    WXK_NUMPAD_RIGHT,
    WXK_NUMPAD_DOWN,
    WXK_NUMPAD_PAGEUP,
    WXK_NUMPAD_PAGEDOWN,




    WXK_NUMPAD_END,
    WXK_NUMPAD_BEGIN,
    WXK_NUMPAD_INSERT,
    WXK_NUMPAD_DELETE,
    WXK_NUMPAD_EQUAL,
    WXK_NUMPAD_MULTIPLY,
    WXK_NUMPAD_ADD,
    WXK_NUMPAD_SEPARATOR,
    WXK_NUMPAD_SUBTRACT,
    WXK_NUMPAD_DECIMAL,
    WXK_NUMPAD_DIVIDE,

    WXK_WINDOWS_LEFT,
    WXK_WINDOWS_RIGHT,
    WXK_WINDOWS_MENU ,



    WXK_RAW_CONTROL = WXK_CONTROL,

    WXK_COMMAND = WXK_CONTROL,


    WXK_SPECIAL1 = 193,
    WXK_SPECIAL2,
    WXK_SPECIAL3,
    WXK_SPECIAL4,
    WXK_SPECIAL5,
    WXK_SPECIAL6,
    WXK_SPECIAL7,
    WXK_SPECIAL8,
    WXK_SPECIAL9,
    WXK_SPECIAL10,
    WXK_SPECIAL11,
    WXK_SPECIAL12,
    WXK_SPECIAL13,
    WXK_SPECIAL14,
    WXK_SPECIAL15,
    WXK_SPECIAL16,
    WXK_SPECIAL17,
    WXK_SPECIAL18,
    WXK_SPECIAL19,
    WXK_SPECIAL20
};


enum wxKeyModifier
{
    wxMOD_NONE = 0x0000,
    wxMOD_ALT = 0x0001,
    wxMOD_CONTROL = 0x0002,
    wxMOD_ALTGR = wxMOD_ALT | wxMOD_CONTROL,
    wxMOD_SHIFT = 0x0004,
    wxMOD_META = 0x0008,
    wxMOD_WIN = wxMOD_META,



    wxMOD_RAW_CONTROL = wxMOD_CONTROL,

    wxMOD_CMD = wxMOD_CONTROL,
    wxMOD_ALL = 0xffff
};





typedef enum
{
    wxPAPER_NONE,
    wxPAPER_LETTER,
    wxPAPER_LEGAL,
    wxPAPER_A4,
    wxPAPER_CSHEET,
    wxPAPER_DSHEET,
    wxPAPER_ESHEET,
    wxPAPER_LETTERSMALL,
    wxPAPER_TABLOID,
    wxPAPER_LEDGER,
    wxPAPER_STATEMENT,
    wxPAPER_EXECUTIVE,
    wxPAPER_A3,
    wxPAPER_A4SMALL,
    wxPAPER_A5,
    wxPAPER_B4,
    wxPAPER_B5,
    wxPAPER_FOLIO,
    wxPAPER_QUARTO,
    wxPAPER_10X14,
    wxPAPER_11X17,
    wxPAPER_NOTE,
    wxPAPER_ENV_9,
    wxPAPER_ENV_10,
    wxPAPER_ENV_11,
    wxPAPER_ENV_12,
    wxPAPER_ENV_14,
    wxPAPER_ENV_DL,
    wxPAPER_ENV_C5,
    wxPAPER_ENV_C3,
    wxPAPER_ENV_C4,
    wxPAPER_ENV_C6,
    wxPAPER_ENV_C65,
    wxPAPER_ENV_B4,
    wxPAPER_ENV_B5,
    wxPAPER_ENV_B6,
    wxPAPER_ENV_ITALY,
    wxPAPER_ENV_MONARCH,
    wxPAPER_ENV_PERSONAL,
    wxPAPER_FANFOLD_US,
    wxPAPER_FANFOLD_STD_GERMAN,
    wxPAPER_FANFOLD_LGL_GERMAN,

    wxPAPER_ISO_B4,
    wxPAPER_JAPANESE_POSTCARD,
    wxPAPER_9X11,
    wxPAPER_10X11,
    wxPAPER_15X11,
    wxPAPER_ENV_INVITE,
    wxPAPER_LETTER_EXTRA,
    wxPAPER_LEGAL_EXTRA,
    wxPAPER_TABLOID_EXTRA,
    wxPAPER_A4_EXTRA,
    wxPAPER_LETTER_TRANSVERSE,
    wxPAPER_A4_TRANSVERSE,
    wxPAPER_LETTER_EXTRA_TRANSVERSE,
    wxPAPER_A_PLUS,
    wxPAPER_B_PLUS,
    wxPAPER_LETTER_PLUS,
    wxPAPER_A4_PLUS,
    wxPAPER_A5_TRANSVERSE,
    wxPAPER_B5_TRANSVERSE,
    wxPAPER_A3_EXTRA,
    wxPAPER_A5_EXTRA,
    wxPAPER_B5_EXTRA,
    wxPAPER_A2,
    wxPAPER_A3_TRANSVERSE,
    wxPAPER_A3_EXTRA_TRANSVERSE,

    wxPAPER_DBL_JAPANESE_POSTCARD,
    wxPAPER_A6,
    wxPAPER_JENV_KAKU2,
    wxPAPER_JENV_KAKU3,
    wxPAPER_JENV_CHOU3,
    wxPAPER_JENV_CHOU4,
    wxPAPER_LETTER_ROTATED,
    wxPAPER_A3_ROTATED,
    wxPAPER_A4_ROTATED,
    wxPAPER_A5_ROTATED,
    wxPAPER_B4_JIS_ROTATED,
    wxPAPER_B5_JIS_ROTATED,
    wxPAPER_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_DBL_JAPANESE_POSTCARD_ROTATED,
    wxPAPER_A6_ROTATED,
    wxPAPER_JENV_KAKU2_ROTATED,
    wxPAPER_JENV_KAKU3_ROTATED,
    wxPAPER_JENV_CHOU3_ROTATED,
    wxPAPER_JENV_CHOU4_ROTATED,
    wxPAPER_B6_JIS,
    wxPAPER_B6_JIS_ROTATED,
    wxPAPER_12X11,
    wxPAPER_JENV_YOU4,
    wxPAPER_JENV_YOU4_ROTATED,
    wxPAPER_P16K,
    wxPAPER_P32K,
    wxPAPER_P32KBIG,
    wxPAPER_PENV_1,
    wxPAPER_PENV_2,
    wxPAPER_PENV_3,
    wxPAPER_PENV_4,
    wxPAPER_PENV_5,
    wxPAPER_PENV_6,
    wxPAPER_PENV_7,
    wxPAPER_PENV_8,
    wxPAPER_PENV_9,
    wxPAPER_PENV_10,
    wxPAPER_P16K_ROTATED,
    wxPAPER_P32K_ROTATED,
    wxPAPER_P32KBIG_ROTATED,
    wxPAPER_PENV_1_ROTATED,
    wxPAPER_PENV_2_ROTATED,
    wxPAPER_PENV_3_ROTATED,
    wxPAPER_PENV_4_ROTATED,
    wxPAPER_PENV_5_ROTATED,
    wxPAPER_PENV_6_ROTATED,
    wxPAPER_PENV_7_ROTATED,
    wxPAPER_PENV_8_ROTATED,
    wxPAPER_PENV_9_ROTATED,
    wxPAPER_PENV_10_ROTATED,
    wxPAPER_A0,
    wxPAPER_A1
} wxPaperSize;


enum wxPrintOrientation
{
   wxPORTRAIT = 1,
   wxLANDSCAPE
};




enum wxDuplexMode
{
    wxDUPLEX_SIMPLEX,
    wxDUPLEX_HORIZONTAL,
    wxDUPLEX_VERTICAL
};
# 2942 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef int wxPrintQuality;




enum wxPrintMode
{
    wxPRINT_MODE_NONE = 0,
    wxPRINT_MODE_PREVIEW = 1,
    wxPRINT_MODE_FILE = 2,
    wxPRINT_MODE_PRINTER = 3,
    wxPRINT_MODE_STREAM = 4
};





enum wxUpdateUI
{
    wxUPDATE_UI_NONE = 0x0000,
    wxUPDATE_UI_RECURSE = 0x0001,
    wxUPDATE_UI_FROMIDLE = 0x0002
};
# 2976 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef int (* wxSortCompareFunction)(const void *elem1, const void *elem2);


typedef int (* wxListIterateFunction)(void *current);
# 3256 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
typedef void* WXHANDLE;
typedef struct HWND__ * WXHWND;
typedef struct HICON__ * WXHICON;
typedef struct HFONT__ * WXHFONT;
typedef struct HMENU__ * WXHMENU;
typedef struct HPEN__ * WXHPEN;
typedef struct HBRUSH__ * WXHBRUSH;
typedef struct HPALETTE__ * WXHPALETTE;
typedef struct HCURSOR__ * WXHCURSOR;
typedef struct HRGN__ * WXHRGN;
typedef struct RECTPTR__ * WXRECTPTR;
typedef struct HACCEL__ * WXHACCEL;
typedef struct HINSTANCE__ * WXHINSTANCE;
typedef struct HBITMAP__ * WXHBITMAP;
typedef struct HIMAGELIST__ * WXHIMAGELIST;
typedef struct HGLOBAL__ * WXHGLOBAL;
typedef struct HDC__ * WXHDC;
typedef WXHINSTANCE WXHMODULE;



typedef unsigned int WXUINT;
typedef unsigned long WXDWORD;
typedef unsigned short WXWORD;

typedef unsigned long WXCOLORREF;
typedef void * WXRGNDATA;
typedef struct tagMSG WXMSG;
typedef void * WXHCONV;
typedef void * WXHKEY;
typedef void * WXHTREEITEM;

typedef void * WXDRAWITEMSTRUCT;
typedef void * WXMEASUREITEMSTRUCT;
typedef void * WXLPCREATESTRUCT;


typedef WXHWND WXWidget;



typedef wxUint64 WXWPARAM;
typedef wxInt64 WXLPARAM;
typedef wxInt64 WXLRESULT;







typedef int (*WXFARPROC)();
# 3531 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 3532 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2





# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/features.h" 1
# 3538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h" 2
# 3599 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/defs.h"
enum
{
    wxPRIORITY_MIN = 0u,
    wxPRIORITY_DEFAULT = 50u,
    wxPRIORITY_MAX = 100u
};
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 1
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/memory.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/memory.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 1
# 40 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdarg.h" 1 3 4
# 140 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdarg.h" 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_mingw_stdarg.h" 1 3 4
# 141 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdarg.h" 2 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 2 3 4
# 41 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 42 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 43 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h" 1
# 37 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wctype.h" 1 3
# 15 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wctype.h" 3
#pragma pack(push,_CRT_PACKING)



# 18 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wctype.h" 3
extern "C" {
# 174 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/wctype.h" 3
  typedef wchar_t wctrans_t;
  wint_t __attribute__((__cdecl__)) towctrans(wint_t,wctrans_t);
  wctrans_t __attribute__((__cdecl__)) wctrans(const char *);
  wctype_t __attribute__((__cdecl__)) wctype(const char *);


}


#pragma pack(pop)
# 38 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 1 3
# 24 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 60 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
  typedef long clock_t;
# 122 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
  extern __attribute__ ((__dllimport__)) int _daylight;
  extern __attribute__ ((__dllimport__)) long _dstbias;
  extern __attribute__ ((__dllimport__)) long _timezone;
  extern __attribute__ ((__dllimport__)) char * _tzname[2];


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_daylight(int *_Daylight);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_dstbias(long *_Daylight_savings_bias);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_timezone(long *_Timezone);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_tzname(size_t *_ReturnValue,char *_Buffer,size_t _SizeInBytes,int _Index);
  char *__attribute__((__cdecl__)) asctime(const struct tm *_Tm) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) asctime_s (char *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  char *__attribute__((__cdecl__)) _ctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime32_s (char *_Buf,size_t _SizeInBytes,const __time32_t *_Time);
  clock_t __attribute__((__cdecl__)) clock(void);
  double __attribute__((__cdecl__)) _difftime32(__time32_t _Time1,__time32_t _Time2);
  struct tm *__attribute__((__cdecl__)) _gmtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime32_s (struct tm *_Tm,const __time32_t *_Time);
  struct tm *__attribute__((__cdecl__)) _localtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime32_s (struct tm *_Tm,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) strftime(char * __restrict__ _Buf,size_t _SizeInBytes,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strftime_l(char * __restrict__ _Buf,size_t _Max_size,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdate(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strdate_s (char *_Buf,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtime(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strtime_s (char *_Buf ,size_t _SizeInBytes);
  __time32_t __attribute__((__cdecl__)) _time32(__time32_t *_Time);
  __time32_t __attribute__((__cdecl__)) _mktime32(struct tm *_Tm);
  __time32_t __attribute__((__cdecl__)) _mkgmtime32(struct tm *_Tm);


  void __attribute__((__cdecl__)) tzset(void) ;



  __attribute__ ((__dllimport__))

  void __attribute__((__cdecl__)) _tzset(void);


  double __attribute__((__cdecl__)) _difftime64(__time64_t _Time1,__time64_t _Time2);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime64_s (char *_Buf,size_t _SizeInBytes,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mktime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mkgmtime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _time64(__time64_t *_Time);
  unsigned __attribute__((__cdecl__)) _getsystime(struct tm *_Tm);
  unsigned __attribute__((__cdecl__)) _setsystime(struct tm *_Tm,unsigned _MilliSec);
# 218 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
double __attribute__((__cdecl__)) difftime(time_t _Time1,time_t _Time2);
char *__attribute__((__cdecl__)) ctime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) gmtime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) localtime(const time_t *_Time) ;

time_t __attribute__((__cdecl__)) mktime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) _mkgmtime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) time(time_t *_Time);
# 261 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) localtime_s(struct tm *_Tm,const time_t *_Time) { return _localtime64_s(_Tm,_Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) gmtime_s(struct tm *_Tm, const time_t *_Time) { return _gmtime64_s(_Tm, _Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) ctime_s(char *_Buf,size_t _SizeInBytes,const time_t *_Time) { return _ctime64_s(_Buf,_SizeInBytes,_Time); }
# 278 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
  __attribute__ ((__dllimport__)) extern int daylight;


  __attribute__ ((__dllimport__)) extern long timezone ;
  __attribute__ ((__dllimport__)) extern char *tzname[2] ;
  void __attribute__((__cdecl__)) tzset(void) ;


# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_timeval.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/_timeval.h" 3
struct timeval
{
 long tv_sec;
 long tv_usec;
};
# 287 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 2 3



struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};

  extern int __attribute__((__cdecl__)) mingw_gettimeofday (struct timeval *p, struct timezone *z);



}


#pragma pack(pop)






inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) localtime_r(const time_t *_Time, struct tm *_Tm) {
  return localtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) gmtime_r(const time_t *_Time, struct tm *_Tm) {
  return gmtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) ctime_r(const time_t *_Time, char *_Str) {
  return ctime_s(_Str, 0x7fffffff, _Time) ? __null : _Str;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) asctime_r(const struct tm *_Tm, char * _Str) {
  return asctime_s(_Str, 0x7fffffff, _Tm) ? __null : _Str;
}
# 332 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread_time.h" 1 3
# 74 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/pthread_time.h" 3
extern "C" {



       





int __attribute__((__cdecl__)) nanosleep(const struct timespec *request, struct timespec *remain);

int __attribute__((__cdecl__)) clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *request, struct timespec *remain);
int __attribute__((__cdecl__)) clock_getres(clockid_t clock_id, struct timespec *res);
int __attribute__((__cdecl__)) clock_gettime(clockid_t clock_id, struct timespec *tp);
int __attribute__((__cdecl__)) clock_settime(clockid_t clock_id, const struct timespec *tp);

       


}
# 333 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/time.h" 2 3
# 39 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h" 2


# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 1 3
# 21 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {


__attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) _getcwd (char*, int);







  struct _finddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    char name[260];
  };

  struct _finddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    char name[260];
  };

  struct _finddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    char name[260];
  };

  struct __finddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    char name[260];
  };
# 187 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _access(const char *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _access_s(const char *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _chmod(const char *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _chsize(int _FileHandle,long _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _chsize_s (int _FileHandle,long long _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _close(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _commit(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _creat(const char *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _dup(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _dup2(int _FileHandleSrc,int _FileHandleDst);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _eof(int _FileHandle);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _filelength(int _FileHandle);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _findfirst32(const char *_Filename,struct _finddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _findnext32(intptr_t _FindHandle,struct _finddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _findclose(intptr_t _FindHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isatty(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _locking(int _FileHandle,int _LockMode,long _NumOfBytes);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _lseek(int _FileHandle,long _Offset,int _Origin);
  _off64_t lseek64(int fd,_off64_t offset, int whence);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _mktemp(char *_TemplateName) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _mktemp_s (char *_TemplateName,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pipe(int *_PtHandles,unsigned int _PipeSize,int _TextMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _read(int _FileHandle,void *_DstBuf,unsigned int _MaxCharCount);
# 221 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmode(int _FileHandle,int _Mode);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _tell(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _umask(int _Mode) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _umask_s (int _NewMode,int *_OldMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _write(int _FileHandle,const void *_Buf,unsigned int _MaxCharCount);

  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _filelengthi64(int _FileHandle);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _findfirst32i64(const char *_Filename,struct _finddata32i64_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _findfirst64(const char *_Filename,struct __finddata64_t *_FindData);



  intptr_t __attribute__((__cdecl__)) _findfirst64i32(const char *_Filename,struct _finddata64i32_t *_FindData);
# 252 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _findnext32i64(intptr_t _FindHandle,struct _finddata32i64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _findnext64(intptr_t _FindHandle,struct __finddata64_t *_FindData);
  int __attribute__((__cdecl__)) _findnext64i32(intptr_t _FindHandle,struct _finddata64i32_t *_FindData);
# 273 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
  __extension__ long long __attribute__((__cdecl__)) _lseeki64(int _FileHandle,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _telli64(int _FileHandle);



  int __attribute__((__cdecl__)) chdir (const char *) ;
  char *__attribute__((__cdecl__)) getcwd (char *, int) ;
  int __attribute__((__cdecl__)) mkdir (const char *) ;
  char *__attribute__((__cdecl__)) mktemp(char *) ;
  int __attribute__((__cdecl__)) rmdir (const char*) ;
  int __attribute__((__cdecl__)) chmod (const char *, int) ;



  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _sopen_s(int *_FileHandle,const char *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionMode);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _open(const char *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sopen(const char *_Filename,int _OpenFlag,int _ShareFlag,...) ;
# 319 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
  int __attribute__((__cdecl__)) __lock_fhandle(int _Filehandle);
  void __attribute__((__cdecl__)) _unlock_fhandle(int _Filehandle);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_osfhandle(int _FileHandle);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _open_osfhandle(intptr_t _OSFileHandle,int _Flags);


  int __attribute__((__cdecl__)) access(const char *_Filename,int _AccessMode) ;
  int __attribute__((__cdecl__)) chmod(const char *_Filename,int _AccessMode) ;
  int __attribute__((__cdecl__)) chsize(int _FileHandle,long _Size) ;
  int __attribute__((__cdecl__)) close(int _FileHandle) ;
  int __attribute__((__cdecl__)) creat(const char *_Filename,int _PermissionMode) ;
  int __attribute__((__cdecl__)) dup(int _FileHandle) ;
  int __attribute__((__cdecl__)) dup2(int _FileHandleSrc,int _FileHandleDst) ;
  int __attribute__((__cdecl__)) eof(int _FileHandle) ;
  long __attribute__((__cdecl__)) filelength(int _FileHandle) ;
  int __attribute__((__cdecl__)) isatty(int _FileHandle) ;
  int __attribute__((__cdecl__)) locking(int _FileHandle,int _LockMode,long _NumOfBytes) ;
  long __attribute__((__cdecl__)) lseek(int _FileHandle,long _Offset,int _Origin) ;
  char *__attribute__((__cdecl__)) mktemp(char *_TemplateName) ;
  int __attribute__((__cdecl__)) open(const char *_Filename,int _OpenFlag,...) ;
  int __attribute__((__cdecl__)) read(int _FileHandle,void *_DstBuf,unsigned int _MaxCharCount) ;
  int __attribute__((__cdecl__)) setmode(int _FileHandle,int _Mode) ;
  int __attribute__((__cdecl__)) sopen(const char *_Filename,int _OpenFlag,int _ShareFlag,...) ;
  long __attribute__((__cdecl__)) tell(int _FileHandle) ;
  int __attribute__((__cdecl__)) umask(int _Mode) ;
  int __attribute__((__cdecl__)) write(int _Filehandle,const void *_Buf,unsigned int _MaxCharCount) ;
# 377 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/io.h" 3
}



#pragma pack(pop)
# 42 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h" 2
# 124 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
        
# 124 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
       inline void wxUpdateLocaleIsUtf8() {}
# 283 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
extern "C" {
# 295 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
}
# 376 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
 char *wxCRT_StrdupA(const char *psz);



 wchar_t *wxCRT_StrdupW(const wchar_t *pwz);



 int wxCRT_StricmpA(const char *psz1, const char *psz2);



 int wxCRT_StricmpW(const wchar_t *psz1, const wchar_t *psz2);



 int wxCRT_StrnicmpA(const char *psz1, const char *psz2, size_t len);



 int wxCRT_StrnicmpW(const wchar_t *psz1, const wchar_t *psz2, size_t len);



 char *wxCRT_StrtokA(char *psz, const char *delim, char **save_ptr);



 wchar_t *wxCRT_StrtokW(wchar_t *psz, const wchar_t *delim, wchar_t **save_ptr);





        long long wxCRT_StrtollA(const char* nptr,
                                                     char** endptr,
                                                     int base);
        unsigned long long wxCRT_StrtoullA(const char* nptr,
                                                       char** endptr,
                                                       int base);


        long long wxCRT_StrtollW(const wchar_t* nptr,
                                                     wchar_t** endptr,
                                                     int base);
        unsigned long long wxCRT_StrtoullW(const wchar_t* nptr,
                                                       wchar_t** endptr,
                                                       int base);
# 461 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
       
       
       
       
# 675 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtbase.h"
inline size_t wxStrlen(const char *s) { return s ? strlen(s) : 0; }
inline size_t wxStrlen(const wchar_t *s) { return s ? wcslen(s) : 0; }




       size_t wxStrlen(const wxChar32 *s );





inline char* wxStrdup(const char *s) { return wxCRT_StrdupA(s); }
inline wchar_t* wxStrdup(const wchar_t *s) { return wxCRT_StrdupW(s); }




       wxChar32* wxStrdup(const wxChar32* s);
# 46 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 2

class wxCStrData;







namespace wxPrivate
{

struct UntypedBufferData
{
    enum Kind
    {
        Owned,
        NonOwned
    };

    UntypedBufferData(void *str, size_t len, Kind kind = Owned)
        : m_str(str), m_length(len), m_ref(1), m_owned(kind == Owned) {}

    ~UntypedBufferData()
    {
        if ( m_owned )
            free(m_str);
    }

    void *m_str;
    size_t m_length;


    unsigned short m_ref;

    bool m_owned;
};


 UntypedBufferData * GetUntypedNullData();

}





template <typename T>
class wxScopedCharTypeBuffer
{
public:
    typedef T CharType;

    wxScopedCharTypeBuffer()
    {
        m_data = GetNullData();
    }




    static
    const wxScopedCharTypeBuffer CreateNonOwned(const CharType *str,
                                                size_t len = ((size_t)-1))
    {
        if ( len == ((size_t)-1) )
            len = wxStrlen(str);

        wxScopedCharTypeBuffer buf;
        if ( str )
            buf.m_data = new Data(const_cast<CharType*>(str), len, Data::NonOwned);
        return buf;
    }



    static
    const wxScopedCharTypeBuffer CreateOwned(CharType *str,
                                             size_t len = ((size_t)-1) )
    {
        if ( len == ((size_t)-1) )
            len = wxStrlen(str);

        wxScopedCharTypeBuffer buf;
        if ( str )
            buf.m_data = new Data(str, len);
        return buf;
    }

    wxScopedCharTypeBuffer(const wxScopedCharTypeBuffer& src)
    {
        m_data = src.m_data;
        IncRef();
    }

    wxScopedCharTypeBuffer& operator=(const wxScopedCharTypeBuffer& src)
    {
        if ( &src == this )
            return *this;

        DecRef();
        m_data = src.m_data;
        IncRef();

        return *this;
    }

    ~wxScopedCharTypeBuffer()
    {
        DecRef();
    }




    CharType *release() const
    {
        if ( m_data == GetNullData() )
            return 
# 136 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                  __null
# 136 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                      ;

        do { if ( wxTheAssertHandler && !(m_data->m_owned) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 138, __FUNCTION__, "m_data->m_owned", L"can't release non-owned buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        do { if ( wxTheAssertHandler && !(m_data->m_ref == 1) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 139, __FUNCTION__, "m_data->m_ref == 1", L"can't release shared buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        CharType * const p = m_data->Get();

        wxScopedCharTypeBuffer *self = const_cast<wxScopedCharTypeBuffer*>(this);
        self->m_data->Set(
# 144 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                         __null
# 144 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                             , 0);
        self->DecRef();

        return p;
    }

    void reset()
    {
        DecRef();
    }

    CharType *data() { return m_data->Get(); }
    const CharType *data() const { return m_data->Get(); }
    operator const CharType *() const { return data(); }
    CharType operator[](size_t n) const { return data()[n]; }

    size_t length() const { return m_data->m_length; }

protected:

    struct Data : public wxPrivate::UntypedBufferData
    {
        Data(CharType *str, size_t len, Kind kind = Owned)
            : wxPrivate::UntypedBufferData(str, len, kind)
        {
        }

        CharType *Get() const { return static_cast<CharType *>(m_str); }
        void Set(CharType *str, size_t len)
        {
            m_str = str;
            m_length = len;
        }
    };


    static Data *GetNullData()
    {
        return static_cast<Data *>(wxPrivate::GetUntypedNullData());
    }

    void IncRef()
    {
        if ( m_data == GetNullData() )
            return;
        m_data->m_ref++;
    }

    void DecRef()
    {
        if ( m_data == GetNullData() )
            return;
        if ( --m_data->m_ref == 0 )
            delete m_data;
        m_data = GetNullData();
    }



    void MakeOwnedCopyOf(const wxScopedCharTypeBuffer& src)
    {
        this->DecRef();

        if ( src.m_data == this->GetNullData() )
        {
            this->m_data = this->GetNullData();
        }
        else if ( src.m_data->m_owned )
        {
            this->m_data = src.m_data;
            this->IncRef();
        }
        else
        {



            this->m_data = new Data
                               (
                                   StrCopy(src.data(), src.length()),
                                   src.length()
                               );
        }
    }

    static CharType *StrCopy(const CharType *src, size_t len)
    {
        CharType *dst = (CharType*)malloc(sizeof(CharType) * (len + 1));
        if ( dst )
            memcpy(dst, src, sizeof(CharType) * (len + 1));
        return dst;
    }

protected:
    Data *m_data;
};

typedef wxScopedCharTypeBuffer<char> wxScopedCharBuffer;
typedef wxScopedCharTypeBuffer<wchar_t> wxScopedWCharBuffer;



template <typename T>
class wxCharTypeBuffer : public wxScopedCharTypeBuffer<T>
{
protected:
    typedef typename wxScopedCharTypeBuffer<T>::Data Data;

public:
    typedef T CharType;

    wxCharTypeBuffer(const CharType *str = 
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                                          __null
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                                              , size_t len = ((size_t)-1))
    {
        if ( str )
        {
            if ( len == ((size_t)-1) )
                len = wxStrlen(str);
            this->m_data = new Data(this->StrCopy(str, len), len);
        }
        else
        {
            this->m_data = this->GetNullData();
        }
    }

    wxCharTypeBuffer(size_t len)
    {
        CharType* const str = (CharType *)malloc((len + 1)*sizeof(CharType));
        if ( str )
        {
            str[len] = (CharType)0;






            this->m_data = new Data(str, len);
        }
        else
        {
            this->m_data = this->GetNullData();
        }
    }

    wxCharTypeBuffer(const wxCharTypeBuffer& src)
        : wxScopedCharTypeBuffer<T>(src) {}

    wxCharTypeBuffer& operator=(const CharType *str)
    {
        this->DecRef();

        if ( str )
            this->m_data = new Data(wxStrdup(str), wxStrlen(str));
        return *this;
    }

    wxCharTypeBuffer& operator=(const wxCharTypeBuffer& src)
    {
        wxScopedCharTypeBuffer<T>::operator=(src);
        return *this;
    }

    wxCharTypeBuffer(const wxScopedCharTypeBuffer<T>& src)
    {
        this->MakeOwnedCopyOf(src);
    }

    wxCharTypeBuffer& operator=(const wxScopedCharTypeBuffer<T>& src)
    {
        MakeOwnedCopyOf(src);
        return *this;
    }

    bool extend(size_t len)
    {
        do { if ( wxTheAssertHandler && !(this->m_data->m_owned) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 320, __FUNCTION__, "this->m_data->m_owned", "cannot extend non-owned buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        do { if ( wxTheAssertHandler && !(this->m_data->m_ref == 1) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 321, __FUNCTION__, "this->m_data->m_ref == 1", "can't extend shared buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        CharType *str =
            (CharType *)realloc(this->data(), (len + 1) * sizeof(CharType));
        if ( !str )
            return false;



        str[len] = (CharType)0;

        if ( this->m_data == this->GetNullData() )
        {
            this->m_data = new Data(str, len);
        }
        else
        {
            this->m_data->Set(str, len);
            this->m_data->m_owned = true;
        }

        return true;
    }

    void shrink(size_t len)
    {
        do { if ( wxTheAssertHandler && !(this->m_data->m_owned) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 347, __FUNCTION__, "this->m_data->m_owned", "cannot shrink non-owned buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        do { if ( wxTheAssertHandler && !(this->m_data->m_ref == 1) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 348, __FUNCTION__, "this->m_data->m_ref == 1", "can't shrink shared buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        do { if ( wxTheAssertHandler && !(len <= this->length()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 350, __FUNCTION__, "len <= this->length()", (const char*)
# 350 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
       __null
# 350 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        this->m_data->m_length = len;
        this->data()[len] = 0;
    }
};




class wxCharBuffer : public wxCharTypeBuffer<char>
{
public:
    typedef wxCharTypeBuffer<char> wxCharTypeBufferBase;
    typedef wxScopedCharTypeBuffer<char> wxScopedCharTypeBufferBase;

    wxCharBuffer(const wxCharTypeBufferBase& buf)
        : wxCharTypeBufferBase(buf) {}
    wxCharBuffer(const wxScopedCharTypeBufferBase& buf)
        : wxCharTypeBufferBase(buf) {}

    wxCharBuffer(const CharType *str = 
# 371 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                                      __null
# 371 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                                          ) : wxCharTypeBufferBase(str) {}
    wxCharBuffer(size_t len) : wxCharTypeBufferBase(len) {}

    wxCharBuffer(const wxCStrData& cstr);
};




class wxWCharBuffer : public wxCharTypeBuffer<wchar_t>
{
public:
    typedef wxCharTypeBuffer<wchar_t> wxCharTypeBufferBase;
    typedef wxScopedCharTypeBuffer<wchar_t> wxScopedCharTypeBufferBase;

    wxWCharBuffer(const wxCharTypeBufferBase& buf)
        : wxCharTypeBufferBase(buf) {}
    wxWCharBuffer(const wxScopedCharTypeBufferBase& buf)
        : wxCharTypeBufferBase(buf) {}

    wxWCharBuffer(const CharType *str = 
# 391 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                                       __null
# 391 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                                           ) : wxCharTypeBufferBase(str) {}
    wxWCharBuffer(size_t len) : wxCharTypeBufferBase(len) {}

    wxWCharBuffer(const wxCStrData& cstr);
};


template <typename T>
class wxWritableCharTypeBuffer : public wxCharTypeBuffer<T>
{
public:
    typedef typename wxScopedCharTypeBuffer<T>::CharType CharType;

    wxWritableCharTypeBuffer(const wxScopedCharTypeBuffer<T>& src)
        : wxCharTypeBuffer<T>(src) {}




    wxWritableCharTypeBuffer(const CharType *str = 
# 410 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                                                  __null
# 410 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                                                      )
        : wxCharTypeBuffer<T>(str) {}

    operator CharType*() { return this->data(); }
};

typedef wxWritableCharTypeBuffer<char> wxWritableCharBuffer;
typedef wxWritableCharTypeBuffer<wchar_t> wxWritableWCharBuffer;
# 446 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
class wxMemoryBufferData
{
public:

    enum { DefBufSize = 1024 };

    friend class wxMemoryBuffer;


private:
    wxMemoryBufferData(size_t size = wxMemoryBufferData::DefBufSize)
        : m_data(size ? malloc(size) : 
# 457 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                                      __null
# 457 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                                          ), m_size(size), m_len(0), m_ref(0)
    {
    }
    ~wxMemoryBufferData() { free(m_data); }


    void ResizeIfNeeded(size_t newSize)
    {
        if (newSize > m_size)
        {
            void *dataOld = m_data;
            m_data = realloc(m_data, newSize + wxMemoryBufferData::DefBufSize);
            if ( !m_data )
            {
                free(dataOld);
            }

            m_size = newSize + wxMemoryBufferData::DefBufSize;
        }
    }

    void IncRef() { m_ref += 1; }
    void DecRef()
    {
        m_ref -= 1;
        if (m_ref == 0)
            delete this;
    }

    void *release()
    {
        if ( m_data == 
# 488 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                      __null 
# 488 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                           )
            return 
# 489 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                  __null
# 489 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                      ;

        do { if ( wxTheAssertHandler && !(m_ref == 1) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 491, __FUNCTION__, "m_ref == 1", "can't release shared buffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        void *p = m_data;
        m_data = 
# 494 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
                __null
# 494 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
                    ;
        m_len =
        m_size = 0;

        return p;
    }



    void *m_data;


    size_t m_size;


    size_t m_len;


    size_t m_ref;

    private: wxMemoryBufferData(const wxMemoryBufferData&); wxMemoryBufferData& operator=(const wxMemoryBufferData&);
};


class wxMemoryBuffer
{
public:

    wxMemoryBuffer(size_t size = wxMemoryBufferData::DefBufSize)
    {
        m_bufdata = new wxMemoryBufferData(size);
        m_bufdata->IncRef();
    }

    ~wxMemoryBuffer() { m_bufdata->DecRef(); }



    wxMemoryBuffer(const wxMemoryBuffer& src)
        : m_bufdata(src.m_bufdata)
    {
        m_bufdata->IncRef();
    }

    wxMemoryBuffer& operator=(const wxMemoryBuffer& src)
    {
        if (&src != this)
        {
            m_bufdata->DecRef();
            m_bufdata = src.m_bufdata;
            m_bufdata->IncRef();
        }
        return *this;
    }



    void *GetData() const { return m_bufdata->m_data; }
    size_t GetBufSize() const { return m_bufdata->m_size; }
    size_t GetDataLen() const { return m_bufdata->m_len; }

    bool IsEmpty() const { return GetDataLen() == 0; }

    void SetBufSize(size_t size) { m_bufdata->ResizeIfNeeded(size); }
    void SetDataLen(size_t len)
    {
        do { if ( wxTheAssertHandler && !(len <= m_bufdata->m_size) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 560, __FUNCTION__, "len <= m_bufdata->m_size", (const char*)
# 560 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h" 3 4
       __null
# 560 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        m_bufdata->m_len = len;
    }

    void Clear() { SetDataLen(0); }


    void *GetWriteBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(sizeNeeded);
        return m_bufdata->m_data;
    }


    void UngetWriteBuf(size_t sizeUsed) { SetDataLen(sizeUsed); }


    void *GetAppendBuf(size_t sizeNeeded)
    {
        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + sizeNeeded);
        return (char*)m_bufdata->m_data + m_bufdata->m_len;
    }


    void UngetAppendBuf(size_t sizeUsed)
    {
        SetDataLen(m_bufdata->m_len + sizeUsed);
    }


    void AppendByte(char data)
    {
        if ( m_bufdata->m_data ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/buffer.h", 592, __FUNCTION__, "m_bufdata->m_data", L"invalid wxMemoryBuffer"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

        m_bufdata->ResizeIfNeeded(m_bufdata->m_len + 1);
        *(((char*)m_bufdata->m_data) + m_bufdata->m_len) = data;
        m_bufdata->m_len += 1;
    }

    void AppendData(const void *data, size_t len)
    {
        memcpy(GetAppendBuf(len), data, len);
        UngetAppendBuf(len);
    }

    operator const char *() const { return (const char*)GetData(); }



    void *release()
    {
        return m_bufdata->release();
    }

private:
    wxMemoryBufferData* m_bufdata;
};
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h" 2
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h" 2

class wxString;
# 47 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
class wxMBConv
{
public:
# 75 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;

    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;





    const wxWCharBuffer cMB2WC(const char *in) const;
    const wxCharBuffer cWC2MB(const wchar_t *in) const;
# 103 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    const wxWCharBuffer
        cMB2WC(const char *in, size_t inLen, size_t *outLen) const;
    const wxCharBuffer
        cWC2MB(const wchar_t *in, size_t inLen, size_t *outLen) const;




    const wxWCharBuffer cMB2WC(const wxScopedCharBuffer& in) const;
    const wxCharBuffer cWC2MB(const wxScopedWCharBuffer& in) const;



    const wxWCharBuffer cMB2WX(const char *psz) const { return cMB2WC(psz); }
    const wxCharBuffer cWX2MB(const wchar_t *psz) const { return cWC2MB(psz); }
    const wchar_t* cWC2WX(const wchar_t *psz) const { return psz; }
    const wchar_t* cWX2WC(const wchar_t *psz) const { return psz; }
# 138 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    virtual size_t GetMBNulLen() const { return 1; }



    static size_t GetMaxMBNulLen() { return 4 ; }
# 167 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    virtual size_t MB2WC(wchar_t *out, const char *in, size_t outLen) const;
    virtual size_t WC2MB(char *out, const wchar_t *in, size_t outLen) const;



    virtual wxMBConv *Clone() const = 0;


    virtual ~wxMBConv();
};






class wxMBConvLibc : public wxMBConv
{
public:
    virtual size_t MB2WC(wchar_t *outputBuf, const char *psz, size_t outputSize) const;
    virtual size_t WC2MB(char *outputBuf, const wchar_t *psz, size_t outputSize) const;

    virtual wxMBConv *Clone() const { return new wxMBConvLibc; }




};
# 251 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
class wxMBConvUTF7 : public wxMBConv
{
public:
    wxMBConvUTF7() { }




    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF7; }

private:


    struct StateMode
    {
        enum Mode
        {
            Direct,
            Shifted
        };
    };




    class DecoderState : private StateMode
    {
    private:


        Mode mode;

    public:

        DecoderState() { mode = Direct; }


        void ToDirect() { mode = Direct; }
        void ToShifted() { mode = Shifted; accum = bit = 0; isLSB = false; }

        bool IsDirect() const { return mode == Direct; }
        bool IsShifted() const { return mode == Shifted; }




        unsigned int accum;
        unsigned int bit;
        unsigned char msb;
        bool isLSB;
    };

    DecoderState m_stateDecoder;




    class EncoderState : private StateMode
    {
    private:
        Mode mode;

    public:
        EncoderState() { mode = Direct; }

        void ToDirect() { mode = Direct; }
        void ToShifted() { mode = Shifted; accum = bit = 0; }

        bool IsDirect() const { return mode == Direct; }
        bool IsShifted() const { return mode == Shifted; }

        unsigned int accum;
        unsigned int bit;
    };

    EncoderState m_stateEncoder;
};
# 341 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
class wxMBConvStrictUTF8 : public wxMBConv
{
public:


    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;

    virtual wxMBConv *Clone() const { return new wxMBConvStrictUTF8(); }






};

class wxMBConvUTF8 : public wxMBConvStrictUTF8
{
public:
    enum
    {
        MAP_INVALID_UTF8_NOT = 0,
        MAP_INVALID_UTF8_TO_PUA = 1,
        MAP_INVALID_UTF8_TO_OCTAL = 2
    };

    wxMBConvUTF8(int options = MAP_INVALID_UTF8_NOT) : m_options(options) { }

    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;

    virtual wxMBConv *Clone() const { return new wxMBConvUTF8(m_options); }







private:
    int m_options;
};





class wxMBConvUTF16Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 2 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:




    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF16LE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16LE; }
};





class wxMBConvUTF16BE : public wxMBConvUTF16Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF16BE; }
};





class wxMBConvUTF32Base : public wxMBConv
{
public:
    enum { BYTES_PER_CHAR = 4 };

    virtual size_t GetMBNulLen() const { return BYTES_PER_CHAR; }

protected:



    static size_t GetLength(const char *src, size_t srcLen);
};





class wxMBConvUTF32LE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32LE; }
};





class wxMBConvUTF32BE : public wxMBConvUTF32Base
{
public:
    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual wxMBConv *Clone() const { return new wxMBConvUTF32BE; }
};





# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/fontenc.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/fontenc.h"
enum wxFontEncoding
{
    wxFONTENCODING_SYSTEM = -1,
    wxFONTENCODING_DEFAULT,


    wxFONTENCODING_ISO8859_1,
    wxFONTENCODING_ISO8859_2,
    wxFONTENCODING_ISO8859_3,
    wxFONTENCODING_ISO8859_4,
    wxFONTENCODING_ISO8859_5,
    wxFONTENCODING_ISO8859_6,
    wxFONTENCODING_ISO8859_7,
    wxFONTENCODING_ISO8859_8,
    wxFONTENCODING_ISO8859_9,
    wxFONTENCODING_ISO8859_10,
    wxFONTENCODING_ISO8859_11,
    wxFONTENCODING_ISO8859_12,


    wxFONTENCODING_ISO8859_13,
    wxFONTENCODING_ISO8859_14,
    wxFONTENCODING_ISO8859_15,
    wxFONTENCODING_ISO8859_MAX,


    wxFONTENCODING_KOI8,
    wxFONTENCODING_KOI8_U,
    wxFONTENCODING_ALTERNATIVE,
    wxFONTENCODING_BULGARIAN,



    wxFONTENCODING_CP437,
    wxFONTENCODING_CP850,
    wxFONTENCODING_CP852,
    wxFONTENCODING_CP855,
    wxFONTENCODING_CP866,

    wxFONTENCODING_CP874,
    wxFONTENCODING_CP932,
    wxFONTENCODING_CP936,
    wxFONTENCODING_CP949,
    wxFONTENCODING_CP950,
    wxFONTENCODING_CP1250,
    wxFONTENCODING_CP1251,
    wxFONTENCODING_CP1252,
    wxFONTENCODING_CP1253,
    wxFONTENCODING_CP1254,
    wxFONTENCODING_CP1255,
    wxFONTENCODING_CP1256,
    wxFONTENCODING_CP1257,
    wxFONTENCODING_CP1258,
    wxFONTENCODING_CP1361,
    wxFONTENCODING_CP12_MAX,

    wxFONTENCODING_UTF7,
    wxFONTENCODING_UTF8,
    wxFONTENCODING_EUC_JP,
    wxFONTENCODING_UTF16BE,
    wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32BE,
    wxFONTENCODING_UTF32LE,

    wxFONTENCODING_MACROMAN,
    wxFONTENCODING_MACJAPANESE,
    wxFONTENCODING_MACCHINESETRAD,
    wxFONTENCODING_MACKOREAN,
    wxFONTENCODING_MACARABIC,
    wxFONTENCODING_MACHEBREW,
    wxFONTENCODING_MACGREEK,
    wxFONTENCODING_MACCYRILLIC,
    wxFONTENCODING_MACDEVANAGARI,
    wxFONTENCODING_MACGURMUKHI,
    wxFONTENCODING_MACGUJARATI,
    wxFONTENCODING_MACORIYA,
    wxFONTENCODING_MACBENGALI,
    wxFONTENCODING_MACTAMIL,
    wxFONTENCODING_MACTELUGU,
    wxFONTENCODING_MACKANNADA,
    wxFONTENCODING_MACMALAJALAM,
    wxFONTENCODING_MACSINHALESE,
    wxFONTENCODING_MACBURMESE,
    wxFONTENCODING_MACKHMER,
    wxFONTENCODING_MACTHAI,
    wxFONTENCODING_MACLAOTIAN,
    wxFONTENCODING_MACGEORGIAN,
    wxFONTENCODING_MACARMENIAN,
    wxFONTENCODING_MACCHINESESIMP,
    wxFONTENCODING_MACTIBETAN,
    wxFONTENCODING_MACMONGOLIAN,
    wxFONTENCODING_MACETHIOPIC,
    wxFONTENCODING_MACCENTRALEUR,
    wxFONTENCODING_MACVIATNAMESE,
    wxFONTENCODING_MACARABICEXT,
    wxFONTENCODING_MACSYMBOL,
    wxFONTENCODING_MACDINGBATS,
    wxFONTENCODING_MACTURKISH,
    wxFONTENCODING_MACCROATIAN,
    wxFONTENCODING_MACICELANDIC,
    wxFONTENCODING_MACROMANIAN,
    wxFONTENCODING_MACCELTIC,
    wxFONTENCODING_MACGAELIC,
    wxFONTENCODING_MACKEYBOARD,



    wxFONTENCODING_ISO2022_JP,

    wxFONTENCODING_MAX,

    wxFONTENCODING_MACMIN = wxFONTENCODING_MACROMAN ,
    wxFONTENCODING_MACMAX = wxFONTENCODING_MACKEYBOARD ,






    wxFONTENCODING_UTF16 = wxFONTENCODING_UTF16LE,
    wxFONTENCODING_UTF32 = wxFONTENCODING_UTF32LE,





    wxFONTENCODING_UNICODE = wxFONTENCODING_UTF16,






    wxFONTENCODING_GB2312 = wxFONTENCODING_CP936,
    wxFONTENCODING_BIG5 = wxFONTENCODING_CP950,


    wxFONTENCODING_SHIFT_JIS = wxFONTENCODING_CP932,


    wxFONTENCODING_EUC_KR = wxFONTENCODING_CP949,
    wxFONTENCODING_JOHAB = wxFONTENCODING_CP1361,


    wxFONTENCODING_VIETNAMESE = wxFONTENCODING_CP1258
};
# 487 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h" 2

class wxCSConv : public wxMBConv
{
public:


    wxCSConv(const wxString& charset);
    wxCSConv(wxFontEncoding encoding);

    wxCSConv(const wxCSConv& conv);
    virtual ~wxCSConv();

    wxCSConv& operator=(const wxCSConv& conv);

    virtual size_t ToWChar(wchar_t *dst, size_t dstLen,
                           const char *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t FromWChar(char *dst, size_t dstLen,
                             const wchar_t *src, size_t srcLen = ((size_t)-1)) const;
    virtual size_t GetMBNulLen() const;





    virtual wxMBConv *Clone() const { return new wxCSConv(*this); }

    void Clear();


    bool IsOk() const;

private:

    void Init();



    wxMBConv *DoCreate() const;



    void SetName(const char *charset);






    void SetEncoding(wxFontEncoding encoding);
# 546 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    char *m_name;
    wxFontEncoding m_encoding;



    wxMBConv *m_convReal;
};
# 576 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
extern wxMBConv* wxConvLibcPtr; extern wxMBConv* wxGet_wxConvLibcPtr(); inline wxMBConv& wxGet_wxConvLibc() { if ( !wxConvLibcPtr ) wxConvLibcPtr = wxGet_wxConvLibcPtr(); return *wxConvLibcPtr; }



extern wxCSConv* wxConvISO8859_1Ptr; extern wxCSConv* wxGet_wxConvISO8859_1Ptr(); inline wxCSConv& wxGet_wxConvISO8859_1() { if ( !wxConvISO8859_1Ptr ) wxConvISO8859_1Ptr = wxGet_wxConvISO8859_1Ptr(); return *wxConvISO8859_1Ptr; }


extern wxMBConvStrictUTF8* wxConvUTF8Ptr; extern wxMBConvStrictUTF8* wxGet_wxConvUTF8Ptr(); inline wxMBConvStrictUTF8& wxGet_wxConvUTF8() { if ( !wxConvUTF8Ptr ) wxConvUTF8Ptr = wxGet_wxConvUTF8Ptr(); return *wxConvUTF8Ptr; }


extern wxMBConvUTF7* wxConvUTF7Ptr; extern wxMBConvUTF7* wxGet_wxConvUTF7Ptr(); inline wxMBConvUTF7& wxGet_wxConvUTF7() { if ( !wxConvUTF7Ptr ) wxConvUTF7Ptr = wxGet_wxConvUTF7Ptr(); return *wxConvUTF7Ptr; }
# 596 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
extern wxMBConv * wxConvFileName;






extern wxMBConv * wxConvCurrent;


extern wxCSConv* wxConvLocalPtr; extern wxCSConv* wxGet_wxConvLocalPtr(); inline wxCSConv& wxGet_wxConvLocal() { if ( !wxConvLocalPtr ) wxConvLocalPtr = wxGet_wxConvLocalPtr(); return *wxConvLocalPtr; }






extern wxMBConv * wxConvUI;
# 625 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    typedef wxMBConvUTF16LE wxMBConvUTF16;
    typedef wxMBConvUTF32LE wxMBConvUTF32;
# 661 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strconv.h"
    extern wxWCharBuffer wxSafeConvertMB2WX(const char *s);



    extern wxCharBuffer wxSafeConvertWX2MB(const wchar_t *ws);
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h" 1
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdlib.h" 1 3
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h" 2
# 44 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h"
extern const wxChar* wxEmptyString;
# 65 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/beforestd.h" 1
# 66 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 2
# 68 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h" 2


    typedef std::wstring wxStdWideString;





    typedef wxStdWideString wxStdString;
# 97 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringimpl.h"
    typedef wxStdString wxStringImpl;
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h" 2

class wxUniCharRef;
class wxString;



class wxUniChar
{
public:



    typedef wxUint32 value_type;

    wxUniChar() : m_value(0) {}



    wxUniChar(char c) { m_value = From8bit(c); }
    wxUniChar(unsigned char c) { m_value = From8bit((char)c); }



    wxUniChar(short c) { m_value = (value_type)c; } wxUniChar(unsigned short c) { m_value = (value_type)c; } wxUniChar(int c) { m_value = (value_type)c; } wxUniChar(unsigned int c) { m_value = (value_type)c; } wxUniChar(long c) { m_value = (value_type)c; } wxUniChar(unsigned long c) { m_value = (value_type)c; } wxUniChar(long long c) { m_value = (value_type)c; } wxUniChar(unsigned long long c) { m_value = (value_type)c; } wxUniChar(wchar_t c) { m_value = (value_type)c; }


    wxUniChar(const wxUniCharRef& c);


    value_type GetValue() const { return m_value; }
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h"
    bool IsAscii() const { return m_value < 0x80; }




    bool GetAsChar(char *c) const
    {

        if ( !IsAscii() )
        {

            if ( GetAsHi8bit(m_value, c) )
                return true;


            return false;
        }


        *c = ((char)(m_value));
        return true;
    }




    operator char() const { return To8bit(m_value); }
    operator unsigned char() const { return (unsigned char)To8bit(m_value); }



    operator short() const { return (short)m_value; } operator unsigned short() const { return (unsigned short)m_value; } operator int() const { return (int)m_value; } operator unsigned int() const { return (unsigned int)m_value; } operator long() const { return (long)m_value; } operator unsigned long() const { return (unsigned long)m_value; } operator long long() const { return (long long)m_value; } operator unsigned long long() const { return (unsigned long long)m_value; } operator wchar_t() const { return (wchar_t)m_value; }







    operator bool() const { return m_value != 0; }
    bool operator!() const { return !((bool)*this); }



    bool operator&&(bool v) const { return (bool)*this && v; }


    wxUniChar& operator=(const wxUniChar& c) { if (&c != this) m_value = c.m_value; return *this; }
    wxUniChar& operator=(const wxUniCharRef& c);
    wxUniChar& operator=(char c) { m_value = From8bit(c); return *this; }
    wxUniChar& operator=(unsigned char c) { m_value = From8bit((char)c); return *this; }



    wxUniChar& operator=(short c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(unsigned short c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(int c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(unsigned int c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(long c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(unsigned long c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(long long c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(unsigned long long c) { m_value = (value_type)c; return *this; } wxUniChar& operator=(wchar_t c) { m_value = (value_type)c; return *this; }
# 129 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h"
    bool operator ==(const wxUniChar& c) const { return m_value == c.m_value; } bool operator ==(char c) const { return m_value == From8bit(c); } bool operator ==(unsigned char c) const { return m_value == From8bit((char)c); } bool operator ==(short c) const { return m_value == (value_type)c; } bool operator ==(unsigned short c) const { return m_value == (value_type)c; } bool operator ==(int c) const { return m_value == (value_type)c; } bool operator ==(unsigned int c) const { return m_value == (value_type)c; } bool operator ==(long c) const { return m_value == (value_type)c; } bool operator ==(unsigned long c) const { return m_value == (value_type)c; } bool operator ==(long long c) const { return m_value == (value_type)c; } bool operator ==(unsigned long long c) const { return m_value == (value_type)c; } bool operator ==(wchar_t c) const { return m_value == (value_type)c; } bool operator !=(const wxUniChar& c) const { return m_value != c.m_value; } bool operator !=(char c) const { return m_value != From8bit(c); } bool operator !=(unsigned char c) const { return m_value != From8bit((char)c); } bool operator !=(short c) const { return m_value != (value_type)c; } bool operator !=(unsigned short c) const { return m_value != (value_type)c; } bool operator !=(int c) const { return m_value != (value_type)c; } bool operator !=(unsigned int c) const { return m_value != (value_type)c; } bool operator !=(long c) const { return m_value != (value_type)c; } bool operator !=(unsigned long c) const { return m_value != (value_type)c; } bool operator !=(long long c) const { return m_value != (value_type)c; } bool operator !=(unsigned long long c) const { return m_value != (value_type)c; } bool operator !=(wchar_t c) const { return m_value != (value_type)c; } bool operator >=(const wxUniChar& c) const { return m_value >= c.m_value; } bool operator >=(char c) const { return m_value >= From8bit(c); } bool operator >=(unsigned char c) const { return m_value >= From8bit((char)c); } bool operator >=(short c) const { return m_value >= (value_type)c; } bool operator >=(unsigned short c) const { return m_value >= (value_type)c; } bool operator >=(int c) const { return m_value >= (value_type)c; } bool operator >=(unsigned int c) const { return m_value >= (value_type)c; } bool operator >=(long c) const { return m_value >= (value_type)c; } bool operator >=(unsigned long c) const { return m_value >= (value_type)c; } bool operator >=(long long c) const { return m_value >= (value_type)c; } bool operator >=(unsigned long long c) const { return m_value >= (value_type)c; } bool operator >=(wchar_t c) const { return m_value >= (value_type)c; } bool operator <=(const wxUniChar& c) const { return m_value <= c.m_value; } bool operator <=(char c) const { return m_value <= From8bit(c); } bool operator <=(unsigned char c) const { return m_value <= From8bit((char)c); } bool operator <=(short c) const { return m_value <= (value_type)c; } bool operator <=(unsigned short c) const { return m_value <= (value_type)c; } bool operator <=(int c) const { return m_value <= (value_type)c; } bool operator <=(unsigned int c) const { return m_value <= (value_type)c; } bool operator <=(long c) const { return m_value <= (value_type)c; } bool operator <=(unsigned long c) const { return m_value <= (value_type)c; } bool operator <=(long long c) const { return m_value <= (value_type)c; } bool operator <=(unsigned long long c) const { return m_value <= (value_type)c; } bool operator <=(wchar_t c) const { return m_value <= (value_type)c; } bool operator >(const wxUniChar& c) const { return m_value > c.m_value; } bool operator >(char c) const { return m_value > From8bit(c); } bool operator >(unsigned char c) const { return m_value > From8bit((char)c); } bool operator >(short c) const { return m_value > (value_type)c; } bool operator >(unsigned short c) const { return m_value > (value_type)c; } bool operator >(int c) const { return m_value > (value_type)c; } bool operator >(unsigned int c) const { return m_value > (value_type)c; } bool operator >(long c) const { return m_value > (value_type)c; } bool operator >(unsigned long c) const { return m_value > (value_type)c; } bool operator >(long long c) const { return m_value > (value_type)c; } bool operator >(unsigned long long c) const { return m_value > (value_type)c; } bool operator >(wchar_t c) const { return m_value > (value_type)c; } bool operator <(const wxUniChar& c) const { return m_value < c.m_value; } bool operator <(char c) const { return m_value < From8bit(c); } bool operator <(unsigned char c) const { return m_value < From8bit((char)c); } bool operator <(short c) const { return m_value < (value_type)c; } bool operator <(unsigned short c) const { return m_value < (value_type)c; } bool operator <(int c) const { return m_value < (value_type)c; } bool operator <(unsigned int c) const { return m_value < (value_type)c; } bool operator <(long c) const { return m_value < (value_type)c; } bool operator <(unsigned long c) const { return m_value < (value_type)c; } bool operator <(long long c) const { return m_value < (value_type)c; } bool operator <(unsigned long long c) const { return m_value < (value_type)c; } bool operator <(wchar_t c) const { return m_value < (value_type)c; }





    int operator-(const wxUniChar& c) const { return m_value - c.m_value; }
    int operator-(char c) const { return m_value - From8bit(c); }
    int operator-(unsigned char c) const { return m_value - From8bit((char)c); }
    int operator-(wchar_t c) const { return m_value - (value_type)c; }


private:


    static value_type From8bit(char c)
    {

        if ( (unsigned char)c < 0x80 )
            return c;

        return FromHi8bit(c);



    }

    static char To8bit(value_type c)
    {

        if ( c < 0x80 )
            return ((char)(c));

        return ToHi8bit(c);



    }


    static value_type FromHi8bit(char c);
    static char ToHi8bit(value_type v);
    static bool GetAsHi8bit(value_type v, char *c);

private:
    value_type m_value;
};






class wxUniCharRef
{
private:
    typedef wxStringImpl::iterator iterator;





    wxUniCharRef(iterator pos) : m_pos(pos) {}


public:
# 204 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h"
    static wxUniCharRef CreateForString(iterator pos)
        { return wxUniCharRef(pos); }


    wxUniChar::value_type GetValue() const { return UniChar().GetValue(); }





    bool IsAscii() const { return UniChar().IsAscii(); }
    bool GetAsChar(char *c) const { return UniChar().GetAsChar(c); }





    wxUniCharRef& operator=(const wxUniChar& c) { *m_pos = c; return *this; }


    wxUniCharRef& operator=(const wxUniCharRef& c)
        { if (&c != this) *this = c.UniChar(); return *this; }



    wxUniCharRef& operator=(char c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(unsigned char c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(short c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(unsigned short c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(int c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(unsigned int c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(long c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(unsigned long c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(long long c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(unsigned long long c) { return *this = wxUniChar(c); } wxUniCharRef& operator=(wchar_t c) { return *this = wxUniChar(c); }





    operator char() const { return UniChar(); } operator unsigned char() const { return UniChar(); } operator short() const { return UniChar(); } operator unsigned short() const { return UniChar(); } operator int() const { return UniChar(); } operator unsigned int() const { return UniChar(); } operator long() const { return UniChar(); } operator unsigned long() const { return UniChar(); } operator long long() const { return UniChar(); } operator unsigned long long() const { return UniChar(); } operator wchar_t() const { return UniChar(); }



    operator bool() const { return (bool)UniChar(); }
    bool operator!() const { return !UniChar(); }
    bool operator&&(bool v) const { return UniChar() && v; }
# 252 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/unichar.h"
    bool operator ==(const wxUniCharRef& c) const { return UniChar() == c.UniChar(); } bool operator ==(const wxUniChar& c) const { return UniChar() == c; } bool operator ==(char c) const { return UniChar() == c; } bool operator ==(unsigned char c) const { return UniChar() == c; } bool operator ==(short c) const { return UniChar() == c; } bool operator ==(unsigned short c) const { return UniChar() == c; } bool operator ==(int c) const { return UniChar() == c; } bool operator ==(unsigned int c) const { return UniChar() == c; } bool operator ==(long c) const { return UniChar() == c; } bool operator ==(unsigned long c) const { return UniChar() == c; } bool operator ==(long long c) const { return UniChar() == c; } bool operator ==(unsigned long long c) const { return UniChar() == c; } bool operator ==(wchar_t c) const { return UniChar() == c; } bool operator !=(const wxUniCharRef& c) const { return UniChar() != c.UniChar(); } bool operator !=(const wxUniChar& c) const { return UniChar() != c; } bool operator !=(char c) const { return UniChar() != c; } bool operator !=(unsigned char c) const { return UniChar() != c; } bool operator !=(short c) const { return UniChar() != c; } bool operator !=(unsigned short c) const { return UniChar() != c; } bool operator !=(int c) const { return UniChar() != c; } bool operator !=(unsigned int c) const { return UniChar() != c; } bool operator !=(long c) const { return UniChar() != c; } bool operator !=(unsigned long c) const { return UniChar() != c; } bool operator !=(long long c) const { return UniChar() != c; } bool operator !=(unsigned long long c) const { return UniChar() != c; } bool operator !=(wchar_t c) const { return UniChar() != c; } bool operator >=(const wxUniCharRef& c) const { return UniChar() >= c.UniChar(); } bool operator >=(const wxUniChar& c) const { return UniChar() >= c; } bool operator >=(char c) const { return UniChar() >= c; } bool operator >=(unsigned char c) const { return UniChar() >= c; } bool operator >=(short c) const { return UniChar() >= c; } bool operator >=(unsigned short c) const { return UniChar() >= c; } bool operator >=(int c) const { return UniChar() >= c; } bool operator >=(unsigned int c) const { return UniChar() >= c; } bool operator >=(long c) const { return UniChar() >= c; } bool operator >=(unsigned long c) const { return UniChar() >= c; } bool operator >=(long long c) const { return UniChar() >= c; } bool operator >=(unsigned long long c) const { return UniChar() >= c; } bool operator >=(wchar_t c) const { return UniChar() >= c; } bool operator <=(const wxUniCharRef& c) const { return UniChar() <= c.UniChar(); } bool operator <=(const wxUniChar& c) const { return UniChar() <= c; } bool operator <=(char c) const { return UniChar() <= c; } bool operator <=(unsigned char c) const { return UniChar() <= c; } bool operator <=(short c) const { return UniChar() <= c; } bool operator <=(unsigned short c) const { return UniChar() <= c; } bool operator <=(int c) const { return UniChar() <= c; } bool operator <=(unsigned int c) const { return UniChar() <= c; } bool operator <=(long c) const { return UniChar() <= c; } bool operator <=(unsigned long c) const { return UniChar() <= c; } bool operator <=(long long c) const { return UniChar() <= c; } bool operator <=(unsigned long long c) const { return UniChar() <= c; } bool operator <=(wchar_t c) const { return UniChar() <= c; } bool operator >(const wxUniCharRef& c) const { return UniChar() > c.UniChar(); } bool operator >(const wxUniChar& c) const { return UniChar() > c; } bool operator >(char c) const { return UniChar() > c; } bool operator >(unsigned char c) const { return UniChar() > c; } bool operator >(short c) const { return UniChar() > c; } bool operator >(unsigned short c) const { return UniChar() > c; } bool operator >(int c) const { return UniChar() > c; } bool operator >(unsigned int c) const { return UniChar() > c; } bool operator >(long c) const { return UniChar() > c; } bool operator >(unsigned long c) const { return UniChar() > c; } bool operator >(long long c) const { return UniChar() > c; } bool operator >(unsigned long long c) const { return UniChar() > c; } bool operator >(wchar_t c) const { return UniChar() > c; } bool operator <(const wxUniCharRef& c) const { return UniChar() < c.UniChar(); } bool operator <(const wxUniChar& c) const { return UniChar() < c; } bool operator <(char c) const { return UniChar() < c; } bool operator <(unsigned char c) const { return UniChar() < c; } bool operator <(short c) const { return UniChar() < c; } bool operator <(unsigned short c) const { return UniChar() < c; } bool operator <(int c) const { return UniChar() < c; } bool operator <(unsigned int c) const { return UniChar() < c; } bool operator <(long c) const { return UniChar() < c; } bool operator <(unsigned long c) const { return UniChar() < c; } bool operator <(long long c) const { return UniChar() < c; } bool operator <(unsigned long long c) const { return UniChar() < c; } bool operator <(wchar_t c) const { return UniChar() < c; }





    int operator-(const wxUniCharRef& c) const { return UniChar() - c.UniChar(); }
    int operator-(const wxUniChar& c) const { return UniChar() - c; }
    int operator-(char c) const { return UniChar() - c; }
    int operator-(unsigned char c) const { return UniChar() - c; }
    int operator-(wchar_t c) const { return UniChar() - c; }

private:



    wxUniChar UniChar() const { return *m_pos; }


    friend class wxUniChar;

private:




    iterator m_pos;
};

inline wxUniChar::wxUniChar(const wxUniCharRef& c)
{
    m_value = c.UniChar().m_value;
}

inline wxUniChar& wxUniChar::operator=(const wxUniCharRef& c)
{
    m_value = c.UniChar().m_value;
    return *this;
}




inline bool operator ==(char x, const wxUniChar& y) { return y == x; } inline bool operator !=(char x, const wxUniChar& y) { return y != x; } inline bool operator >=(char x, const wxUniChar& y) { return y <= x; } inline bool operator <=(char x, const wxUniChar& y) { return y >= x; } inline bool operator >(char x, const wxUniChar& y) { return y < x; } inline bool operator <(char x, const wxUniChar& y) { return y > x; }
inline bool operator ==(char x, const wxUniCharRef& y) { return y == x; } inline bool operator !=(char x, const wxUniCharRef& y) { return y != x; } inline bool operator >=(char x, const wxUniCharRef& y) { return y <= x; } inline bool operator <=(char x, const wxUniCharRef& y) { return y >= x; } inline bool operator >(char x, const wxUniCharRef& y) { return y < x; } inline bool operator <(char x, const wxUniCharRef& y) { return y > x; }

inline bool operator ==(wchar_t x, const wxUniChar& y) { return y == x; } inline bool operator !=(wchar_t x, const wxUniChar& y) { return y != x; } inline bool operator >=(wchar_t x, const wxUniChar& y) { return y <= x; } inline bool operator <=(wchar_t x, const wxUniChar& y) { return y >= x; } inline bool operator >(wchar_t x, const wxUniChar& y) { return y < x; } inline bool operator <(wchar_t x, const wxUniChar& y) { return y > x; }
inline bool operator ==(wchar_t x, const wxUniCharRef& y) { return y == x; } inline bool operator !=(wchar_t x, const wxUniCharRef& y) { return y != x; } inline bool operator >=(wchar_t x, const wxUniCharRef& y) { return y <= x; } inline bool operator <=(wchar_t x, const wxUniCharRef& y) { return y >= x; } inline bool operator >(wchar_t x, const wxUniCharRef& y) { return y < x; } inline bool operator <(wchar_t x, const wxUniCharRef& y) { return y > x; }

inline bool operator ==(const wxUniChar& x, const wxUniCharRef& y) { return y == x; } inline bool operator !=(const wxUniChar& x, const wxUniCharRef& y) { return y != x; } inline bool operator >=(const wxUniChar& x, const wxUniCharRef& y) { return y <= x; } inline bool operator <=(const wxUniChar& x, const wxUniCharRef& y) { return y >= x; } inline bool operator >(const wxUniChar& x, const wxUniCharRef& y) { return y < x; } inline bool operator <(const wxUniChar& x, const wxUniCharRef& y) { return y > x; }


inline int operator-(char c1, const wxUniCharRef& c2) { return -(c2 - c1); }
inline int operator-(const wxUniChar& c1, const wxUniCharRef& c2) { return -(c2 - c1); }
inline int operator-(wchar_t c1, const wxUniCharRef& c2) { return -(c2 - c1); }
# 23 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 2
# 34 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
class wxCStrData;
class wxString;
# 136 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
class wxFormatString
{
public:
    wxFormatString(const char *str)
        : m_char(wxScopedCharBuffer::CreateNonOwned(str)), m_str(
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                                                __null
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                                                    ), m_cstr(
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                                                              __null
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                                                                  ) {}
    wxFormatString(const wchar_t *str)
        : m_wchar(wxScopedWCharBuffer::CreateNonOwned(str)), m_str(
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                                                  __null
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                                                      ), m_cstr(
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                                                                __null
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                                                                    ) {}
    wxFormatString(const wxString& str)
        : m_str(&str), m_cstr(
# 144 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                             __null
# 144 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                 ) {}
    wxFormatString(const wxCStrData& str)
        : m_str(
# 146 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
               __null
# 146 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                   ), m_cstr(&str) {}
    wxFormatString(const wxScopedCharBuffer& str)
        : m_char(str), m_str(
# 148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                            __null
# 148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                ), m_cstr(
# 148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                          __null
# 148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                              ) {}
    wxFormatString(const wxScopedWCharBuffer& str)
        : m_wchar(str), m_str(
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                             __null
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                 ), m_cstr(
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                           __null
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                               ) {}





    enum ArgumentType
    {

        Arg_Unused = 0,



        Arg_Char = 0x0001,
        Arg_Pointer = 0x0002,
        Arg_String = 0x0004 | Arg_Pointer,

        Arg_Int = 0x0008 | Arg_Char,

        Arg_LongInt = Arg_Int,






        Arg_LongLongInt = 0x0020,


        Arg_Double = 0x0040,
        Arg_LongDouble = 0x0080,






        Arg_Size_t = Arg_LongLongInt,




        Arg_IntPtr = 0x0200,
        Arg_ShortIntPtr = 0x0400,
        Arg_LongIntPtr = 0x0800,

        Arg_Unknown = 0x8000
    };





    ArgumentType GetArgumentType(unsigned n) const;



    wxString InputAsString() const;
# 223 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
public:
    operator const wchar_t*() const
        { return const_cast<wxFormatString*>(this)->AsWChar(); }
private:
    const wchar_t* InputAsWChar();
    const wchar_t* AsWChar();
    wxScopedWCharBuffer m_convertedWChar;


private:
    wxScopedCharBuffer m_char;
    wxScopedWCharBuffer m_wchar;




    const wxString * const m_str;
    const wxCStrData * const m_cstr;

    private: wxFormatString& operator=(const wxFormatString&);
};



struct wxFormatStringArgument
{
    wxFormatStringArgument(const wxFormatString *s = 
# 249 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                                    __null
# 249 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                                        ) : m_str(s) {}
    const wxFormatString *m_str;


    wxFormatStringArgument operator,(const wxFormatStringArgument& a) const
    {
        do { if ( wxTheAssertHandler && !(m_str == 
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
       __null 
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
       || a.m_str == 
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
       __null
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
       ) && (wxOnAssert(
                                                                         "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
        ,
                                                                         256
# 255 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
        , __FUNCTION__, "m_str == NULL || a.m_str == NULL", "can't have two format strings in vararg function"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                          ;
        return wxFormatStringArgument(m_str ? m_str : a.m_str);
    }

    operator const wxFormatString*() const { return m_str; }
};

template<typename T>
struct wxFormatStringArgumentFinder
{
    static wxFormatStringArgument find(T)
    {

        return wxFormatStringArgument();
    }
};

template<>
struct wxFormatStringArgumentFinder<const wxFormatString&>
{
    static wxFormatStringArgument find(const wxFormatString& arg)
        { return wxFormatStringArgument(&arg); }
};

template<>
struct wxFormatStringArgumentFinder<wxFormatString>
    : public wxFormatStringArgumentFinder<const wxFormatString&> {};



template<>
struct wxFormatStringArgumentFinder<wxString>
    : public wxFormatStringArgumentFinder<const wxString&> {};

template<>
struct wxFormatStringArgumentFinder<wxScopedCharBuffer>
    : public wxFormatStringArgumentFinder<const wxScopedCharBuffer&> {};

template<>
struct wxFormatStringArgumentFinder<wxScopedWCharBuffer>
    : public wxFormatStringArgumentFinder<const wxScopedWCharBuffer&> {};

template<>
struct wxFormatStringArgumentFinder<wxCharBuffer>
    : public wxFormatStringArgumentFinder<const wxCharBuffer&> {};

template<>
struct wxFormatStringArgumentFinder<wxWCharBuffer>
    : public wxFormatStringArgumentFinder<const wxWCharBuffer&> {};
# 337 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<bool IsEnum>
struct wxFormatStringSpecifierNonPodType {};

template<>
struct wxFormatStringSpecifierNonPodType<true>
{
    enum { value = wxFormatString::Arg_Int };
};

template<typename T>
struct wxFormatStringSpecifier
{

    typedef std::is_enum<T> is_enum;



    enum { value = wxFormatStringSpecifierNonPodType<is_enum::value>::value };
};
# 381 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<typename T>
struct wxFormatStringSpecifier<T*>
{
    enum { value = wxFormatString::Arg_Pointer };
};

template<typename T>
struct wxFormatStringSpecifier<const T*>
{
    enum { value = wxFormatString::Arg_Pointer };
};
# 401 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<> struct wxFormatStringSpecifier<bool> { enum { value = wxFormatString::Arg_Int }; };
template<> struct wxFormatStringSpecifier<int> { enum { value = wxFormatString::Arg_Int }; };
template<> struct wxFormatStringSpecifier<unsigned int> { enum { value = wxFormatString::Arg_Int }; };
template<> struct wxFormatStringSpecifier<short int> { enum { value = wxFormatString::Arg_Int }; };
template<> struct wxFormatStringSpecifier<short unsigned int> { enum { value = wxFormatString::Arg_Int }; };
template<> struct wxFormatStringSpecifier<long int> { enum { value = wxFormatString::Arg_LongInt }; };
template<> struct wxFormatStringSpecifier<long unsigned int> { enum { value = wxFormatString::Arg_LongInt }; };

template<> struct wxFormatStringSpecifier<long long> { enum { value = wxFormatString::Arg_LongLongInt }; };
template<> struct wxFormatStringSpecifier<unsigned long long> { enum { value = wxFormatString::Arg_LongLongInt }; };

template<> struct wxFormatStringSpecifier<float> { enum { value = wxFormatString::Arg_Double }; };
template<> struct wxFormatStringSpecifier<double> { enum { value = wxFormatString::Arg_Double }; };
template<> struct wxFormatStringSpecifier<long double> { enum { value = wxFormatString::Arg_LongDouble }; };


template<> struct wxFormatStringSpecifier<wchar_t> { enum { value = wxFormatString::Arg_Char | wxFormatString::Arg_Int }; };
# 426 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<> struct wxFormatStringSpecifier<char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<unsigned char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<signed char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<const char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<const unsigned char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<const signed char*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<wchar_t*> { enum { value = wxFormatString::Arg_String }; };
template<> struct wxFormatStringSpecifier<const wchar_t*> { enum { value = wxFormatString::Arg_String }; };

template<> struct wxFormatStringSpecifier<int*> { enum { value = wxFormatString::Arg_IntPtr | wxFormatString::Arg_Pointer }; };
template<> struct wxFormatStringSpecifier<short int*> { enum { value = wxFormatString::Arg_ShortIntPtr | wxFormatString::Arg_Pointer }; };
template<> struct wxFormatStringSpecifier<long int*> { enum { value = wxFormatString::Arg_LongIntPtr | wxFormatString::Arg_Pointer }; };




template<> struct wxFormatStringSpecifier<std::nullptr_t> { enum { value = wxFormatString::Arg_Pointer }; };
# 451 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<typename T>
struct wxArgNormalizer
{




    wxArgNormalizer(T value,
                    const wxFormatString *fmt, unsigned index)
        : m_value(value)
    {
        do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatStringSpecifier<T>::value)) == argtype) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h", 462, __FUNCTION__, "(argtype & (wxFormatStringSpecifier<T>::value)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 );
    }




    T get() const { return m_value; }

    T m_value;
};





template<typename T>
struct wxArgNormalizerWchar : public wxArgNormalizer<T>
{
    wxArgNormalizerWchar(T value,
                         const wxFormatString *fmt, unsigned index)
        : wxArgNormalizer<T>(value, fmt, index) {}
};
# 510 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<typename CharType>
struct wxArgNormalizerWithBuffer
{
    typedef wxScopedCharTypeBuffer<CharType> CharBuffer;

    wxArgNormalizerWithBuffer() {}
    wxArgNormalizerWithBuffer(const CharBuffer& buf,
                              const wxFormatString *fmt,
                              unsigned index)
        : m_value(buf)
    {
        do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatString::Arg_String)) == argtype) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h", 521, __FUNCTION__, "(argtype & (wxFormatString::Arg_String)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 );
    }

    const CharType *get() const { return m_value; }

    CharBuffer m_value;
};


template<>
struct wxArgNormalizerWchar<const wxString&>
{
    wxArgNormalizerWchar(const wxString& s,
                          const wxFormatString *fmt,
                          unsigned index)
        : m_value(s)
    {
        do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatString::Arg_String)) == argtype) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h", 538, __FUNCTION__, "(argtype & (wxFormatString::Arg_String)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 );
    }

    const wxStringCharType *get() const;

    const wxString& m_value;
};


template<>
struct wxArgNormalizerWchar<const wxCStrData&>
{
    wxArgNormalizerWchar(const wxCStrData& value,
                          const wxFormatString *fmt,
                          unsigned index)
        : m_value(value)
    {
        do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatString::Arg_String)) == argtype) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h", 555, __FUNCTION__, "(argtype & (wxFormatString::Arg_String)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 );
    }

    const wxStringCharType *get() const;

    const wxCStrData& m_value;
};
# 587 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<>
struct wxArgNormalizerWchar<const char*>
    : public wxArgNormalizerWithBuffer<wchar_t>
{
    wxArgNormalizerWchar(const char* s,
                         const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerWithBuffer<wchar_t>(wxGet_wxConvLibc().cMB2WC(s), fmt, index) {}
};
# 687 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<> struct wxArgNormalizerWchar<wxString> : public wxArgNormalizerWchar<const wxString&> { wxArgNormalizerWchar(const wxString& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxString&>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxCStrData> : public wxArgNormalizerWchar<const wxCStrData&> { wxArgNormalizerWchar(const wxCStrData& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxCStrData&>(value, fmt, index) {} };


template<> struct wxArgNormalizerWchar<char*> : public wxArgNormalizerWchar<const char*> { wxArgNormalizerWchar(const char* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const char*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wchar_t*> : public wxArgNormalizerWchar<const wchar_t*> { wxArgNormalizerWchar(const wchar_t* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wchar_t*>(value, fmt, index) {} };


template<> struct wxArgNormalizerWchar<wxScopedCharBuffer> : public wxArgNormalizerWchar<const char*> { wxArgNormalizerWchar(const char* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const char*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wxScopedCharBuffer&> : public wxArgNormalizerWchar<const char*> { wxArgNormalizerWchar(const char* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const char*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxScopedWCharBuffer> : public wxArgNormalizerWchar<const wchar_t*> { wxArgNormalizerWchar(const wchar_t* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wchar_t*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wxScopedWCharBuffer&> : public wxArgNormalizerWchar<const wchar_t*> { wxArgNormalizerWchar(const wchar_t* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wchar_t*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxCharBuffer> : public wxArgNormalizerWchar<const char*> { wxArgNormalizerWchar(const char* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const char*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wxCharBuffer&> : public wxArgNormalizerWchar<const char*> { wxArgNormalizerWchar(const char* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const char*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxWCharBuffer> : public wxArgNormalizerWchar<const wchar_t*> { wxArgNormalizerWchar(const wchar_t* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wchar_t*>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wxWCharBuffer&> : public wxArgNormalizerWchar<const wchar_t*> { wxArgNormalizerWchar(const wchar_t* value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wchar_t*>(value, fmt, index) {} };







template<>
struct wxArgNormalizerWchar<const std::string&>
    : public wxArgNormalizerWchar<const char*>
{
    wxArgNormalizerWchar(const std::string& s,
                         const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerWchar<const char*>(s.c_str(), fmt, index) {}
};

template<>
struct wxArgNormalizerWchar<const wxStdWideString&>
    : public wxArgNormalizerWchar<const wchar_t*>
{
    wxArgNormalizerWchar(const wxStdWideString& s,
                         const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerWchar<const wchar_t*>(s.c_str(), fmt, index) {}
};
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<> struct wxArgNormalizerWchar<std::string> : public wxArgNormalizerWchar<const std::string&> { wxArgNormalizerWchar(const std::string& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const std::string&>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxStdWideString> : public wxArgNormalizerWchar<const wxStdWideString&> { wxArgNormalizerWchar(const wxStdWideString& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxStdWideString&>(value, fmt, index) {} };






template<>
struct wxArgNormalizer<const wxUniChar&> : public wxArgNormalizer<wchar_t>
{
    wxArgNormalizer(const wxUniChar& s,
                    const wxFormatString *fmt, unsigned index)
        : wxArgNormalizer<wchar_t>(((wchar_t)(s.GetValue())), fmt, index) {}
};
# 773 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
template<typename T>
struct wxArgNormalizerNarrowChar
{
    wxArgNormalizerNarrowChar(T value,
                              const wxFormatString *fmt, unsigned index)
    {
        do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatString::Arg_Char | wxFormatString::Arg_Int)) == argtype) && (wxOnAssert(
                                                                              "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
# 779 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
        ,
                                                                              780
# 779 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
        , __FUNCTION__, "(argtype & (wxFormatString::Arg_Char | wxFormatString::Arg_Int)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 )
                                                                               ;



        if ( !fmt || fmt->GetArgumentType(index) == wxFormatString::Arg_Char )
            m_value = ((T)(wxUniChar(value).GetValue()));
        else
            m_value = value;
    }

    int get() const { return m_value; }

    T m_value;
};

template<>
struct wxArgNormalizer<char> : public wxArgNormalizerNarrowChar<char>
{
    wxArgNormalizer(char value,
                    const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerNarrowChar<char>(value, fmt, index) {}
};

template<>
struct wxArgNormalizer<unsigned char>
    : public wxArgNormalizerNarrowChar<unsigned char>
{
    wxArgNormalizer(unsigned char value,
                    const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerNarrowChar<unsigned char>(value, fmt, index) {}
};

template<>
struct wxArgNormalizer<signed char>
    : public wxArgNormalizerNarrowChar<signed char>
{
    wxArgNormalizer(signed char value,
                    const wxFormatString *fmt, unsigned index)
        : wxArgNormalizerNarrowChar<signed char>(value, fmt, index) {}
};




template<> struct wxArgNormalizerWchar<wxUniChar> : public wxArgNormalizerWchar<const wxUniChar&> { wxArgNormalizerWchar(const wxUniChar& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxUniChar&>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wxUniCharRef&> : public wxArgNormalizerWchar<const wxUniChar&> { wxArgNormalizerWchar(const wxUniChar& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxUniChar&>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<wxUniCharRef> : public wxArgNormalizerWchar<const wxUniChar&> { wxArgNormalizerWchar(const wxUniChar& value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<const wxUniChar&>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const wchar_t&> : public wxArgNormalizerWchar<wchar_t> { wxArgNormalizerWchar(wchar_t value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<wchar_t>(value, fmt, index) {} };

template<> struct wxArgNormalizerWchar<const char&> : public wxArgNormalizerWchar<char> { wxArgNormalizerWchar(char value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<char>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const unsigned char&> : public wxArgNormalizerWchar<unsigned char> { wxArgNormalizerWchar(unsigned char value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<unsigned char>(value, fmt, index) {} };
template<> struct wxArgNormalizerWchar<const signed char&> : public wxArgNormalizerWchar<signed char> { wxArgNormalizerWchar(signed char value, const wxFormatString *fmt, unsigned index) : wxArgNormalizerWchar<signed char>(value, fmt, index) {} };
# 846 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
struct wxArgNormalizedString
{
    wxArgNormalizedString(const void* ptr) : m_ptr(ptr) {}


    bool IsValid() const { return m_ptr != 
# 851 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h" 3 4
                                          __null
# 851 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/strvararg.h"
                                              ; }
    operator bool() const { return IsValid(); }


    wxString GetString() const;
    operator wxString() const;

private:
    const void *m_ptr;
};
# 47 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringops.h" 1
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringops.h"
struct wxStringOperationsWchar
{

    template <typename Iterator>
    static void IncIter(Iterator& i) { ++i; }


    template <typename Iterator>
    static void DecIter(Iterator& i) { --i; }


    template <typename Iterator>
    static Iterator AddToIter(const Iterator& i, ptrdiff_t n)
        { return i + n; }


    template <typename Iterator>
    static ptrdiff_t DiffIters(const Iterator& i1, const Iterator& i2)
        { return i1 - i2; }



    static wxChar EncodeChar(const wxUniChar& ch) { return (wxChar)ch; }

    static wxUniChar DecodeChar(const wxStringImpl::const_iterator& i)
        { return *i; }
};
# 169 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/stringops.h"
typedef wxStringOperationsWchar wxStringOperations;
# 51 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2
# 85 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
class wxString;







namespace wxPrivate
{
    template <typename T> struct wxStringAsBufHelper;
}
# 132 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
__attribute__((deprecated("use wxIsEmpty() instead")))
inline bool IsEmpty(const char *p) { return (!p || !*p); }


__attribute__((deprecated("use wxStrlen() instead")))
inline size_t Strlen(const char *psz)
  { return psz ? strlen(psz) : 0; }


__attribute__((deprecated("use wxStricmp() instead")))
inline int Stricmp(const char *psz1, const char *psz2)
    { return wxCRT_StricmpA(psz1, psz2); }
# 153 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
class wxCStrData
{
private:

    wxCStrData(const wxString *str, size_t offset = 0, bool owned = false)
        : m_str(str), m_offset(offset), m_owned(owned) {}

public:


    inline wxCStrData(char *buf);
    inline wxCStrData(wchar_t *buf);
    inline wxCStrData(const wxCStrData& data);

    inline ~wxCStrData();
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    inline const wchar_t* AsWChar() const;
    operator const wchar_t*() const { return AsWChar(); }

    inline const char* AsChar() const;
    const unsigned char* AsUnsignedChar() const
        { return (const unsigned char *) AsChar(); }
    operator const char*() const { return AsChar(); }
    operator const unsigned char*() const { return AsUnsignedChar(); }

    operator const void*() const { return AsChar(); }


    const wxScopedCharBuffer AsCharBuf() const
    {
        return wxScopedCharBuffer::CreateNonOwned(AsChar());
    }

    const wxScopedWCharBuffer AsWCharBuf() const
    {
        return wxScopedWCharBuffer::CreateNonOwned(AsWChar());
    }

    inline wxString AsString() const;



    const wxStringCharType *AsInternal() const;


    inline wxUniChar operator[](size_t n) const;
    wxUniChar operator[](int n) const { return operator[](size_t(n)); }
    wxUniChar operator[](long n) const { return operator[](size_t(n)); }

    wxUniChar operator[](unsigned int n) const { return operator[](size_t(n)); }







    wxCStrData operator+(int n) const
        { return wxCStrData(m_str, m_offset + n, m_owned); }
    wxCStrData operator+(long n) const
        { return wxCStrData(m_str, m_offset + n, m_owned); }
    wxCStrData operator+(size_t n) const
        { return wxCStrData(m_str, m_offset + n, m_owned); }




    wxCStrData operator-(ptrdiff_t n) const
    {
        do { if ( wxTheAssertHandler && !(n <= (ptrdiff_t)m_offset) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
        ,
 232
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
        , __FUNCTION__, "n <= (ptrdiff_t)m_offset", L"attempt to construct address before the beginning of the string"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                                              ;
        return wxCStrData(m_str, m_offset - n, m_owned);
    }



    inline wxUniChar operator*() const;

private:

    const wxString *m_str;






    size_t m_offset;

    bool m_owned;

    friend class wxString;
};
# 393 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
class wxString



{



public:

  static const size_t npos;

private:







  wxString& operator=(int);





  wxString(int);




  template<typename T>
  struct SubstrBufFromType
  {
      T data;
      size_t len;

      SubstrBufFromType(const T& data_, size_t len_)
          : data(data_), len(len_)
      {
          do { if ( wxTheAssertHandler && !(len != npos) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 433, __FUNCTION__, "len != npos", "must have real length"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
      }
  };






  typedef SubstrBufFromType<const wchar_t*> SubstrBufFromWC;
  typedef SubstrBufFromType<wxScopedWCharBuffer> SubstrBufFromMB;
# 461 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  static SubstrBufFromMB ConvertStr(const char *psz, size_t nLength,
                                    const wxMBConv& conv);
# 471 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  static const wchar_t* ImplStr(const wchar_t* str)
    { return str ? str : L""; }
  static const SubstrBufFromWC ImplStr(const wchar_t* str, size_t n)
    { return SubstrBufFromWC(str, (str && n == npos) ? wcslen(str) : n); }
  static wxScopedWCharBuffer ImplStr(const char* str,
                                     const wxMBConv& conv = wxGet_wxConvLibc())
    { return ConvertStr(str, npos, conv).data; }
  static SubstrBufFromMB ImplStr(const char* str, size_t n,
                                 const wxMBConv& conv = wxGet_wxConvLibc())
    { return ConvertStr(str, n, conv); }
# 496 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  static size_t PosToImpl(size_t pos) { return pos; }
  static void PosLenToImpl(size_t pos, size_t len,
                           size_t *implPos, size_t *implLen)
    { *implPos = pos; *implLen = len; }
  static size_t LenToImpl(size_t len) { return len; }
  static size_t PosFromImpl(size_t pos) { return pos; }
# 812 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
public:

  typedef wxUniChar value_type;
  typedef wxUniChar char_type;
  typedef wxUniCharRef reference;
  typedef wxChar* pointer;
  typedef const wxChar* const_pointer;

  typedef size_t size_type;
  typedef wxUniChar const_reference;
# 905 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  class const_iterator;
# 1026 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  class iterator
  {
      private: typedef wxStringImpl::iterator underlying_iterator; public: typedef std::random_access_iterator_tag iterator_category; typedef wxUniChar value_type; typedef ptrdiff_t difference_type; typedef wxUniCharRef reference; typedef wxChar* pointer; reference operator[](size_t n) const { return *(*this + n); } iterator& operator++() { wxStringOperations::IncIter(m_cur); return *this; } iterator& operator--() { wxStringOperations::DecIter(m_cur); return *this; } iterator operator++(int) { iterator tmp = *this; wxStringOperations::IncIter(m_cur); return tmp; } iterator operator--(int) { iterator tmp = *this; wxStringOperations::DecIter(m_cur); return tmp; } iterator& operator+=(ptrdiff_t n) { m_cur = wxStringOperations::AddToIter(m_cur, n); return *this; } iterator& operator-=(ptrdiff_t n) { m_cur = wxStringOperations::AddToIter(m_cur, -n); return *this; } difference_type operator-(const iterator& i) const { return wxStringOperations::DiffIters(m_cur, i.m_cur); } bool operator==(const iterator& i) const { return m_cur == i.m_cur; } bool operator!=(const iterator& i) const { return m_cur != i.m_cur; } bool operator<(const iterator& i) const { return m_cur < i.m_cur; } bool operator>(const iterator& i) const { return m_cur > i.m_cur; } bool operator<=(const iterator& i) const { return m_cur <= i.m_cur; } bool operator>=(const iterator& i) const { return m_cur >= i.m_cur; } private: underlying_iterator impl() const { return m_cur; } friend class wxString; friend class wxCStrData; private: underlying_iterator m_cur;

  public:
      iterator() {}
      iterator(const iterator& i) : m_cur(i.m_cur) {}

      reference operator*()
        { return wxUniCharRef::CreateForString(m_cur); }

      iterator operator+(ptrdiff_t n) const
        { return iterator(wxStringOperations::AddToIter(m_cur, n)); }
      iterator operator-(ptrdiff_t n) const
        { return iterator(wxStringOperations::AddToIter(m_cur, -n)); }



      bool operator==(const const_iterator& i) const;
      bool operator!=(const const_iterator& i) const;
      bool operator<(const const_iterator& i) const;
      bool operator>(const const_iterator& i) const;
      bool operator<=(const const_iterator& i) const;
      bool operator>=(const const_iterator& i) const;

  private:

      iterator(underlying_iterator ptr) : m_cur(ptr) {}
      iterator(wxString *, underlying_iterator ptr) : m_cur(ptr) {}

      friend class const_iterator;
  };

  class const_iterator
  {


      private: typedef wxStringImpl::const_iterator underlying_iterator; public: typedef std::random_access_iterator_tag iterator_category; typedef wxUniChar value_type; typedef ptrdiff_t difference_type; typedef wxUniChar reference; typedef const wxChar* pointer; reference operator[](size_t n) const { return *(*this + n); } const_iterator& operator++() { wxStringOperations::IncIter(m_cur); return *this; } const_iterator& operator--() { wxStringOperations::DecIter(m_cur); return *this; } const_iterator operator++(int) { const_iterator tmp = *this; wxStringOperations::IncIter(m_cur); return tmp; } const_iterator operator--(int) { const_iterator tmp = *this; wxStringOperations::DecIter(m_cur); return tmp; } const_iterator& operator+=(ptrdiff_t n) { m_cur = wxStringOperations::AddToIter(m_cur, n); return *this; } const_iterator& operator-=(ptrdiff_t n) { m_cur = wxStringOperations::AddToIter(m_cur, -n); return *this; } difference_type operator-(const const_iterator& i) const { return wxStringOperations::DiffIters(m_cur, i.m_cur); } bool operator==(const const_iterator& i) const { return m_cur == i.m_cur; } bool operator!=(const const_iterator& i) const { return m_cur != i.m_cur; } bool operator<(const const_iterator& i) const { return m_cur < i.m_cur; } bool operator>(const const_iterator& i) const { return m_cur > i.m_cur; } bool operator<=(const const_iterator& i) const { return m_cur <= i.m_cur; } bool operator>=(const const_iterator& i) const { return m_cur >= i.m_cur; } private: underlying_iterator impl() const { return m_cur; } friend class wxString; friend class wxCStrData; private: underlying_iterator m_cur;

  public:
      const_iterator() {}
      const_iterator(const const_iterator& i) : m_cur(i.m_cur) {}
      const_iterator(const iterator& i) : m_cur(i.m_cur) {}

      reference operator*() const
        { return wxStringOperations::DecodeChar(m_cur); }

      const_iterator operator+(ptrdiff_t n) const
        { return const_iterator(wxStringOperations::AddToIter(m_cur, n)); }
      const_iterator operator-(ptrdiff_t n) const
        { return const_iterator(wxStringOperations::AddToIter(m_cur, -n)); }






  private:

      const_iterator(underlying_iterator ptr) : m_cur(ptr) {}
      const_iterator(const wxString *, underlying_iterator ptr)
          : m_cur(ptr) {}
  };

  iterator GetIterForNthChar(size_t n) { return begin() + n; }
  const_iterator GetIterForNthChar(size_t n) const { return begin() + n; }
# 1105 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  ptrdiff_t IterOffsetInMBStr(const const_iterator& i) const
  {
      const wxString str(begin(), i);




      size_t ofs = wxGet_wxConvLibc().FromWChar(
# 1112 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                       __null
# 1112 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                           , 0, str.wc_str(), str.length());
      return ofs == ((size_t)-1) ? 0 : static_cast<ptrdiff_t>(ofs);
  }

  friend class iterator;
  friend class const_iterator;

  template <typename T>
  class reverse_iterator_impl
  {
  public:
      typedef T iterator_type;

      typedef typename T::iterator_category iterator_category;
      typedef typename T::value_type value_type;
      typedef typename T::difference_type difference_type;
      typedef typename T::reference reference;
      typedef typename T::pointer *pointer;

      reverse_iterator_impl() {}
      reverse_iterator_impl(iterator_type i) : m_cur(i) {}
      reverse_iterator_impl(const reverse_iterator_impl& ri)
          : m_cur(ri.m_cur) {}

      iterator_type base() const { return m_cur; }

      reference operator*() const { return *(m_cur-1); }
      reference operator[](size_t n) const { return *(*this + n); }

      reverse_iterator_impl& operator++()
        { --m_cur; return *this; }
      reverse_iterator_impl operator++(int)
        { reverse_iterator_impl tmp = *this; --m_cur; return tmp; }
      reverse_iterator_impl& operator--()
        { ++m_cur; return *this; }
      reverse_iterator_impl operator--(int)
        { reverse_iterator_impl tmp = *this; ++m_cur; return tmp; }


      reverse_iterator_impl operator+(ptrdiff_t n) const
        { return reverse_iterator_impl<T>(m_cur - n); }
      reverse_iterator_impl operator-(ptrdiff_t n) const
        { return reverse_iterator_impl<T>(m_cur + n); }
      reverse_iterator_impl operator+=(ptrdiff_t n)
        { m_cur -= n; return *this; }
      reverse_iterator_impl operator-=(ptrdiff_t n)
        { m_cur += n; return *this; }

      unsigned operator-(const reverse_iterator_impl& i) const
        { return i.m_cur - m_cur; }

      bool operator==(const reverse_iterator_impl& ri) const
        { return m_cur == ri.m_cur; }
      bool operator!=(const reverse_iterator_impl& ri) const
        { return !(*this == ri); }

      bool operator<(const reverse_iterator_impl& i) const
        { return m_cur > i.m_cur; }
      bool operator>(const reverse_iterator_impl& i) const
        { return m_cur < i.m_cur; }
      bool operator<=(const reverse_iterator_impl& i) const
        { return m_cur >= i.m_cur; }
      bool operator>=(const reverse_iterator_impl& i) const
        { return m_cur <= i.m_cur; }

  private:
      iterator_type m_cur;
  };

  typedef reverse_iterator_impl<iterator> reverse_iterator;
  typedef reverse_iterator_impl<const_iterator> const_reverse_iterator;

private:


  static const_iterator CreateConstIterator(const wxCStrData& data)
  {
      return const_iterator(data.m_str,
                            (data.m_str->begin() + data.m_offset).impl());
  }
# 1211 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  static wxString FromImpl(const wxStringImpl& src) { return wxString(src); }


public:


  wxString() {}


  wxString(const wxString& stringSrc) : m_impl(stringSrc.m_impl) { }


  wxString(wxUniChar ch, size_t nRepeat = 1 )
    { assign(nRepeat, ch); }
  wxString(size_t nRepeat, wxUniChar ch)
    { assign(nRepeat, ch); }
  wxString(wxUniCharRef ch, size_t nRepeat = 1)
    { assign(nRepeat, ch); }
  wxString(size_t nRepeat, wxUniCharRef ch)
    { assign(nRepeat, ch); }
  wxString(char ch, size_t nRepeat = 1)
    { assign(nRepeat, ch); }
  wxString(size_t nRepeat, char ch)
    { assign(nRepeat, ch); }
  wxString(wchar_t ch, size_t nRepeat = 1)
    { assign(nRepeat, ch); }
  wxString(size_t nRepeat, wchar_t ch)
    { assign(nRepeat, ch); }


  wxString(const char *psz)
    : m_impl(ImplStr(psz)) {}
  wxString(const char *psz, const wxMBConv& conv)
    : m_impl(ImplStr(psz, conv)) {}
  wxString(const char *psz, size_t nLength)
    { assign(psz, nLength); }
  wxString(const char *psz, const wxMBConv& conv, size_t nLength)
  {
    SubstrBufFromMB str(ImplStr(psz, nLength, conv));
    m_impl.assign(str.data, str.len);
  }


  wxString(const unsigned char *psz)
    : m_impl(ImplStr((const char*)psz)) {}
  wxString(const unsigned char *psz, const wxMBConv& conv)
    : m_impl(ImplStr((const char*)psz, conv)) {}
  wxString(const unsigned char *psz, size_t nLength)
    { assign((const char*)psz, nLength); }
  wxString(const unsigned char *psz, const wxMBConv& conv, size_t nLength)
  {
    SubstrBufFromMB str(ImplStr((const char*)psz, nLength, conv));
    m_impl.assign(str.data, str.len);
  }


  wxString(const wchar_t *pwz)
    : m_impl(ImplStr(pwz)) {}
  wxString(const wchar_t *pwz, const wxMBConv& )
    : m_impl(ImplStr(pwz)) {}
  wxString(const wchar_t *pwz, size_t nLength)
    { assign(pwz, nLength); }
  wxString(const wchar_t *pwz, const wxMBConv& , size_t nLength)
    { assign(pwz, nLength); }

  wxString(const wxScopedCharBuffer& buf)
    { assign(buf.data(), buf.length()); }
  wxString(const wxScopedWCharBuffer& buf)
    { assign(buf.data(), buf.length()); }




  wxString(const wxCStrData& cstr)
      : m_impl(cstr.AsString().m_impl.c_str()) { }



  wxString(const wxCStrData& cstr, size_t nLength)
      : m_impl(cstr.AsString().Mid(0, nLength).m_impl) {}



  wxString(const wxString& str, size_t nLength)
    { assign(str, nLength); }
# 1317 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    wxString(const wxStdWideString& str) : m_impl(str) {}
# 1327 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    wxString(const std::string& str)
        { assign(str.c_str(), str.length()); }
# 1339 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    const wxStdWideString& ToStdWstring() const { return m_impl; }
# 1363 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    std::string ToStdString() const
    {
        wxScopedCharBuffer buf(mb_str());
        return std::string(buf.data(), buf.length());
    }
# 1384 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  wxString Clone() const
  {


      return wxString::FromImpl(wxStringImpl(m_impl.c_str(), m_impl.length()));
  }


  const_iterator begin() const { return const_iterator(this, m_impl.begin()); }
  iterator begin() { return iterator(this, m_impl.begin()); }

  const_iterator end() const { return const_iterator(this, m_impl.end()); }
  iterator end() { return iterator(this, m_impl.end()); }


  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end()); }
  reverse_iterator rbegin()
    { return reverse_iterator(end()); }

  const_reverse_iterator rend() const
    { return const_reverse_iterator(begin()); }
  reverse_iterator rend()
    { return reverse_iterator(begin()); }
# 1438 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  size_t length() const { return m_impl.length(); }


  size_type size() const { return length(); }
  size_type max_size() const { return npos; }

  bool empty() const { return m_impl.empty(); }


  size_type capacity() const { return m_impl.capacity(); }
  void reserve(size_t sz) { m_impl.reserve(sz); }

  void resize(size_t nSize, wxUniChar ch = L'\0')
  {
    const size_t len = length();
    if ( nSize == len)
        return;
# 1475 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    {
        ;

        m_impl.resize(nSize, (wxStringCharType)ch);
    }
  }

  wxString substr(size_t nStart = 0, size_t nLen = npos) const
  {
    size_t pos, len;
    PosLenToImpl(nStart, nLen, &pos, &len);
    return FromImpl(m_impl.substr(pos, len));
  }



  size_t Len() const { return length(); }

  bool IsEmpty() const { return empty(); }

  bool operator!() const { return empty(); }

  wxString& Truncate(size_t uiLen);

  void Empty() { clear(); }

  void Clear() { clear(); }



  bool IsAscii() const;

  bool IsNumber() const;

  bool IsWord() const;



    wxUniChar at(size_t n) const
      { return wxStringOperations::DecodeChar(m_impl.begin() + PosToImpl(n)); }
    wxUniChar GetChar(size_t n) const
      { return at(n); }

    wxUniCharRef at(size_t n)
      { return *GetIterForNthChar(n); }
    wxUniCharRef GetWritableChar(size_t n)
      { return at(n); }

    void SetChar(size_t n, wxUniChar ch)
      { at(n) = ch; }


    wxUniChar Last() const
    {
      do { if ( wxTheAssertHandler && !(!empty()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 1529, __FUNCTION__, "!empty()", L"wxString: index out of bounds"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
      return *rbegin();
    }


    wxUniCharRef Last()
    {
      do { if ( wxTheAssertHandler && !(!empty()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 1536, __FUNCTION__, "!empty()", L"wxString: index out of bounds"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
      return *rbegin();
    }





    wxUniChar operator[](int n) const
      { return at(n); }
    wxUniChar operator[](long n) const
      { return at(n); }
    wxUniChar operator[](size_t n) const
      { return at(n); }

    wxUniChar operator[](unsigned int n) const
      { return at(n); }



    wxUniCharRef operator[](int n)
      { return at(n); }
    wxUniCharRef operator[](long n)
      { return at(n); }
    wxUniCharRef operator[](size_t n)
      { return at(n); }

    wxUniCharRef operator[](unsigned int n)
      { return at(n); }
# 1610 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    wxCStrData c_str() const { return wxCStrData(this); }
    wxCStrData data() const { return c_str(); }


    operator wxCStrData() const { return c_str(); }
# 1623 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    operator const char*() const { return c_str(); }
    operator const wchar_t*() const { return c_str(); }




    operator const void*() const { return c_str(); }



    const wxCStrData GetData() const { return c_str(); }



    const wxStringCharType *wx_str() const { return m_impl.c_str(); }




    wxWritableCharBuffer char_str(const wxMBConv& conv = wxGet_wxConvLibc()) const
        { return mb_str(conv); }
    wxWritableWCharBuffer wchar_str() const { return wc_str(); }
# 1654 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    template <typename T>
    wxCharTypeBuffer<T> tchar_str(size_t *len = 
# 1655 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                               __null
# 1655 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                   ,
                                  T * = 
# 1656 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                       __null
# 1656 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                           ) const
    {


        return wxPrivate::wxStringAsBufHelper<T>::Get(*this, len);







    }
# 1677 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    static wxString FromAscii(const char *ascii, size_t len);
    static wxString FromAscii(const char *ascii);
    static wxString FromAscii(char ascii);
    const wxScopedCharBuffer ToAscii() const;
# 1691 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    static wxString FromAscii(const unsigned char *ascii)
        { return FromAscii((const char *)ascii); }
    static wxString FromAscii(const unsigned char *ascii, size_t len)
        { return FromAscii((const char *)ascii, len); }
# 1742 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    static wxString FromUTF8(const char *utf8, size_t len = npos)
      { return wxString(utf8, wxMBConvUTF8(), len); }
    static wxString FromUTF8Unchecked(const char *utf8, size_t len = npos)
    {
        const wxString s(utf8, wxMBConvUTF8(), len);
        do { if ( wxTheAssertHandler && !(!utf8 || !*utf8 || !s.empty()) && (wxOnAssert(
                                                   "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 1747 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
        ,
                                                   1748
# 1747 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
        , __FUNCTION__, "!utf8 || !*utf8 || !s.empty()", "string must be valid UTF-8"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                    ;
        return s;
    }
    const wxScopedCharBuffer utf8_str() const { return mb_str(wxMBConvUTF8()); }
# 1782 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    const wxScopedCharBuffer ToUTF8() const { return utf8_str(); }



    static wxString From8BitData(const char *data, size_t len)
      { return wxString(data, wxGet_wxConvISO8859_1(), len); }

    static wxString From8BitData(const char *data)
      { return wxString(data, wxGet_wxConvISO8859_1()); }
    const wxScopedCharBuffer To8BitData() const
        { return mb_str(wxGet_wxConvISO8859_1()); }
# 1827 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    const wxScopedCharBuffer mb_str(const wxMBConv& conv = wxGet_wxConvLibc()) const
    {
        return AsCharBuf(conv);
    }


    const wxCharBuffer mbc_str() const { return mb_str(*wxConvCurrent); }


    const wchar_t* wc_str() const { return wx_str(); }





    const wxChar* wc_str(const wxMBConv& ) const
      { return wc_str(); }




    const wxChar* fn_str() const { return wc_str(); }
# 1869 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    const wchar_t* t_str() const { return wx_str(); }







  wxString& operator=(const wxString& stringSrc)
  {
    if ( this != &stringSrc )
    {
        ;

        m_impl = stringSrc.m_impl;
    }

    return *this;
  }

  wxString& operator=(const wxCStrData& cstr)
    { return *this = cstr.AsString(); }

  wxString& operator=(wxUniChar ch)
  {
    ;






        m_impl = (wxStringCharType)ch;
    return *this;
  }

  wxString& operator=(wxUniCharRef ch)
    { return operator=((wxUniChar)ch); }
  wxString& operator=(char ch)
    { return operator=(wxUniChar(ch)); }
  wxString& operator=(unsigned char ch)
    { return operator=(wxUniChar(ch)); }
  wxString& operator=(wchar_t ch)
    { return operator=(wxUniChar(ch)); }



  wxString& operator=(const char *psz)
  {
      ;

      if ( psz )
          m_impl = ImplStr(psz);
      else
          clear();

      return *this;
  }

  wxString& operator=(const wchar_t *pwz)
  {
      ;

      if ( pwz )
          m_impl = ImplStr(pwz);
      else
          clear();

      return *this;
  }
# 1959 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  wxString& operator=(const unsigned char *psz)
    { return operator=((const char*)psz); }


  wxString& operator=(const wxScopedWCharBuffer& s)
    { return assign(s); }

  wxString& operator=(const wxScopedCharBuffer& s)
    { return assign(s); }
# 1977 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  wxString& operator<<(const wxString& s)
  {





    append(s);
    return *this;
  }

  wxString& operator<<(const char *psz)
    { append(psz); return *this; }
  wxString& operator<<(const wchar_t *pwz)
    { append(pwz); return *this; }
  wxString& operator<<(const wxCStrData& psz)
    { append(psz.AsString()); return *this; }

  wxString& operator<<(wxUniChar ch) { append(1, ch); return *this; }
  wxString& operator<<(wxUniCharRef ch) { append(1, ch); return *this; }
  wxString& operator<<(char ch) { append(1, ch); return *this; }
  wxString& operator<<(unsigned char ch) { append(1, ch); return *this; }
  wxString& operator<<(wchar_t ch) { append(1, ch); return *this; }


  wxString& operator<<(const wxScopedWCharBuffer& s)
    { return append(s); }
  wxString& operator<<(const wxScopedCharBuffer& s)
    { return append(s); }


  wxString& Append(const wxString& s)
    {

        if ( empty() )
            *this = s;
        else
            append(s);
        return *this;
    }
  wxString& Append(const char* psz)
    { append(psz); return *this; }
  wxString& Append(const wchar_t* pwz)
    { append(pwz); return *this; }
  wxString& Append(const wxCStrData& psz)
    { append(psz); return *this; }
  wxString& Append(const wxScopedCharBuffer& psz)
    { append(psz); return *this; }
  wxString& Append(const wxScopedWCharBuffer& psz)
    { append(psz); return *this; }
  wxString& Append(const char* psz, size_t nLen)
    { append(psz, nLen); return *this; }
  wxString& Append(const wchar_t* pwz, size_t nLen)
    { append(pwz, nLen); return *this; }
  wxString& Append(const wxCStrData& psz, size_t nLen)
    { append(psz, nLen); return *this; }
  wxString& Append(const wxScopedCharBuffer& psz, size_t nLen)
    { append(psz, nLen); return *this; }
  wxString& Append(const wxScopedWCharBuffer& psz, size_t nLen)
    { append(psz, nLen); return *this; }

  wxString& Append(wxUniChar ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(wxUniCharRef ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(char ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(unsigned char ch, size_t count = 1u)
    { append(count, ch); return *this; }
  wxString& Append(wchar_t ch, size_t count = 1u)
    { append(count, ch); return *this; }


  wxString& Prepend(const wxString& str)
    { *this = str + *this; return *this; }



  friend wxString operator+(const wxString& string1,
                                             const wxString& string2);

  friend wxString operator+(const wxString& string, wxUniChar ch);

  friend wxString operator+(wxUniChar ch, const wxString& string);

  friend wxString operator+(const wxString& string,
                                             const char *psz);
  friend wxString operator+(const wxString& string,
                                             const wchar_t *pwz);

  friend wxString operator+(const char *psz,
                                             const wxString& string);
  friend wxString operator+(const wchar_t *pwz,
                                             const wxString& string);



  wxString& operator<<(int i)
    { return (*this) << Format(L"%d", i); }

  wxString& operator<<(unsigned int ui)
    { return (*this) << Format(L"%u", ui); }

  wxString& operator<<(long l)
    { return (*this) << Format(L"%ld", l); }

  wxString& operator<<(unsigned long ul)
    { return (*this) << Format(L"%lu", ul); }


  wxString& operator<<(long long ll)
    {
      return (*this) << Format("%" "I64" "d", ll);
    }

  wxString& operator<<(unsigned long long ull)
    {
      return (*this) << Format("%" "I64" "u" , ull);
    }


  wxString& operator<<(float f)
    { return (*this) << Format(L"%f", f); }

  wxString& operator<<(double d)
    { return (*this) << Format(L"%g", d); }



  int Cmp(const char *psz) const
    { return compare(psz); }
  int Cmp(const wchar_t *pwz) const
    { return compare(pwz); }
  int Cmp(const wxString& s) const
    { return compare(s); }
  int Cmp(const wxCStrData& s) const
    { return compare(s); }
  int Cmp(const wxScopedCharBuffer& s) const
    { return compare(s); }
  int Cmp(const wxScopedWCharBuffer& s) const
    { return compare(s); }

  int CmpNoCase(const wxString& s) const;



  bool IsSameAs(const wxString& str, bool compareWithCase = true) const
  {


      if ( length() != str.length() )
          return false;

      return (compareWithCase ? Cmp(str) : CmpNoCase(str)) == 0;
  }
  bool IsSameAs(const char *str, bool compareWithCase = true) const
    { return (compareWithCase ? Cmp(str) : CmpNoCase(str)) == 0; }
  bool IsSameAs(const wchar_t *str, bool compareWithCase = true) const
    { return (compareWithCase ? Cmp(str) : CmpNoCase(str)) == 0; }

  bool IsSameAs(const wxCStrData& str, bool compareWithCase = true) const
    { return IsSameAs(str.AsString(), compareWithCase); }
  bool IsSameAs(const wxScopedCharBuffer& str, bool compareWithCase = true) const
    { return IsSameAs(str.data(), compareWithCase); }
  bool IsSameAs(const wxScopedWCharBuffer& str, bool compareWithCase = true) const
    { return IsSameAs(str.data(), compareWithCase); }

  bool IsSameAs(wxUniChar c, bool compareWithCase = true) const;

  bool IsSameAs(wxUniCharRef c, bool compareWithCase = true) const
    { return IsSameAs(wxUniChar(c), compareWithCase); }
  bool IsSameAs(char c, bool compareWithCase = true) const
    { return IsSameAs(wxUniChar(c), compareWithCase); }
  bool IsSameAs(unsigned char c, bool compareWithCase = true) const
    { return IsSameAs(wxUniChar(c), compareWithCase); }
  bool IsSameAs(wchar_t c, bool compareWithCase = true) const
    { return IsSameAs(wxUniChar(c), compareWithCase); }
  bool IsSameAs(int c, bool compareWithCase = true) const
    { return IsSameAs(wxUniChar(c), compareWithCase); }




  wxString Mid(size_t nFirst, size_t nCount = npos) const;


  wxString operator()(size_t start, size_t len) const
    { return Mid(start, len); }




  bool StartsWith(const wxString& prefix, wxString *rest = 
# 2169 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                          __null
# 2169 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                              ) const;



  bool EndsWith(const wxString& suffix, wxString *rest = 
# 2173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                        __null
# 2173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                            ) const;


  wxString Left(size_t nCount) const;

  wxString Right(size_t nCount) const;



  wxString BeforeFirst(wxUniChar ch, wxString *rest = 
# 2182 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                     __null
# 2182 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                         ) const;



  wxString BeforeLast(wxUniChar ch, wxString *rest = 
# 2186 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                    __null
# 2186 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                        ) const;


  wxString AfterFirst(wxUniChar ch) const;


  wxString AfterLast(wxUniChar ch) const;


  wxString Before(wxUniChar ch) const { return BeforeLast(ch); }
  wxString After(wxUniChar ch) const { return AfterFirst(ch); }



  wxString& MakeUpper();

  wxString Upper() const { return wxString(*this).MakeUpper(); }

  wxString& MakeLower();

  wxString Lower() const { return wxString(*this).MakeLower(); }


  wxString& MakeCapitalized();


  wxString Capitalize() const { return wxString(*this).MakeCapitalized(); }



  wxString& Trim(bool bFromRight = true);

  wxString& Pad(size_t nCount, wxUniChar chPad = L' ', bool bFromRight = true);



  int Find(wxUniChar ch, bool bFromEnd = false) const;
  int Find(wxUniCharRef ch, bool bFromEnd = false) const
    { return Find(wxUniChar(ch), bFromEnd); }
  int Find(char ch, bool bFromEnd = false) const
    { return Find(wxUniChar(ch), bFromEnd); }
  int Find(unsigned char ch, bool bFromEnd = false) const
    { return Find(wxUniChar(ch), bFromEnd); }
  int Find(wchar_t ch, bool bFromEnd = false) const
    { return Find(wxUniChar(ch), bFromEnd); }

  int Find(const wxString& sub) const
  {
    size_type idx = find(sub);
    return (idx == npos) ? (-1) : (int)idx;
  }
  int Find(const char *sub) const
  {
    size_type idx = find(sub);
    return (idx == npos) ? (-1) : (int)idx;
  }
  int Find(const wchar_t *sub) const
  {
    size_type idx = find(sub);
    return (idx == npos) ? (-1) : (int)idx;
  }

  int Find(const wxCStrData& sub) const
    { return Find(sub.AsString()); }
  int Find(const wxScopedCharBuffer& sub) const
    { return Find(sub.data()); }
  int Find(const wxScopedWCharBuffer& sub) const
    { return Find(sub.data()); }



  size_t Replace(const wxString& strOld,
                 const wxString& strNew,
                 bool bReplaceAll = true);


  bool Matches(const wxString& mask) const;







  bool ToLong(long *val, int base = 10) const;

  bool ToULong(unsigned long *val, int base = 10) const;


  bool ToLongLong(long long *val, int base = 10) const;

  bool ToULongLong(unsigned long long *val, int base = 10) const;


  bool ToDouble(double *val) const;



  bool ToCLong(long *val, int base = 10) const;

  bool ToCULong(unsigned long *val, int base = 10) const;

  bool ToCDouble(double *val) const;




  static wxString FromDouble(double val, int precision = -1);

  static wxString FromCDouble(double val, int precision = -1);






  inline int Printf(const wxFormatString& f1) { return DoPrintfWchar(f1); } template<typename T1> int Printf(const wxFormatString& f1, T1 a1) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int Printf(const wxFormatString& f1, T1 a1, T2 a2) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }
# 2317 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  int PrintfV(const wxString& format, va_list argptr);




  inline static wxString Format(const wxFormatString& f1) { return DoFormatWchar(f1); } template<typename T1> static wxString Format(const wxFormatString& f1, T1 a1) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> static wxString Format(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoFormatWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }
# 2337 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  static wxString FormatV(const wxString& format, va_list argptr);




  bool Alloc(size_t nLen) { reserve(nLen); return capacity() >= nLen; }


  bool Shrink();
# 2360 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  wxString SubString(size_t from, size_t to) const
      { return Mid(from, (to - from + 1)); }

  enum caseCompare {exact, ignoreCase};

  enum stripType {leading = 0x1, trailing = 0x2, both = 0x3};





  inline int sprintf(const wxFormatString& f1) { return DoPrintfWchar(f1); } template<typename T1> int sprintf(const wxFormatString& f1, T1 a1) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int sprintf(const wxFormatString& f1, T1 a1, T2 a2) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int sprintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }
# 2387 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  int CompareTo(const wxChar* psz, caseCompare cmp = exact) const
    { return cmp == exact ? Cmp(psz) : CmpNoCase(psz); }


  size_t Length() const { return length(); }

  int Freq(wxUniChar ch) const;

  void LowerCase() { MakeLower(); }

  void UpperCase() { MakeUpper(); }

  wxString Strip(stripType w = trailing) const;


  size_t Index(const wxChar* psz) const { return Find(psz); }
  size_t Index(wxUniChar ch) const { return Find(ch); }

  wxString& Remove(size_t pos) { return Truncate(pos); }
  wxString& RemoveLast(size_t n = 1) { return Truncate(length() - n); }

  wxString& Remove(size_t nStart, size_t nLen)
      { return (wxString&)erase( nStart, nLen ); }


  int First( wxUniChar ch ) const { return Find(ch); }
  int First( wxUniCharRef ch ) const { return Find(ch); }
  int First( char ch ) const { return Find(ch); }
  int First( unsigned char ch ) const { return Find(ch); }
  int First( wchar_t ch ) const { return Find(ch); }
  int First( const wxString& str ) const { return Find(str); }
  int Last( wxUniChar ch ) const { return Find(ch, true); }
  bool Contains(const wxString& str) const { return Find(str) != (-1); }


  bool IsNull() const { return empty(); }




  wxString(const wxString& str, size_t nPos, size_t nLen)
      { assign(str, nPos, nLen); }

  wxString(const_iterator first, const_iterator last)
      : m_impl(first.impl(), last.impl()) { }



  wxString(const char *first, const char *last)
  {
      SubstrBufFromMB str(ImplStr(first, last - first));
      m_impl.assign(str.data, str.len);
  }
  wxString(const wchar_t *first, const wchar_t *last)
  {
      SubstrBufFromWC str(ImplStr(first, last - first));
      m_impl.assign(str.data, str.len);
  }

  wxString(const wxCStrData& first, const wxCStrData& last)
      : m_impl(CreateConstIterator(first).impl(),
               CreateConstIterator(last).impl())
  {
      do { if ( wxTheAssertHandler && !(first.m_str == last.m_str) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 2450 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      ,
 2451
# 2450 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      , __FUNCTION__, "first.m_str == last.m_str", L"pointers must be into the same string"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                  ;
  }




  wxString& append(const wxString& str, size_t pos, size_t n)
  {
      ;

      size_t from, len;
      str.PosLenToImpl(pos, n, &from, &len);
      m_impl.append(str.m_impl, from, len);
      return *this;
  }

  wxString& append(const wxString& str)
  {
      ;

      m_impl.append(str.m_impl);
      return *this;
  }


  wxString& append(const char *sz)
  {
      ;

      m_impl.append(ImplStr(sz));
      return *this;
  }

  wxString& append(const wchar_t *sz)
  {
      ;

      m_impl.append(ImplStr(sz));
      return *this;
  }

  wxString& append(const char *sz, size_t n)
  {
      ;

      SubstrBufFromMB str(ImplStr(sz, n));
      m_impl.append(str.data, str.len);
      return *this;
  }
  wxString& append(const wchar_t *sz, size_t n)
  {
      ;

      SubstrBufFromWC str(ImplStr(sz, n));
      m_impl.append(str.data, str.len);
      return *this;
  }

  wxString& append(const wxCStrData& str)
    { return append(str.AsString()); }
  wxString& append(const wxScopedCharBuffer& str)
    { return append(str.data(), str.length()); }
  wxString& append(const wxScopedWCharBuffer& str)
    { return append(str.data(), str.length()); }
  wxString& append(const wxCStrData& str, size_t n)
    { return append(str.AsString(), 0, n); }
  wxString& append(const wxScopedCharBuffer& str, size_t n)
    { return append(str.data(), n); }
  wxString& append(const wxScopedWCharBuffer& str, size_t n)
    { return append(str.data(), n); }


  wxString& append(size_t n, wxUniChar ch)
  {
# 2534 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      {
          ;

          m_impl.append(n, (wxStringCharType)ch);
      }

      return *this;
  }

  wxString& append(size_t n, wxUniCharRef ch)
    { return append(n, wxUniChar(ch)); }
  wxString& append(size_t n, char ch)
    { return append(n, wxUniChar(ch)); }
  wxString& append(size_t n, unsigned char ch)
    { return append(n, wxUniChar(ch)); }
  wxString& append(size_t n, wchar_t ch)
    { return append(n, wxUniChar(ch)); }


  wxString& append(const_iterator first, const_iterator last)
  {
      ;

      m_impl.append(first.impl(), last.impl());
      return *this;
  }

  wxString& append(const char *first, const char *last)
    { return append(first, last - first); }
  wxString& append(const wchar_t *first, const wchar_t *last)
    { return append(first, last - first); }
  wxString& append(const wxCStrData& first, const wxCStrData& last)
    { return append(CreateConstIterator(first), CreateConstIterator(last)); }



  wxString& assign(const wxString& str)
  {
      ;

      m_impl = str.m_impl;

      return *this;
  }



  wxString& assign(const wxString& str, size_t len)
  {
# 2595 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      m_impl.assign(str.m_impl, 0, str.LenToImpl(len));

      return *this;
  }


  wxString& assign(const wxString& str, size_t pos, size_t n)
  {
      size_t from, len;
      str.PosLenToImpl(pos, n, &from, &len);
      m_impl.assign(str.m_impl, from, len);



      ;

      return *this;
  }


  wxString& assign(const char *sz)
  {
      ;

      m_impl.assign(ImplStr(sz));

      return *this;
  }

  wxString& assign(const wchar_t *sz)
  {
      ;

      m_impl.assign(ImplStr(sz));

      return *this;
  }

  wxString& assign(const char *sz, size_t n)
  {
      ;

      SubstrBufFromMB str(ImplStr(sz, n));
      m_impl.assign(str.data, str.len);

      return *this;
  }

  wxString& assign(const wchar_t *sz, size_t n)
  {
      ;

      SubstrBufFromWC str(ImplStr(sz, n));
      m_impl.assign(str.data, str.len);

      return *this;
  }

  wxString& assign(const wxCStrData& str)
    { return assign(str.AsString()); }
  wxString& assign(const wxScopedCharBuffer& str)
    { return assign(str.data(), str.length()); }
  wxString& assign(const wxScopedWCharBuffer& str)
    { return assign(str.data(), str.length()); }
  wxString& assign(const wxCStrData& str, size_t len)
    { return assign(str.AsString(), len); }
  wxString& assign(const wxScopedCharBuffer& str, size_t len)
    { return assign(str.data(), len); }
  wxString& assign(const wxScopedWCharBuffer& str, size_t len)
    { return assign(str.data(), len); }


  wxString& assign(size_t n, wxUniChar ch)
  {
      ;






          m_impl.assign(n, (wxStringCharType)ch);

      return *this;
  }

  wxString& assign(size_t n, wxUniCharRef ch)
    { return assign(n, wxUniChar(ch)); }
  wxString& assign(size_t n, char ch)
    { return assign(n, wxUniChar(ch)); }
  wxString& assign(size_t n, unsigned char ch)
    { return assign(n, wxUniChar(ch)); }
  wxString& assign(size_t n, wchar_t ch)
    { return assign(n, wxUniChar(ch)); }


  wxString& assign(const_iterator first, const_iterator last)
  {
      ;

      m_impl.assign(first.impl(), last.impl());

      return *this;
  }

  wxString& assign(const char *first, const char *last)
    { return assign(first, last - first); }
  wxString& assign(const wchar_t *first, const wchar_t *last)
    { return assign(first, last - first); }
  wxString& assign(const wxCStrData& first, const wxCStrData& last)
    { return assign(CreateConstIterator(first), CreateConstIterator(last)); }



  int compare(const wxString& str) const;
  int compare(const char* sz) const;
  int compare(const wchar_t* sz) const;
  int compare(const wxCStrData& str) const
    { return compare(str.AsString()); }
  int compare(const wxScopedCharBuffer& str) const
    { return compare(str.data()); }
  int compare(const wxScopedWCharBuffer& str) const
    { return compare(str.data()); }

  int compare(size_t nStart, size_t nLen, const wxString& str) const;

  int compare(size_t nStart, size_t nLen,
              const wxString& str, size_t nStart2, size_t nLen2) const;

  int compare(size_t nStart, size_t nLen,
              const char* sz, size_t nCount = npos) const;
  int compare(size_t nStart, size_t nLen,
              const wchar_t* sz, size_t nCount = npos) const;


  wxString& insert(size_t nPos, const wxString& str)
    { insert(GetIterForNthChar(nPos), str.begin(), str.end()); return *this; }

  wxString& insert(size_t nPos, const wxString& str, size_t nStart, size_t n)
  {
      ;

      size_t from, len;
      str.PosLenToImpl(nStart, n, &from, &len);
      m_impl.insert(PosToImpl(nPos), str.m_impl, from, len);

      return *this;
  }


  wxString& insert(size_t nPos, const char *sz)
  {
      ;

      m_impl.insert(PosToImpl(nPos), ImplStr(sz));

      return *this;
  }

  wxString& insert(size_t nPos, const wchar_t *sz)
  {
      ;

      m_impl.insert(PosToImpl(nPos), ImplStr(sz)); return *this;
  }

  wxString& insert(size_t nPos, const char *sz, size_t n)
  {
      ;

      SubstrBufFromMB str(ImplStr(sz, n));
      m_impl.insert(PosToImpl(nPos), str.data, str.len);

      return *this;
  }

  wxString& insert(size_t nPos, const wchar_t *sz, size_t n)
  {
      ;

      SubstrBufFromWC str(ImplStr(sz, n));
      m_impl.insert(PosToImpl(nPos), str.data, str.len);

      return *this;
  }


  wxString& insert(size_t nPos, size_t n, wxUniChar ch)
  {
      ;






          m_impl.insert(PosToImpl(nPos), n, (wxStringCharType)ch);
      return *this;
  }

  iterator insert(iterator it, wxUniChar ch)
  {
      ;
# 2808 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
          return iterator(this, m_impl.insert(it.impl(), (wxStringCharType)ch));
  }

  void insert(iterator it, const_iterator first, const_iterator last)
  {
      ;

      m_impl.insert(it.impl(), first.impl(), last.impl());
  }


  void insert(iterator it, const char *first, const char *last)
    { insert(it - begin(), first, last - first); }
  void insert(iterator it, const wchar_t *first, const wchar_t *last)
    { insert(it - begin(), first, last - first); }
  void insert(iterator it, const wxCStrData& first, const wxCStrData& last)
    { insert(it, CreateConstIterator(first), CreateConstIterator(last)); }


  void insert(iterator it, size_type n, wxUniChar ch)
  {
      ;






          m_impl.insert(it.impl(), n, (wxStringCharType)ch);
  }


  wxString& erase(size_type pos = 0, size_type n = npos)
  {
      ;

      size_t from, len;
      PosLenToImpl(pos, n, &from, &len);
      m_impl.erase(from, len);

      return *this;
  }


  iterator erase(iterator first, iterator last)
  {
      ;

      return iterator(this, m_impl.erase(first.impl(), last.impl()));
  }

  iterator erase(iterator first)
  {
      ;

      return iterator(this, m_impl.erase(first.impl()));
  }


  void clear() { erase(); }
# 2878 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  wxString& replace(size_t nStart, size_t nLen, const char* sz)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);
      m_impl.replace(from, len, ImplStr(sz));

      return *this;
  }

  wxString& replace(size_t nStart, size_t nLen, const wchar_t* sz)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);
      m_impl.replace(from, len, ImplStr(sz));

      return *this;
  }


  wxString& replace(size_t nStart, size_t nLen, const wxString& str)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);
      m_impl.replace(from, len, str.m_impl);

      return *this;
  }


  wxString& replace(size_t nStart, size_t nLen, size_t nCount, wxUniChar ch)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);





          m_impl.replace(from, len, nCount, (wxStringCharType)ch);

      return *this;
  }


  wxString& replace(size_t nStart, size_t nLen,
                    const wxString& str, size_t nStart2, size_t nLen2)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);

      size_t from2, len2;
      str.PosLenToImpl(nStart2, nLen2, &from2, &len2);

      m_impl.replace(from, len, str.m_impl, from2, len2);

      return *this;
  }


  wxString& replace(size_t nStart, size_t nLen,
                    const char* sz, size_t nCount)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);

      SubstrBufFromMB str(ImplStr(sz, nCount));

      m_impl.replace(from, len, str.data, str.len);

      return *this;
  }

  wxString& replace(size_t nStart, size_t nLen,
                    const wchar_t* sz, size_t nCount)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);

      SubstrBufFromWC str(ImplStr(sz, nCount));

      m_impl.replace(from, len, str.data, str.len);

      return *this;
  }

  wxString& replace(size_t nStart, size_t nLen,
                    const wxString& s, size_t nCount)
  {
      ;

      size_t from, len;
      PosLenToImpl(nStart, nLen, &from, &len);
      m_impl.replace(from, len, s.m_impl.c_str(), s.LenToImpl(nCount));

      return *this;
  }

  wxString& replace(iterator first, iterator last, const char* s)
  {
      ;

      m_impl.replace(first.impl(), last.impl(), ImplStr(s));

      return *this;
  }

  wxString& replace(iterator first, iterator last, const wchar_t* s)
  {
      ;

      m_impl.replace(first.impl(), last.impl(), ImplStr(s));

      return *this;
  }

  wxString& replace(iterator first, iterator last, const char* s, size_type n)
  {
      ;

      SubstrBufFromMB str(ImplStr(s, n));
      m_impl.replace(first.impl(), last.impl(), str.data, str.len);

      return *this;
  }

  wxString& replace(iterator first, iterator last, const wchar_t* s, size_type n)
  {
      ;

      SubstrBufFromWC str(ImplStr(s, n));
      m_impl.replace(first.impl(), last.impl(), str.data, str.len);

      return *this;
  }

  wxString& replace(iterator first, iterator last, const wxString& s)
  {
      ;

      m_impl.replace(first.impl(), last.impl(), s.m_impl);

      return *this;
  }

  wxString& replace(iterator first, iterator last, size_type n, wxUniChar ch)
  {
      ;







          m_impl.replace(first.impl(), last.impl(), n, (wxStringCharType)ch);

      return *this;
  }

  wxString& replace(iterator first, iterator last,
                    const_iterator first1, const_iterator last1)
  {
      ;

      m_impl.replace(first.impl(), last.impl(), first1.impl(), last1.impl());

      return *this;
  }

  wxString& replace(iterator first, iterator last,
                    const char *first1, const char *last1)
    { replace(first, last, first1, last1 - first1); return *this; }
  wxString& replace(iterator first, iterator last,
                    const wchar_t *first1, const wchar_t *last1)
    { replace(first, last, first1, last1 - first1); return *this; }


  void swap(wxString& str)
  {
# 3079 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      m_impl.swap(str.m_impl);
  }


  size_t find(const wxString& str, size_t nStart = 0) const
    { return PosFromImpl(m_impl.find(str.m_impl, PosToImpl(nStart))); }


  size_t find(const char* sz, size_t nStart = 0, size_t n = npos) const
  {
      SubstrBufFromMB str(ImplStr(sz, n));
      return PosFromImpl(m_impl.find(str.data, PosToImpl(nStart), str.len));
  }
  size_t find(const wchar_t* sz, size_t nStart = 0, size_t n = npos) const
  {
      SubstrBufFromWC str(ImplStr(sz, n));
      return PosFromImpl(m_impl.find(str.data, PosToImpl(nStart), str.len));
  }
  size_t find(const wxScopedCharBuffer& s, size_t nStart = 0, size_t n = npos) const
    { return find(s.data(), nStart, n); }
  size_t find(const wxScopedWCharBuffer& s, size_t nStart = 0, size_t n = npos) const
    { return find(s.data(), nStart, n); }
  size_t find(const wxCStrData& s, size_t nStart = 0, size_t n = npos) const
    { return find(s.AsWChar(), nStart, n); }


  size_t find(wxUniChar ch, size_t nStart = 0) const
  {






        return PosFromImpl(m_impl.find((wxStringCharType)ch,
                                       PosToImpl(nStart)));

  }
  size_t find(wxUniCharRef ch, size_t nStart = 0) const
    { return find(wxUniChar(ch), nStart); }
  size_t find(char ch, size_t nStart = 0) const
    { return find(wxUniChar(ch), nStart); }
  size_t find(unsigned char ch, size_t nStart = 0) const
    { return find(wxUniChar(ch), nStart); }
  size_t find(wchar_t ch, size_t nStart = 0) const
    { return find(wxUniChar(ch), nStart); }




  size_t rfind(const wxString& str, size_t nStart = npos) const
    { return PosFromImpl(m_impl.rfind(str.m_impl, PosToImpl(nStart))); }


  size_t rfind(const char* sz, size_t nStart = npos, size_t n = npos) const
  {
      SubstrBufFromMB str(ImplStr(sz, n));
      return PosFromImpl(m_impl.rfind(str.data, PosToImpl(nStart), str.len));
  }
  size_t rfind(const wchar_t* sz, size_t nStart = npos, size_t n = npos) const
  {
      SubstrBufFromWC str(ImplStr(sz, n));
      return PosFromImpl(m_impl.rfind(str.data, PosToImpl(nStart), str.len));
  }
  size_t rfind(const wxScopedCharBuffer& s, size_t nStart = npos, size_t n = npos) const
    { return rfind(s.data(), nStart, n); }
  size_t rfind(const wxScopedWCharBuffer& s, size_t nStart = npos, size_t n = npos) const
    { return rfind(s.data(), nStart, n); }
  size_t rfind(const wxCStrData& s, size_t nStart = npos, size_t n = npos) const
    { return rfind(s.AsWChar(), nStart, n); }

  size_t rfind(wxUniChar ch, size_t nStart = npos) const
  {






        return PosFromImpl(m_impl.rfind((wxStringCharType)ch,
                                        PosToImpl(nStart)));
  }
  size_t rfind(wxUniCharRef ch, size_t nStart = npos) const
    { return rfind(wxUniChar(ch), nStart); }
  size_t rfind(char ch, size_t nStart = npos) const
    { return rfind(wxUniChar(ch), nStart); }
  size_t rfind(unsigned char ch, size_t nStart = npos) const
    { return rfind(wxUniChar(ch), nStart); }
  size_t rfind(wchar_t ch, size_t nStart = npos) const
    { return rfind(wxUniChar(ch), nStart); }






  size_t find_first_of(const wxString& str, size_t nStart = 0) const
    { return m_impl.find_first_of(str.m_impl, nStart); }
  size_t find_first_of(const char* sz, size_t nStart = 0) const
    { return m_impl.find_first_of(ImplStr(sz), nStart); }
  size_t find_first_of(const wchar_t* sz, size_t nStart = 0) const
    { return m_impl.find_first_of(ImplStr(sz), nStart); }
  size_t find_first_of(const char* sz, size_t nStart, size_t n) const
    { return m_impl.find_first_of(ImplStr(sz), nStart, n); }
  size_t find_first_of(const wchar_t* sz, size_t nStart, size_t n) const
    { return m_impl.find_first_of(ImplStr(sz), nStart, n); }
  size_t find_first_of(wxUniChar c, size_t nStart = 0) const
    { return m_impl.find_first_of((wxChar)c, nStart); }

  size_t find_last_of(const wxString& str, size_t nStart = npos) const
    { return m_impl.find_last_of(str.m_impl, nStart); }
  size_t find_last_of(const char* sz, size_t nStart = npos) const
    { return m_impl.find_last_of(ImplStr(sz), nStart); }
  size_t find_last_of(const wchar_t* sz, size_t nStart = npos) const
    { return m_impl.find_last_of(ImplStr(sz), nStart); }
  size_t find_last_of(const char* sz, size_t nStart, size_t n) const
    { return m_impl.find_last_of(ImplStr(sz), nStart, n); }
  size_t find_last_of(const wchar_t* sz, size_t nStart, size_t n) const
    { return m_impl.find_last_of(ImplStr(sz), nStart, n); }
  size_t find_last_of(wxUniChar c, size_t nStart = npos) const
    { return m_impl.find_last_of((wxChar)c, nStart); }

  size_t find_first_not_of(const wxString& str, size_t nStart = 0) const
    { return m_impl.find_first_not_of(str.m_impl, nStart); }
  size_t find_first_not_of(const char* sz, size_t nStart = 0) const
    { return m_impl.find_first_not_of(ImplStr(sz), nStart); }
  size_t find_first_not_of(const wchar_t* sz, size_t nStart = 0) const
    { return m_impl.find_first_not_of(ImplStr(sz), nStart); }
  size_t find_first_not_of(const char* sz, size_t nStart, size_t n) const
    { return m_impl.find_first_not_of(ImplStr(sz), nStart, n); }
  size_t find_first_not_of(const wchar_t* sz, size_t nStart, size_t n) const
    { return m_impl.find_first_not_of(ImplStr(sz), nStart, n); }
  size_t find_first_not_of(wxUniChar c, size_t nStart = 0) const
    { return m_impl.find_first_not_of((wxChar)c, nStart); }

  size_t find_last_not_of(const wxString& str, size_t nStart = npos) const
    { return m_impl.find_last_not_of(str.m_impl, nStart); }
  size_t find_last_not_of(const char* sz, size_t nStart = npos) const
    { return m_impl.find_last_not_of(ImplStr(sz), nStart); }
  size_t find_last_not_of(const wchar_t* sz, size_t nStart = npos) const
    { return m_impl.find_last_not_of(ImplStr(sz), nStart); }
  size_t find_last_not_of(const char* sz, size_t nStart, size_t n) const
    { return m_impl.find_last_not_of(ImplStr(sz), nStart, n); }
  size_t find_last_not_of(const wchar_t* sz, size_t nStart, size_t n) const
    { return m_impl.find_last_not_of(ImplStr(sz), nStart, n); }
  size_t find_last_not_of(wxUniChar c, size_t nStart = npos) const
    { return m_impl.find_last_not_of((wxChar)c, nStart); }
# 3295 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  size_t find_first_of(wxUniCharRef ch, size_t nStart = 0) const
    { return find_first_of(wxUniChar(ch), nStart); }
  size_t find_first_of(char ch, size_t nStart = 0) const
    { return find_first_of(wxUniChar(ch), nStart); }
  size_t find_first_of(unsigned char ch, size_t nStart = 0) const
    { return find_first_of(wxUniChar(ch), nStart); }
  size_t find_first_of(wchar_t ch, size_t nStart = 0) const
    { return find_first_of(wxUniChar(ch), nStart); }
  size_t find_last_of(wxUniCharRef ch, size_t nStart = npos) const
    { return find_last_of(wxUniChar(ch), nStart); }
  size_t find_last_of(char ch, size_t nStart = npos) const
    { return find_last_of(wxUniChar(ch), nStart); }
  size_t find_last_of(unsigned char ch, size_t nStart = npos) const
    { return find_last_of(wxUniChar(ch), nStart); }
  size_t find_last_of(wchar_t ch, size_t nStart = npos) const
    { return find_last_of(wxUniChar(ch), nStart); }
  size_t find_first_not_of(wxUniCharRef ch, size_t nStart = 0) const
    { return find_first_not_of(wxUniChar(ch), nStart); }
  size_t find_first_not_of(char ch, size_t nStart = 0) const
    { return find_first_not_of(wxUniChar(ch), nStart); }
  size_t find_first_not_of(unsigned char ch, size_t nStart = 0) const
    { return find_first_not_of(wxUniChar(ch), nStart); }
  size_t find_first_not_of(wchar_t ch, size_t nStart = 0) const
    { return find_first_not_of(wxUniChar(ch), nStart); }
  size_t find_last_not_of(wxUniCharRef ch, size_t nStart = npos) const
    { return find_last_not_of(wxUniChar(ch), nStart); }
  size_t find_last_not_of(char ch, size_t nStart = npos) const
    { return find_last_not_of(wxUniChar(ch), nStart); }
  size_t find_last_not_of(unsigned char ch, size_t nStart = npos) const
    { return find_last_not_of(wxUniChar(ch), nStart); }
  size_t find_last_not_of(wchar_t ch, size_t nStart = npos) const
    { return find_last_not_of(wxUniChar(ch), nStart); }


  size_t find_first_of(const wxCStrData& sz, size_t nStart = 0) const
    { return find_first_of(sz.AsString(), nStart); }
  size_t find_first_of(const wxScopedCharBuffer& sz, size_t nStart = 0) const
    { return find_first_of(sz.data(), nStart); }
  size_t find_first_of(const wxScopedWCharBuffer& sz, size_t nStart = 0) const
    { return find_first_of(sz.data(), nStart); }
  size_t find_first_of(const wxCStrData& sz, size_t nStart, size_t n) const
    { return find_first_of(sz.AsWChar(), nStart, n); }
  size_t find_first_of(const wxScopedCharBuffer& sz, size_t nStart, size_t n) const
    { return find_first_of(sz.data(), nStart, n); }
  size_t find_first_of(const wxScopedWCharBuffer& sz, size_t nStart, size_t n) const
    { return find_first_of(sz.data(), nStart, n); }

  size_t find_last_of(const wxCStrData& sz, size_t nStart = 0) const
    { return find_last_of(sz.AsString(), nStart); }
  size_t find_last_of(const wxScopedCharBuffer& sz, size_t nStart = 0) const
    { return find_last_of(sz.data(), nStart); }
  size_t find_last_of(const wxScopedWCharBuffer& sz, size_t nStart = 0) const
    { return find_last_of(sz.data(), nStart); }
  size_t find_last_of(const wxCStrData& sz, size_t nStart, size_t n) const
    { return find_last_of(sz.AsWChar(), nStart, n); }
  size_t find_last_of(const wxScopedCharBuffer& sz, size_t nStart, size_t n) const
    { return find_last_of(sz.data(), nStart, n); }
  size_t find_last_of(const wxScopedWCharBuffer& sz, size_t nStart, size_t n) const
    { return find_last_of(sz.data(), nStart, n); }

  size_t find_first_not_of(const wxCStrData& sz, size_t nStart = 0) const
    { return find_first_not_of(sz.AsString(), nStart); }
  size_t find_first_not_of(const wxScopedCharBuffer& sz, size_t nStart = 0) const
    { return find_first_not_of(sz.data(), nStart); }
  size_t find_first_not_of(const wxScopedWCharBuffer& sz, size_t nStart = 0) const
    { return find_first_not_of(sz.data(), nStart); }
  size_t find_first_not_of(const wxCStrData& sz, size_t nStart, size_t n) const
    { return find_first_not_of(sz.AsWChar(), nStart, n); }
  size_t find_first_not_of(const wxScopedCharBuffer& sz, size_t nStart, size_t n) const
    { return find_first_not_of(sz.data(), nStart, n); }
  size_t find_first_not_of(const wxScopedWCharBuffer& sz, size_t nStart, size_t n) const
    { return find_first_not_of(sz.data(), nStart, n); }

  size_t find_last_not_of(const wxCStrData& sz, size_t nStart = 0) const
    { return find_last_not_of(sz.AsString(), nStart); }
  size_t find_last_not_of(const wxScopedCharBuffer& sz, size_t nStart = 0) const
    { return find_last_not_of(sz.data(), nStart); }
  size_t find_last_not_of(const wxScopedWCharBuffer& sz, size_t nStart = 0) const
    { return find_last_not_of(sz.data(), nStart); }
  size_t find_last_not_of(const wxCStrData& sz, size_t nStart, size_t n) const
    { return find_last_not_of(sz.AsWChar(), nStart, n); }
  size_t find_last_not_of(const wxScopedCharBuffer& sz, size_t nStart, size_t n) const
    { return find_last_not_of(sz.data(), nStart, n); }
  size_t find_last_not_of(const wxScopedWCharBuffer& sz, size_t nStart, size_t n) const
    { return find_last_not_of(sz.data(), nStart, n); }


  wxString& operator+=(const wxString& s)
  {
      ;

      m_impl += s.m_impl;
      return *this;
  }

  wxString& operator+=(const char *psz)
  {
      ;

      m_impl += ImplStr(psz);
      return *this;
  }
  wxString& operator+=(const wchar_t *pwz)
  {
      ;

      m_impl += ImplStr(pwz);
      return *this;
  }
  wxString& operator+=(const wxCStrData& s)
  {
      ;

      m_impl += s.AsString().m_impl;
      return *this;
  }
  wxString& operator+=(const wxScopedCharBuffer& s)
    { return append(s); }
  wxString& operator+=(const wxScopedWCharBuffer& s)
    { return append(s); }

  wxString& operator+=(wxUniChar ch)
  {
      ;






          m_impl += (wxStringCharType)ch;
      return *this;
  }
  wxString& operator+=(wxUniCharRef ch) { return *this += wxUniChar(ch); }
  wxString& operator+=(int ch) { return *this += wxUniChar(ch); }
  wxString& operator+=(char ch) { return *this += wxUniChar(ch); }
  wxString& operator+=(unsigned char ch) { return *this += wxUniChar(ch); }
  wxString& operator+=(wchar_t ch) { return *this += wxUniChar(ch); }

private:
# 3459 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  int DoPrintfWchar(const wxChar *format, ...);
  static wxString DoFormatWchar(const wxChar *format, ...);
# 3473 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
private:
  wxStringImpl m_impl;
# 3483 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  template<typename T>
  struct ConvertedBuffer
  {


      ConvertedBuffer() : m_str(
# 3488 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                               __null
# 3488 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                   ) {}
      ~ConvertedBuffer()
          { free(m_str); }

      bool Extend(size_t len)
      {

          void * const str = realloc(m_str, sizeof(T)*(len + 1));
          if ( !str )
              return false;

          m_str = static_cast<T *>(str);
          m_len = len;

          return true;
      }

      const wxScopedCharTypeBuffer<T> AsScopedBuffer() const
      {
          return wxScopedCharTypeBuffer<T>::CreateNonOwned(m_str, m_len);
      }

      T *m_str;
      size_t m_len;
  };
# 3526 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  const char *AsChar(const wxMBConv& conv) const;


  wxScopedCharBuffer AsCharBuf(const wxMBConv& conv) const
  {
# 3546 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
      if ( !AsChar(conv) )
      {
# 3556 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
          return wxScopedCharBuffer::CreateNonOwned("", 0);
      }

      return m_convertedToChar.AsScopedBuffer();
  }

  ConvertedBuffer<char> m_convertedToChar;
# 3606 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
  friend class wxCStrData;
  friend class wxStringInternalBuffer;
  friend class wxStringInternalBufferLength;
};







inline wxString::iterator operator+(ptrdiff_t n, wxString::iterator i)
  { return i + n; }
inline wxString::const_iterator operator+(ptrdiff_t n, wxString::const_iterator i)
  { return i + n; }
inline wxString::reverse_iterator operator+(ptrdiff_t n, wxString::reverse_iterator i)
  { return i + n; }
inline wxString::const_reverse_iterator operator+(ptrdiff_t n, wxString::const_reverse_iterator i)
  { return i + n; }





wxString operator+(const wxString& string1, const wxString& string2);
wxString operator+(const wxString& string, const char *psz);
wxString operator+(const wxString& string, const wchar_t *pwz);
wxString operator+(const char *psz, const wxString& string);
wxString operator+(const wchar_t *pwz, const wxString& string);

wxString operator+(const wxString& string, wxUniChar ch);
wxString operator+(wxUniChar ch, const wxString& string);

inline wxString operator+(const wxString& string, wxUniCharRef ch)
    { return string + (wxUniChar)ch; }
inline wxString operator+(const wxString& string, char ch)
    { return string + wxUniChar(ch); }
inline wxString operator+(const wxString& string, wchar_t ch)
    { return string + wxUniChar(ch); }
inline wxString operator+(wxUniCharRef ch, const wxString& string)
    { return (wxUniChar)ch + string; }
inline wxString operator+(char ch, const wxString& string)
    { return wxUniChar(ch) + string; }
inline wxString operator+(wchar_t ch, const wxString& string)
    { return wxUniChar(ch) + string; }
# 3659 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
namespace wxPrivate
{



template <>
struct wxStringAsBufHelper<char>
{
    static wxScopedCharBuffer Get(const wxString& s, size_t *len)
    {
        wxScopedCharBuffer buf(s.mb_str());
        if ( len )
            *len = buf ? strlen(buf) : 0;
        return buf;
    }
};

template <>
struct wxStringAsBufHelper<wchar_t>
{
    static wxScopedWCharBuffer Get(const wxString& s, size_t *len)
    {
        const size_t length = s.length();
        if ( len )
            *len = length;
        return wxScopedWCharBuffer::CreateNonOwned(s.wx_str(), length);
    }
};
# 3716 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
}
# 3777 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
template<typename T>
class wxStringTypeBufferBase
{
public:
    typedef T CharType;

    wxStringTypeBufferBase(wxString& str, size_t lenWanted = 1024)
        : m_str(str), m_buf(lenWanted)
    {






        size_t len;
        const wxCharTypeBuffer<CharType> buf(str.tchar_str(&len, (CharType *)
# 3793 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                                                            __null
# 3793 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                                                                ));
        if ( buf )
        {
            if ( len > lenWanted )
            {


                m_buf.data()[lenWanted] = 0;
                len = lenWanted - 1;
            }

            memcpy(m_buf.data(), buf, (len + 1)*sizeof(CharType));
        }


    }

    operator CharType*() { return m_buf.data(); }

protected:
    wxString& m_str;
    wxCharTypeBuffer<CharType> m_buf;
};

template<typename T>
class wxStringTypeBufferLengthBase : public wxStringTypeBufferBase<T>
{
public:
    wxStringTypeBufferLengthBase(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferBase<T>(str, lenWanted),
          m_len(0),
          m_lenSet(false)
        { }

    ~wxStringTypeBufferLengthBase()
    {
        do { if ( wxTheAssertHandler && !(this->m_lenSet) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 3829, __FUNCTION__, "this->m_lenSet", "forgot to call SetLength()"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
    }

    void SetLength(size_t length) { m_len = length; m_lenSet = true; }

protected:
    size_t m_len;
    bool m_lenSet;
};

template<typename T>
class wxStringTypeBuffer : public wxStringTypeBufferBase<T>
{
public:
    wxStringTypeBuffer(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferBase<T>(str, lenWanted)
        { }

    ~wxStringTypeBuffer()
    {
        this->m_str.assign(this->m_buf.data());
    }

    private: wxStringTypeBuffer(const wxStringTypeBuffer&); wxStringTypeBuffer& operator=(const wxStringTypeBuffer&);
};

template<typename T>
class wxStringTypeBufferLength : public wxStringTypeBufferLengthBase<T>
{
public:
    wxStringTypeBufferLength(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferLengthBase<T>(str, lenWanted)
        { }

    ~wxStringTypeBufferLength()
    {
        this->m_str.assign(this->m_buf.data(), this->m_len);
    }

    private: wxStringTypeBufferLength(const wxStringTypeBufferLength&); wxStringTypeBufferLength& operator=(const wxStringTypeBufferLength&);
};





class wxStringInternalBuffer : public wxStringTypeBufferBase<wxStringCharType>
{
public:
    wxStringInternalBuffer(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferBase<wxStringCharType>(str, lenWanted) {}
    ~wxStringInternalBuffer()
        { m_str.m_impl.assign(m_buf.data()); }

    private: wxStringInternalBuffer(const wxStringInternalBuffer&); wxStringInternalBuffer& operator=(const wxStringInternalBuffer&);
};




class wxStringInternalBufferLength
    : public wxStringTypeBufferLengthBase<wxStringCharType>
{
public:
    wxStringInternalBufferLength(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferLengthBase<wxStringCharType>(str, lenWanted) {}

    ~wxStringInternalBufferLength()
    {
        m_str.m_impl.assign(m_buf.data(), m_len);
    }

    private: wxStringInternalBufferLength(const wxStringInternalBufferLength&); wxStringInternalBufferLength& operator=(const wxStringInternalBufferLength&);
};





typedef wxStringTypeBuffer<wxChar> wxStringBuffer;
typedef wxStringTypeBufferLength<wxChar> wxStringBufferLength;
# 3920 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"

# 3936 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
class wxUTF8StringBuffer : public wxStringTypeBufferBase<char>
{
public:
    wxUTF8StringBuffer(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferBase<char>(str, lenWanted) {}
    ~wxUTF8StringBuffer()
    {
        wxMBConvStrictUTF8 conv;
        size_t wlen = conv.ToWChar(
# 3944 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                  __null
# 3944 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                      , 0, m_buf);
        if ( wlen != ((size_t)-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 3945, __FUNCTION__, "wlen != ((size_t)-1)", "invalid UTF-8 data in string buffer?"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

        wxStringInternalBuffer wbuf(m_str, wlen);
        conv.ToWChar(wbuf, wlen, m_buf);
    }

    private: wxUTF8StringBuffer(const wxUTF8StringBuffer&); wxUTF8StringBuffer& operator=(const wxUTF8StringBuffer&);
};



class wxUTF8StringBufferLength : public wxStringTypeBufferLengthBase<char>
{
public:
    wxUTF8StringBufferLength(wxString& str, size_t lenWanted = 1024)
        : wxStringTypeBufferLengthBase<char>(str, lenWanted) {}
    ~wxUTF8StringBufferLength()
    {
        if ( m_lenSet ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 3963, __FUNCTION__, "m_lenSet", "length not set"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

        wxMBConvStrictUTF8 conv;
        size_t wlen = conv.ToWChar(
# 3966 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 3 4
                                  __null
# 3966 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
                                      , 0, m_buf, m_len);
        if ( wlen != ((size_t)-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h", 3967, __FUNCTION__, "wlen != ((size_t)-1)", "invalid UTF-8 data in string buffer?"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

        wxStringInternalBufferLength wbuf(m_str, wlen);
        conv.ToWChar(wbuf, wlen, m_buf, m_len);
        wbuf.SetLength(wlen);
    }

    private: wxUTF8StringBufferLength(const wxUTF8StringBufferLength&); wxUTF8StringBufferLength& operator=(const wxUTF8StringBufferLength&);
};
# 3985 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
inline bool operator ==(const wxChar * x, const wxString& y) { return 0 == y.Cmp(x); } inline bool operator !=(const wxChar * x, const wxString& y) { return 0 != y.Cmp(x); } inline bool operator >=(const wxChar * x, const wxString& y) { return 0 >= y.Cmp(x); } inline bool operator <=(const wxChar * x, const wxString& y) { return 0 <= y.Cmp(x); } inline bool operator >(const wxChar * x, const wxString& y) { return 0 > y.Cmp(x); } inline bool operator <(const wxChar * x, const wxString& y) { return 0 < y.Cmp(x); } inline bool operator ==(const wxString& y, const wxChar * x) { return 0 == y.Cmp(x); } inline bool operator !=(const wxString& y, const wxChar * x) { return 0 != y.Cmp(x); } inline bool operator >=(const wxString& y, const wxChar * x) { return 0 <= y.Cmp(x); } inline bool operator <=(const wxString& y, const wxChar * x) { return 0 >= y.Cmp(x); } inline bool operator >(const wxString& y, const wxChar * x) { return 0 < y.Cmp(x); } inline bool operator <(const wxString& y, const wxChar * x) { return 0 > y.Cmp(x); }



inline bool operator==(const wxString& s1, const wxString& s2)
    { return s1.IsSameAs(s2); }
inline bool operator!=(const wxString& s1, const wxString& s2)
    { return !s1.IsSameAs(s2); }
inline bool operator< (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) < 0; }
inline bool operator> (const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) > 0; }
inline bool operator<=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) <= 0; }
inline bool operator>=(const wxString& s1, const wxString& s2)
    { return s1.Cmp(s2) >= 0; }

inline bool operator==(const wxString& s1, const wxCStrData& s2)
    { return s1 == s2.AsString(); }
inline bool operator==(const wxCStrData& s1, const wxString& s2)
    { return s1.AsString() == s2; }
inline bool operator!=(const wxString& s1, const wxCStrData& s2)
    { return s1 != s2.AsString(); }
inline bool operator!=(const wxCStrData& s1, const wxString& s2)
    { return s1.AsString() != s2; }

inline bool operator==(const wxString& s1, const wxScopedWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) == 0); }
inline bool operator==(const wxScopedWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) == 0); }
inline bool operator!=(const wxString& s1, const wxScopedWCharBuffer& s2)
    { return (s1.Cmp((const wchar_t *)s2) != 0); }
inline bool operator!=(const wxScopedWCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const wchar_t *)s1) != 0); }

inline bool operator==(const wxString& s1, const wxScopedCharBuffer& s2)
    { return (s1.Cmp((const char *)s2) == 0); }
inline bool operator==(const wxScopedCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const char *)s1) == 0); }
inline bool operator!=(const wxString& s1, const wxScopedCharBuffer& s2)
    { return (s1.Cmp((const char *)s2) != 0); }
inline bool operator!=(const wxScopedCharBuffer& s1, const wxString& s2)
    { return (s2.Cmp((const char *)s1) != 0); }

inline wxString operator+(const wxString& string, const wxScopedWCharBuffer& buf)
    { return string + (const wchar_t *)buf; }
inline wxString operator+(const wxScopedWCharBuffer& buf, const wxString& string)
    { return (const wchar_t *)buf + string; }

inline wxString operator+(const wxString& string, const wxScopedCharBuffer& buf)
    { return string + (const char *)buf; }
inline wxString operator+(const wxScopedCharBuffer& buf, const wxString& string)
    { return (const char *)buf + string; }


inline bool operator==(const wxUniChar& c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(const wxUniCharRef& c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(char c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(wchar_t c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(int c, const wxString& s) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, const wxUniChar& c) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, const wxUniCharRef& c) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, char c) { return s.IsSameAs(c); }
inline bool operator==(const wxString& s, wchar_t c) { return s.IsSameAs(c); }
inline bool operator!=(const wxUniChar& c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(const wxUniCharRef& c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(char c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(wchar_t c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(int c, const wxString& s) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, const wxUniChar& c) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, const wxUniCharRef& c) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, char c) { return !s.IsSameAs(c); }
inline bool operator!=(const wxString& s, wchar_t c) { return !s.IsSameAs(c); }



inline bool wxString::iterator::operator==(const const_iterator& i) const
    { return i == *this; }
inline bool wxString::iterator::operator!=(const const_iterator& i) const
    { return i != *this; }
inline bool wxString::iterator::operator<(const const_iterator& i) const
    { return i > *this; }
inline bool wxString::iterator::operator>(const const_iterator& i) const
    { return i < *this; }
inline bool wxString::iterator::operator<=(const const_iterator& i) const
    { return i >= *this; }
inline bool wxString::iterator::operator>=(const const_iterator& i) const
    { return i <= *this; }






inline bool operator ==(const char * x, const wxString& y) { return wxString(x) == y; } inline bool operator !=(const char * x, const wxString& y) { return wxString(x) != y; } inline bool operator >=(const char * x, const wxString& y) { return wxString(x) >= y; } inline bool operator <=(const char * x, const wxString& y) { return wxString(x) <= y; } inline bool operator >(const char * x, const wxString& y) { return wxString(x) > y; } inline bool operator <(const char * x, const wxString& y) { return wxString(x) < y; } inline bool operator ==(const wxString& y, const char * x) { return wxString(x) == y; } inline bool operator !=(const wxString& y, const char * x) { return wxString(x) != y; } inline bool operator >=(const wxString& y, const char * x) { return wxString(x) <= y; } inline bool operator <=(const wxString& y, const char * x) { return wxString(x) >= y; } inline bool operator >(const wxString& y, const char * x) { return wxString(x) < y; } inline bool operator <(const wxString& y, const char * x) { return wxString(x) > y; }
# 4093 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
inline bool operator ==(const wchar_t * x, const wxCStrData& y) { return x == y.AsWChar(); } inline bool operator !=(const wchar_t * x, const wxCStrData& y) { return x != y.AsWChar(); } inline bool operator >=(const wchar_t * x, const wxCStrData& y) { return x >= y.AsWChar(); } inline bool operator <=(const wchar_t * x, const wxCStrData& y) { return x <= y.AsWChar(); } inline bool operator >(const wchar_t * x, const wxCStrData& y) { return x > y.AsWChar(); } inline bool operator <(const wchar_t * x, const wxCStrData& y) { return x < y.AsWChar(); } inline bool operator ==(const wxCStrData& y, const wchar_t * x) { return x == y.AsWChar(); } inline bool operator !=(const wxCStrData& y, const wchar_t * x) { return x != y.AsWChar(); } inline bool operator >=(const wxCStrData& y, const wchar_t * x) { return x <= y.AsWChar(); } inline bool operator <=(const wxCStrData& y, const wchar_t * x) { return x >= y.AsWChar(); } inline bool operator >(const wxCStrData& y, const wchar_t * x) { return x < y.AsWChar(); } inline bool operator <(const wxCStrData& y, const wchar_t * x) { return x > y.AsWChar(); }
inline bool operator ==(const char * x, const wxCStrData& y) { return x == y.AsChar(); } inline bool operator !=(const char * x, const wxCStrData& y) { return x != y.AsChar(); } inline bool operator >=(const char * x, const wxCStrData& y) { return x >= y.AsChar(); } inline bool operator <=(const char * x, const wxCStrData& y) { return x <= y.AsChar(); } inline bool operator >(const char * x, const wxCStrData& y) { return x > y.AsChar(); } inline bool operator <(const char * x, const wxCStrData& y) { return x < y.AsChar(); } inline bool operator ==(const wxCStrData& y, const char * x) { return x == y.AsChar(); } inline bool operator !=(const wxCStrData& y, const char * x) { return x != y.AsChar(); } inline bool operator >=(const wxCStrData& y, const char * x) { return x <= y.AsChar(); } inline bool operator <=(const wxCStrData& y, const char * x) { return x >= y.AsChar(); } inline bool operator >(const wxCStrData& y, const char * x) { return x < y.AsChar(); } inline bool operator <(const wxCStrData& y, const char * x) { return x > y.AsChar(); }
# 4105 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 1
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 2
# 4106 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2

 std:: ostream& operator<<(std:: ostream&, const wxString&);
 std:: ostream& operator<<(std:: ostream&, const wxCStrData&);
 std:: ostream& operator<<(std:: ostream&, const wxScopedCharBuffer&);

 std:: ostream& operator<<(std:: ostream&, const wxScopedWCharBuffer&);




 std:: wostream& operator<<(std:: wostream&, const wxString&);
 std:: wostream& operator<<(std:: wostream&, const wxCStrData&);
 std:: wostream& operator<<(std:: wostream&, const wxScopedWCharBuffer&);
# 4128 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
inline wxCStrData::wxCStrData(char *buf)
    : m_str(new wxString(buf)), m_offset(0), m_owned(true) {}
inline wxCStrData::wxCStrData(wchar_t *buf)
    : m_str(new wxString(buf)), m_offset(0), m_owned(true) {}

inline wxCStrData::wxCStrData(const wxCStrData& data)
    : m_str(data.m_owned ? new wxString(*data.m_str) : data.m_str),
      m_offset(data.m_offset),
      m_owned(data.m_owned)
{
}

inline wxCStrData::~wxCStrData()
{
    if ( m_owned )
        delete const_cast<wxString*>(m_str);
}



inline const wchar_t* wxCStrData::AsWChar() const
{
    const wchar_t * const p =

        m_str->wc_str();
# 4179 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
    return p + m_offset;
}

inline const char* wxCStrData::AsChar() const
{

    const char * const p = m_str->AsChar(wxGet_wxConvLibc());
    if ( !p )
        return "";




    return p + m_offset;
}

inline wxString wxCStrData::AsString() const
{
    if ( m_offset == 0 )
        return *m_str;
    else
        return m_str->Mid(m_offset);
}

inline const wxStringCharType *wxCStrData::AsInternal() const
{



    return m_str->wx_str() + m_offset;

}

inline wxUniChar wxCStrData::operator*() const
{
    if ( m_str->empty() )
        return wxUniChar(L'\0');
    else
        return (*m_str)[m_offset];
}

inline wxUniChar wxCStrData::operator[](size_t n) const
{


    return (*m_str)[m_offset + n];
}







inline size_t operator-(const char *p, const wxCStrData& cs)
{
    return p - cs.AsChar();
}

inline size_t operator-(const wchar_t *p, const wxCStrData& cs)
{
    return p - cs.AsWChar();
}






inline wxCharBuffer::wxCharBuffer(const wxCStrData& cstr)
                    : wxCharTypeBufferBase(cstr.AsCharBuf())
{
}

inline wxWCharBuffer::wxWCharBuffer(const wxCStrData& cstr)
                    : wxCharTypeBufferBase(cstr.AsWCharBuf())
{
}
# 4305 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/crt.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/crt.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 2
# 30 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline bool wxIsEmpty(const char *s) { return !s || !*s; }
inline bool wxIsEmpty(const wchar_t *s) { return !s || !*s; }
inline bool wxIsEmpty(const wxScopedCharBuffer& s) { return wxIsEmpty(s.data()); }
inline bool wxIsEmpty(const wxScopedWCharBuffer& s) { return wxIsEmpty(s.data()); }
inline bool wxIsEmpty(const wxString& s) { return s.empty(); }
inline bool wxIsEmpty(const wxCStrData& s) { return s.AsString().empty(); }






 size_t wxMB2WC(wchar_t *buf, const char *psz, size_t n);
 size_t wxWC2MB(char *buf, const wchar_t *psz, size_t n);
# 69 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
    inline wxChar* wxTmemchr(const wxChar* s, wxChar c, size_t l)
    {
        for(;l && *s != c;--l, ++s) {}

        if(l)
            return const_cast<wxChar*>(s);
        return 
# 75 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
              __null
# 75 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                  ;
    }

    inline int wxTmemcmp(const wxChar* sz1, const wxChar* sz2, size_t len)
    {
        for(; *sz1 == *sz2 && len; --len, ++sz1, ++sz2) {}

        if(len)
            return *sz1 < *sz2 ? -1 : *sz1 > *sz2;
        else
            return 0;
    }

    inline wxChar* wxTmemcpy(wxChar* szOut, const wxChar* szIn, size_t len)
    {
        return (wxChar*) memcpy(szOut, szIn, len * sizeof(wxChar));
    }

    inline wxChar* wxTmemmove(wxChar* szOut, const wxChar* szIn, size_t len)
    {
        return (wxChar*) memmove(szOut, szIn, len * sizeof(wxChar));
    }

    inline wxChar* wxTmemset(wxChar* szOut, const wxChar cIn, size_t len)
    {
        wxChar* szRet = szOut;

        while (len--)
            *szOut++ = cIn;

        return szRet;
    }





inline char* wxTmemchr(const char* s, char c, size_t len)
    { return (char*)memchr(s, c, len); }
inline int wxTmemcmp(const char* sz1, const char* sz2, size_t len)
    { return memcmp(sz1, sz2, len); }
inline char* wxTmemcpy(char* szOut, const char* szIn, size_t len)
    { return (char*)memcpy(szOut, szIn, len); }
inline char* wxTmemmove(char* szOut, const char* szIn, size_t len)
    { return (char*)memmove(szOut, szIn, len); }
inline char* wxTmemset(char* szOut, const char cIn, size_t len)
    { return (char*)memset(szOut, cIn, len); }
# 149 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
 char* wxSetlocale(int category, const char *locale);
inline char* wxSetlocale(int category, const wxScopedCharBuffer& locale)
    { return wxSetlocale(category, locale.data()); }
inline char* wxSetlocale(int category, const wxString& locale)
    { return wxSetlocale(category, locale.mb_str()); }
inline char* wxSetlocale(int category, const wxCStrData& locale)
    { return wxSetlocale(category, locale.AsCharBuf()); }
# 165 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline size_t wxStrlen(const wxScopedCharBuffer& s) { return wxStrlen(s.data()); }
inline size_t wxStrlen(const wxScopedWCharBuffer& s) { return wxStrlen(s.data()); }
inline size_t wxStrlen(const wxString& s) { return s.length(); }
inline size_t wxStrlen(const wxCStrData& s) { return s.AsString().length(); }






inline size_t wxStrnlen(const char *str, size_t maxlen)
{
    size_t n;
    for ( n = 0; n < maxlen; n++ )
        if ( !str[n] )
            break;

    return n;
}





inline size_t wxStrnlen(const wchar_t *str, size_t maxlen)
{
    size_t n;
    for ( n = 0; n < maxlen; n++ )
        if ( !str[n] )
            break;

    return n;
}





inline char* wxStrdup(const wxScopedCharBuffer& s) { return wxStrdup(s.data()); }
inline wchar_t* wxStrdup(const wxScopedWCharBuffer& s) { return wxStrdup(s.data()); }
inline char* wxStrdup(const wxString& s) { return wxStrdup(s.mb_str()); }
inline char* wxStrdup(const wxCStrData& s) { return wxStrdup(s.AsCharBuf()); }

inline char *wxStrcpy(char *dest, const char *src)
    { return strcpy(dest, src); }
inline wchar_t *wxStrcpy(wchar_t *dest, const wchar_t *src)
    { return wcscpy(dest, src); }
inline char *wxStrcpy(char *dest, const wxString& src)
    { return strcpy(dest, src.mb_str()); }
inline char *wxStrcpy(char *dest, const wxCStrData& src)
    { return strcpy(dest, src.AsCharBuf()); }
inline char *wxStrcpy(char *dest, const wxScopedCharBuffer& src)
    { return strcpy(dest, src.data()); }
inline wchar_t *wxStrcpy(wchar_t *dest, const wxString& src)
    { return wcscpy(dest, src.wc_str()); }
inline wchar_t *wxStrcpy(wchar_t *dest, const wxCStrData& src)
    { return wcscpy(dest, src.AsWCharBuf()); }
inline wchar_t *wxStrcpy(wchar_t *dest, const wxScopedWCharBuffer& src)
    { return wcscpy(dest, src.data()); }
inline char *wxStrcpy(char *dest, const wchar_t *src)
    { return strcpy(dest, wxGet_wxConvLibc().cWC2MB(src)); }
inline wchar_t *wxStrcpy(wchar_t *dest, const char *src)
    { return wcscpy(dest, wxGet_wxConvLibc().cMB2WC(src)); }

inline char *wxStrncpy(char *dest, const char *src, size_t n)
    { return strncpy(dest, src, n); }
inline wchar_t *wxStrncpy(wchar_t *dest, const wchar_t *src, size_t n)
    { return wcsncpy(dest, src, n); }
inline char *wxStrncpy(char *dest, const wxString& src, size_t n)
    { return strncpy(dest, src.mb_str(), n); }
inline char *wxStrncpy(char *dest, const wxCStrData& src, size_t n)
    { return strncpy(dest, src.AsCharBuf(), n); }
inline char *wxStrncpy(char *dest, const wxScopedCharBuffer& src, size_t n)
    { return strncpy(dest, src.data(), n); }
inline wchar_t *wxStrncpy(wchar_t *dest, const wxString& src, size_t n)
    { return wcsncpy(dest, src.wc_str(), n); }
inline wchar_t *wxStrncpy(wchar_t *dest, const wxCStrData& src, size_t n)
    { return wcsncpy(dest, src.AsWCharBuf(), n); }
inline wchar_t *wxStrncpy(wchar_t *dest, const wxScopedWCharBuffer& src, size_t n)
    { return wcsncpy(dest, src.data(), n); }
inline char *wxStrncpy(char *dest, const wchar_t *src, size_t n)
    { return strncpy(dest, wxGet_wxConvLibc().cWC2MB(src), n); }
inline wchar_t *wxStrncpy(wchar_t *dest, const char *src, size_t n)
    { return wcsncpy(dest, wxGet_wxConvLibc().cMB2WC(src), n); }



inline size_t wxStrlcpy(char *dest, const char *src, size_t n)
{
    const size_t len = strlen(src);

    if ( n )
    {
        if ( n-- > len )
            n = len;
        strncpy(dest, src, n);
        dest[n] = '\0';
    }

    return len;
}
inline size_t wxStrlcpy(wchar_t *dest, const wchar_t *src, size_t n)
{
    const size_t len = wcslen(src);
    if ( n )
    {
        if ( n-- > len )
            n = len;
        wcsncpy(dest, src, n);
        dest[n] = L'\0';
    }

    return len;
}

inline char *wxStrcat(char *dest, const char *src)
    { return strcat(dest, src); }
inline wchar_t *wxStrcat(wchar_t *dest, const wchar_t *src)
    { return wcscat(dest, src); }
inline char *wxStrcat(char *dest, const wxString& src)
    { return strcat(dest, src.mb_str()); }
inline char *wxStrcat(char *dest, const wxCStrData& src)
    { return strcat(dest, src.AsCharBuf()); }
inline char *wxStrcat(char *dest, const wxScopedCharBuffer& src)
    { return strcat(dest, src.data()); }
inline wchar_t *wxStrcat(wchar_t *dest, const wxString& src)
    { return wcscat(dest, src.wc_str()); }
inline wchar_t *wxStrcat(wchar_t *dest, const wxCStrData& src)
    { return wcscat(dest, src.AsWCharBuf()); }
inline wchar_t *wxStrcat(wchar_t *dest, const wxScopedWCharBuffer& src)
    { return wcscat(dest, src.data()); }
inline char *wxStrcat(char *dest, const wchar_t *src)
    { return strcat(dest, wxGet_wxConvLibc().cWC2MB(src)); }
inline wchar_t *wxStrcat(wchar_t *dest, const char *src)
    { return wcscat(dest, wxGet_wxConvLibc().cMB2WC(src)); }

inline char *wxStrncat(char *dest, const char *src, size_t n)
    { return strncat(dest, src, n); }
inline wchar_t *wxStrncat(wchar_t *dest, const wchar_t *src, size_t n)
    { return wcsncat(dest, src, n); }
inline char *wxStrncat(char *dest, const wxString& src, size_t n)
    { return strncat(dest, src.mb_str(), n); }
inline char *wxStrncat(char *dest, const wxCStrData& src, size_t n)
    { return strncat(dest, src.AsCharBuf(), n); }
inline char *wxStrncat(char *dest, const wxScopedCharBuffer& src, size_t n)
    { return strncat(dest, src.data(), n); }
inline wchar_t *wxStrncat(wchar_t *dest, const wxString& src, size_t n)
    { return wcsncat(dest, src.wc_str(), n); }
inline wchar_t *wxStrncat(wchar_t *dest, const wxCStrData& src, size_t n)
    { return wcsncat(dest, src.AsWCharBuf(), n); }
inline wchar_t *wxStrncat(wchar_t *dest, const wxScopedWCharBuffer& src, size_t n)
    { return wcsncat(dest, src.data(), n); }
inline char *wxStrncat(char *dest, const wchar_t *src, size_t n)
    { return strncat(dest, wxGet_wxConvLibc().cWC2MB(src), n); }
inline wchar_t *wxStrncat(wchar_t *dest, const char *src, size_t n)
    { return wcsncat(dest, wxGet_wxConvLibc().cMB2WC(src), n); }
# 451 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
template<typename T>
inline int wxStrcmp_String(const wxString& s1, const T& s2)
    { return s1.compare(s2); }
inline int wxStrcmp(const char * s1, const char * s2) { return strcmp(s1, s2); } inline int wxStrcmp(const char * s1, const wchar_t * s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const char * s1, const wxScopedCharBuffer& s2) { return strcmp(s1, s2.data()); } inline int wxStrcmp(const char * s1, const wxScopedWCharBuffer& s2) { return wxStrcmp_String(wxString(s1), s2.data()); } inline int wxStrcmp(const wchar_t * s1, const wchar_t * s2) { return wcscmp(s1, s2); } inline int wxStrcmp(const wchar_t * s1, const char * s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const wchar_t * s1, const wxScopedWCharBuffer& s2) { return wcscmp(s1, s2.data()); } inline int wxStrcmp(const wchar_t * s1, const wxScopedCharBuffer& s2) { return wxStrcmp_String(wxString(s1), s2.data()); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const char * s2) { return strcmp(s1.data(), s2); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const wchar_t * s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2) { return strcmp(s1.data(), s2.data()); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const wchar_t * s2) { return wcscmp(s1.data(), s2); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const char * s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wcscmp(s1.data(), s2.data()); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxStrcmp_String(wxString(s1), wxString(s2)); } inline int wxStrcmp(const wxString& s1, const char* s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxString& s1, const wchar_t* s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxString& s1, const wxScopedCharBuffer& s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxString& s1, const wxScopedWCharBuffer& s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxString& s1, const wxString& s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxString& s1, const wxCStrData& s2) { return wxStrcmp_String(s1, s2); } inline int wxStrcmp(const wxCStrData& s1, const char* s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const wxCStrData& s1, const wchar_t* s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const wxCStrData& s1, const wxScopedCharBuffer& s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const wxCStrData& s1, const wxScopedWCharBuffer& s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const wxCStrData& s1, const wxString& s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const wxCStrData& s1, const wxCStrData& s2) { return wxStrcmp_String(s1.AsString(), s2); } inline int wxStrcmp(const char * s1, const wxCStrData& s2) { return -wxStrcmp_String(s2.AsString(), s1); } inline int wxStrcmp(const char * s1, const wxString& s2) { return -wxStrcmp_String(s2, s1); } inline int wxStrcmp(const wchar_t * s1, const wxCStrData& s2) { return -wxStrcmp_String(s2.AsString(), s1); } inline int wxStrcmp(const wchar_t * s1, const wxString& s2) { return -wxStrcmp_String(s2, s1); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const wxCStrData& s2) { return -wxStrcmp_String(s2.AsString(), s1.data()); } inline int wxStrcmp(const wxScopedCharBuffer& s1, const wxString& s2) { return -wxStrcmp_String(s2, s1.data()); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const wxCStrData& s2) { return -wxStrcmp_String(s2.AsString(), s1.data()); } inline int wxStrcmp(const wxScopedWCharBuffer& s1, const wxString& s2) { return -wxStrcmp_String(s2, s1.data()); }

template<typename T>
inline int wxStricmp_String(const wxString& s1, const T& s2)
    { return s1.CmpNoCase(s2); }
inline int wxStricmp(const char * s1, const char * s2) { return wxCRT_StricmpA(s1, s2); } inline int wxStricmp(const char * s1, const wchar_t * s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const char * s1, const wxScopedCharBuffer& s2) { return wxCRT_StricmpA(s1, s2.data()); } inline int wxStricmp(const char * s1, const wxScopedWCharBuffer& s2) { return wxStricmp_String(wxString(s1), s2.data()); } inline int wxStricmp(const wchar_t * s1, const wchar_t * s2) { return wxCRT_StricmpW(s1, s2); } inline int wxStricmp(const wchar_t * s1, const char * s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const wchar_t * s1, const wxScopedWCharBuffer& s2) { return wxCRT_StricmpW(s1, s2.data()); } inline int wxStricmp(const wchar_t * s1, const wxScopedCharBuffer& s2) { return wxStricmp_String(wxString(s1), s2.data()); } inline int wxStricmp(const wxScopedCharBuffer& s1, const char * s2) { return wxCRT_StricmpA(s1.data(), s2); } inline int wxStricmp(const wxScopedCharBuffer& s1, const wchar_t * s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxCRT_StricmpA(s1.data(), s2.data()); } inline int wxStricmp(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const wchar_t * s2) { return wxCRT_StricmpW(s1.data(), s2); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const char * s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxCRT_StricmpW(s1.data(), s2.data()); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxStricmp_String(wxString(s1), wxString(s2)); } inline int wxStricmp(const wxString& s1, const char* s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxString& s1, const wchar_t* s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxString& s1, const wxScopedCharBuffer& s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxString& s1, const wxScopedWCharBuffer& s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxString& s1, const wxString& s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxString& s1, const wxCStrData& s2) { return wxStricmp_String(s1, s2); } inline int wxStricmp(const wxCStrData& s1, const char* s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const wxCStrData& s1, const wchar_t* s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const wxCStrData& s1, const wxScopedCharBuffer& s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const wxCStrData& s1, const wxScopedWCharBuffer& s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const wxCStrData& s1, const wxString& s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const wxCStrData& s1, const wxCStrData& s2) { return wxStricmp_String(s1.AsString(), s2); } inline int wxStricmp(const char * s1, const wxCStrData& s2) { return -wxStricmp_String(s2.AsString(), s1); } inline int wxStricmp(const char * s1, const wxString& s2) { return -wxStricmp_String(s2, s1); } inline int wxStricmp(const wchar_t * s1, const wxCStrData& s2) { return -wxStricmp_String(s2.AsString(), s1); } inline int wxStricmp(const wchar_t * s1, const wxString& s2) { return -wxStricmp_String(s2, s1); } inline int wxStricmp(const wxScopedCharBuffer& s1, const wxCStrData& s2) { return -wxStricmp_String(s2.AsString(), s1.data()); } inline int wxStricmp(const wxScopedCharBuffer& s1, const wxString& s2) { return -wxStricmp_String(s2, s1.data()); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const wxCStrData& s2) { return -wxStricmp_String(s2.AsString(), s1.data()); } inline int wxStricmp(const wxScopedWCharBuffer& s1, const wxString& s2) { return -wxStricmp_String(s2, s1.data()); }
# 474 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
template<typename T>
inline int wxStrcoll_String(const wxString& s1, const T& s2);
inline int wxStrcoll(const char * s1, const char * s2) { return strcoll(s1, s2); } inline int wxStrcoll(const char * s1, const wchar_t * s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const char * s1, const wxScopedCharBuffer& s2) { return strcoll(s1, s2.data()); } inline int wxStrcoll(const char * s1, const wxScopedWCharBuffer& s2) { return wxStrcoll_String(wxString(s1), s2.data()); } inline int wxStrcoll(const wchar_t * s1, const wchar_t * s2) { return wcscoll(s1, s2); } inline int wxStrcoll(const wchar_t * s1, const char * s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const wchar_t * s1, const wxScopedWCharBuffer& s2) { return wcscoll(s1, s2.data()); } inline int wxStrcoll(const wchar_t * s1, const wxScopedCharBuffer& s2) { return wxStrcoll_String(wxString(s1), s2.data()); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const char * s2) { return strcoll(s1.data(), s2); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const wchar_t * s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2) { return strcoll(s1.data(), s2.data()); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const wchar_t * s2) { return wcscoll(s1.data(), s2); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const char * s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wcscoll(s1.data(), s2.data()); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxStrcoll_String(wxString(s1), wxString(s2)); } inline int wxStrcoll(const wxString& s1, const char* s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxString& s1, const wchar_t* s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxString& s1, const wxScopedCharBuffer& s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxString& s1, const wxScopedWCharBuffer& s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxString& s1, const wxString& s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxString& s1, const wxCStrData& s2) { return wxStrcoll_String(s1, s2); } inline int wxStrcoll(const wxCStrData& s1, const char* s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const wxCStrData& s1, const wchar_t* s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const wxCStrData& s1, const wxScopedCharBuffer& s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const wxCStrData& s1, const wxScopedWCharBuffer& s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const wxCStrData& s1, const wxString& s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const wxCStrData& s1, const wxCStrData& s2) { return wxStrcoll_String(s1.AsString(), s2); } inline int wxStrcoll(const char * s1, const wxCStrData& s2) { return -wxStrcoll_String(s2.AsString(), s1); } inline int wxStrcoll(const char * s1, const wxString& s2) { return -wxStrcoll_String(s2, s1); } inline int wxStrcoll(const wchar_t * s1, const wxCStrData& s2) { return -wxStrcoll_String(s2.AsString(), s1); } inline int wxStrcoll(const wchar_t * s1, const wxString& s2) { return -wxStrcoll_String(s2, s1); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const wxCStrData& s2) { return -wxStrcoll_String(s2.AsString(), s1.data()); } inline int wxStrcoll(const wxScopedCharBuffer& s1, const wxString& s2) { return -wxStrcoll_String(s2, s1.data()); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const wxCStrData& s2) { return -wxStrcoll_String(s2.AsString(), s1.data()); } inline int wxStrcoll(const wxScopedWCharBuffer& s1, const wxString& s2) { return -wxStrcoll_String(s2, s1.data()); }


template<typename T>
inline int wxStrcoll_String(const wxString& s1, const T& s2)
{





    return wxStrcoll((const wchar_t*)s1.wc_str(), s2);



}
# 501 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
template<typename T>
inline size_t wxStrspn_String(const wxString& s1, const T& s2)
{
    size_t pos = s1.find_first_not_of(s2);
    return pos == wxString::npos ? s1.length() : pos;
}
inline size_t wxStrspn(const char * s1, const char * s2) { return strspn(s1, s2); } inline size_t wxStrspn(const char * s1, const wchar_t * s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const char * s1, const wxScopedCharBuffer& s2) { return strspn(s1, s2.data()); } inline size_t wxStrspn(const char * s1, const wxScopedWCharBuffer& s2) { return wxStrspn_String(wxString(s1), s2.data()); } inline size_t wxStrspn(const wchar_t * s1, const wchar_t * s2) { return wcsspn(s1, s2); } inline size_t wxStrspn(const wchar_t * s1, const char * s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const wchar_t * s1, const wxScopedWCharBuffer& s2) { return wcsspn(s1, s2.data()); } inline size_t wxStrspn(const wchar_t * s1, const wxScopedCharBuffer& s2) { return wxStrspn_String(wxString(s1), s2.data()); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const char * s2) { return strspn(s1.data(), s2); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const wchar_t * s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2) { return strspn(s1.data(), s2.data()); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const wchar_t * s2) { return wcsspn(s1.data(), s2); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const char * s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wcsspn(s1.data(), s2.data()); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxStrspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrspn(const wxString& s1, const char* s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxString& s1, const wchar_t* s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxString& s1, const wxScopedCharBuffer& s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxString& s1, const wxScopedWCharBuffer& s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxString& s1, const wxString& s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxString& s1, const wxCStrData& s2) { return wxStrspn_String(s1, s2); } inline size_t wxStrspn(const wxCStrData& s1, const char* s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const wxCStrData& s1, const wchar_t* s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const wxCStrData& s1, const wxScopedCharBuffer& s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const wxCStrData& s1, const wxScopedWCharBuffer& s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const wxCStrData& s1, const wxString& s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const wxCStrData& s1, const wxCStrData& s2) { return wxStrspn_String(s1.AsString(), s2); } inline size_t wxStrspn(const char * s1, const wxCStrData& s2) { return strspn(s1, s2.AsCharBuf()); } inline size_t wxStrspn(const char * s1, const wxString& s2) { return strspn(s1, s2.mb_str()); } inline size_t wxStrspn(const wchar_t * s1, const wxCStrData& s2) { return wcsspn(s1, s2.AsWCharBuf()); } inline size_t wxStrspn(const wchar_t * s1, const wxString& s2) { return wcsspn(s1, s2.wc_str()); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const wxCStrData& s2) { return strspn(s1.data(), s2.AsCharBuf()); } inline size_t wxStrspn(const wxScopedCharBuffer& s1, const wxString& s2) { return strspn(s1.data(), s2.mb_str()); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const wxCStrData& s2) { return wcsspn(s1.data(), s2.AsWCharBuf()); } inline size_t wxStrspn(const wxScopedWCharBuffer& s1, const wxString& s2) { return wcsspn(s1.data(), s2.wc_str()); }

template<typename T>
inline size_t wxStrcspn_String(const wxString& s1, const T& s2)
{
    size_t pos = s1.find_first_of(s2);
    return pos == wxString::npos ? s1.length() : pos;
}
inline size_t wxStrcspn(const char * s1, const char * s2) { return strcspn(s1, s2); } inline size_t wxStrcspn(const char * s1, const wchar_t * s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const char * s1, const wxScopedCharBuffer& s2) { return strcspn(s1, s2.data()); } inline size_t wxStrcspn(const char * s1, const wxScopedWCharBuffer& s2) { return wxStrcspn_String(wxString(s1), s2.data()); } inline size_t wxStrcspn(const wchar_t * s1, const wchar_t * s2) { return wcscspn(s1, s2); } inline size_t wxStrcspn(const wchar_t * s1, const char * s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const wchar_t * s1, const wxScopedWCharBuffer& s2) { return wcscspn(s1, s2.data()); } inline size_t wxStrcspn(const wchar_t * s1, const wxScopedCharBuffer& s2) { return wxStrcspn_String(wxString(s1), s2.data()); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const char * s2) { return strcspn(s1.data(), s2); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const wchar_t * s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2) { return strcspn(s1.data(), s2.data()); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const wchar_t * s2) { return wcscspn(s1.data(), s2); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const char * s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2) { return wcscspn(s1.data(), s2.data()); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2) { return wxStrcspn_String(wxString(s1), wxString(s2)); } inline size_t wxStrcspn(const wxString& s1, const char* s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxString& s1, const wchar_t* s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxString& s1, const wxScopedCharBuffer& s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxString& s1, const wxScopedWCharBuffer& s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxString& s1, const wxString& s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxString& s1, const wxCStrData& s2) { return wxStrcspn_String(s1, s2); } inline size_t wxStrcspn(const wxCStrData& s1, const char* s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const wxCStrData& s1, const wchar_t* s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const wxCStrData& s1, const wxScopedCharBuffer& s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const wxCStrData& s1, const wxScopedWCharBuffer& s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const wxCStrData& s1, const wxString& s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const wxCStrData& s1, const wxCStrData& s2) { return wxStrcspn_String(s1.AsString(), s2); } inline size_t wxStrcspn(const char * s1, const wxCStrData& s2) { return strcspn(s1, s2.AsCharBuf()); } inline size_t wxStrcspn(const char * s1, const wxString& s2) { return strcspn(s1, s2.mb_str()); } inline size_t wxStrcspn(const wchar_t * s1, const wxCStrData& s2) { return wcscspn(s1, s2.AsWCharBuf()); } inline size_t wxStrcspn(const wchar_t * s1, const wxString& s2) { return wcscspn(s1, s2.wc_str()); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const wxCStrData& s2) { return strcspn(s1.data(), s2.AsCharBuf()); } inline size_t wxStrcspn(const wxScopedCharBuffer& s1, const wxString& s2) { return strcspn(s1.data(), s2.mb_str()); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const wxCStrData& s2) { return wcscspn(s1.data(), s2.AsWCharBuf()); } inline size_t wxStrcspn(const wxScopedWCharBuffer& s1, const wxString& s2) { return wcscspn(s1.data(), s2.wc_str()); }






template<typename T>
inline int wxStrncmp_String(const wxString& s1, const T& s2, size_t n)
    { return s1.compare(0, n, s2, 0, n); }
inline int wxStrncmp(const char * s1, const char * s2, size_t n) { return strncmp(s1, s2, n); } inline int wxStrncmp(const char * s1, const wchar_t * s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const char * s1, const wxScopedCharBuffer& s2, size_t n) { return strncmp(s1, s2.data(), n); } inline int wxStrncmp(const char * s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrncmp_String(wxString(s1), s2.data(), n); } inline int wxStrncmp(const wchar_t * s1, const wchar_t * s2, size_t n) { return wcsncmp(s1, s2, n); } inline int wxStrncmp(const wchar_t * s1, const char * s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const wchar_t * s1, const wxScopedWCharBuffer& s2, size_t n) { return wcsncmp(s1, s2.data(), n); } inline int wxStrncmp(const wchar_t * s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrncmp_String(wxString(s1), s2.data(), n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const char * s2, size_t n) { return strncmp(s1.data(), s2, n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const wchar_t * s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2, size_t n) { return strncmp(s1.data(), s2.data(), n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const wchar_t * s2, size_t n) { return wcsncmp(s1.data(), s2, n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const char * s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2, size_t n) { return wcsncmp(s1.data(), s2.data(), n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrncmp_String(wxString(s1), wxString(s2), n); } inline int wxStrncmp(const wxString& s1, const char* s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxString& s1, const wchar_t* s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxString& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxString& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxString& s1, const wxString& s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxString& s1, const wxCStrData& s2, size_t n) { return wxStrncmp_String(s1, s2, n); } inline int wxStrncmp(const wxCStrData& s1, const char* s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const wxCStrData& s1, const wchar_t* s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const wxCStrData& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const wxCStrData& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const wxCStrData& s1, const wxString& s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const wxCStrData& s1, const wxCStrData& s2, size_t n) { return wxStrncmp_String(s1.AsString(), s2, n); } inline int wxStrncmp(const char * s1, const wxCStrData& s2, size_t n) { return -wxStrncmp_String(s2.AsString(), s1, n); } inline int wxStrncmp(const char * s1, const wxString& s2, size_t n) { return -wxStrncmp_String(s2, s1, n); } inline int wxStrncmp(const wchar_t * s1, const wxCStrData& s2, size_t n) { return -wxStrncmp_String(s2.AsString(), s1, n); } inline int wxStrncmp(const wchar_t * s1, const wxString& s2, size_t n) { return -wxStrncmp_String(s2, s1, n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const wxCStrData& s2, size_t n) { return -wxStrncmp_String(s2.AsString(), s1.data(), n); } inline int wxStrncmp(const wxScopedCharBuffer& s1, const wxString& s2, size_t n) { return -wxStrncmp_String(s2, s1.data(), n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const wxCStrData& s2, size_t n) { return -wxStrncmp_String(s2.AsString(), s1.data(), n); } inline int wxStrncmp(const wxScopedWCharBuffer& s1, const wxString& s2, size_t n) { return -wxStrncmp_String(s2, s1.data(), n); }

template<typename T>
inline int wxStrnicmp_String(const wxString& s1, const T& s2, size_t n)
    { return s1.substr(0, n).CmpNoCase(wxString(s2).substr(0, n)); }
inline int wxStrnicmp(const char * s1, const char * s2, size_t n) { return wxCRT_StrnicmpA(s1, s2, n); } inline int wxStrnicmp(const char * s1, const wchar_t * s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const char * s1, const wxScopedCharBuffer& s2, size_t n) { return wxCRT_StrnicmpA(s1, s2.data(), n); } inline int wxStrnicmp(const char * s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrnicmp_String(wxString(s1), s2.data(), n); } inline int wxStrnicmp(const wchar_t * s1, const wchar_t * s2, size_t n) { return wxCRT_StrnicmpW(s1, s2, n); } inline int wxStrnicmp(const wchar_t * s1, const char * s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const wchar_t * s1, const wxScopedWCharBuffer& s2, size_t n) { return wxCRT_StrnicmpW(s1, s2.data(), n); } inline int wxStrnicmp(const wchar_t * s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrnicmp_String(wxString(s1), s2.data(), n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const char * s2, size_t n) { return wxCRT_StrnicmpA(s1.data(), s2, n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const wchar_t * s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const wxScopedCharBuffer& s2, size_t n) { return wxCRT_StrnicmpA(s1.data(), s2.data(), n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const wchar_t * s2, size_t n) { return wxCRT_StrnicmpW(s1.data(), s2, n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const char * s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxCRT_StrnicmpW(s1.data(), s2.data(), n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrnicmp_String(wxString(s1), wxString(s2), n); } inline int wxStrnicmp(const wxString& s1, const char* s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxString& s1, const wchar_t* s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxString& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxString& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxString& s1, const wxString& s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxString& s1, const wxCStrData& s2, size_t n) { return wxStrnicmp_String(s1, s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const char* s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const wchar_t* s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const wxScopedCharBuffer& s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const wxScopedWCharBuffer& s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const wxString& s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const wxCStrData& s1, const wxCStrData& s2, size_t n) { return wxStrnicmp_String(s1.AsString(), s2, n); } inline int wxStrnicmp(const char * s1, const wxCStrData& s2, size_t n) { return -wxStrnicmp_String(s2.AsString(), s1, n); } inline int wxStrnicmp(const char * s1, const wxString& s2, size_t n) { return -wxStrnicmp_String(s2, s1, n); } inline int wxStrnicmp(const wchar_t * s1, const wxCStrData& s2, size_t n) { return -wxStrnicmp_String(s2.AsString(), s1, n); } inline int wxStrnicmp(const wchar_t * s1, const wxString& s2, size_t n) { return -wxStrnicmp_String(s2, s1, n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const wxCStrData& s2, size_t n) { return -wxStrnicmp_String(s2.AsString(), s1.data(), n); } inline int wxStrnicmp(const wxScopedCharBuffer& s1, const wxString& s2, size_t n) { return -wxStrnicmp_String(s2, s1.data(), n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const wxCStrData& s2, size_t n) { return -wxStrnicmp_String(s2.AsString(), s1.data(), n); } inline int wxStrnicmp(const wxScopedWCharBuffer& s1, const wxString& s2, size_t n) { return -wxStrnicmp_String(s2, s1.data(), n); }
# 540 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline size_t wxStrxfrm(char *dest, const char *src, size_t n)
    { return strxfrm(dest, src, n); }
inline size_t wxStrxfrm(wchar_t *dest, const wchar_t *src, size_t n)
    { return wcsxfrm(dest, src, n); }
template<typename T>
inline size_t wxStrxfrm(T *dest, const wxScopedCharTypeBuffer<T>& src, size_t n)
    { return wxStrxfrm(dest, src.data(), n); }
inline size_t wxStrxfrm(char *dest, const wxString& src, size_t n)
    { return strxfrm(dest, src.mb_str(), n); }
inline size_t wxStrxfrm(wchar_t *dest, const wxString& src, size_t n)
    { return wcsxfrm(dest, src.wc_str(), n); }
inline size_t wxStrxfrm(char *dest, const wxCStrData& src, size_t n)
    { return strxfrm(dest, src.AsCharBuf(), n); }
inline size_t wxStrxfrm(wchar_t *dest, const wxCStrData& src, size_t n)
    { return wcsxfrm(dest, src.AsWCharBuf(), n); }



inline char *wxStrtok(char *str, const char *delim, char **saveptr)
    { return wxCRT_StrtokA(str, delim, saveptr); }
inline wchar_t *wxStrtok(wchar_t *str, const wchar_t *delim, wchar_t **saveptr)
    { return wxCRT_StrtokW(str, delim, saveptr); }
template<typename T>
inline T *wxStrtok(T *str, const wxScopedCharTypeBuffer<T>& delim, T **saveptr)
    { return wxStrtok(str, delim.data(), saveptr); }
inline char *wxStrtok(char *str, const wxCStrData& delim, char **saveptr)
    { return wxCRT_StrtokA(str, delim.AsCharBuf(), saveptr); }
inline wchar_t *wxStrtok(wchar_t *str, const wxCStrData& delim, wchar_t **saveptr)
    { return wxCRT_StrtokW(str, delim.AsWCharBuf(), saveptr); }
inline char *wxStrtok(char *str, const wxString& delim, char **saveptr)
    { return wxCRT_StrtokA(str, delim.mb_str(), saveptr); }
inline wchar_t *wxStrtok(wchar_t *str, const wxString& delim, wchar_t **saveptr)
    { return wxCRT_StrtokW(str, delim.wc_str(), saveptr); }

inline const char *wxStrstr(const char *haystack, const char *needle)
    { return strstr(haystack, needle); }
inline const wchar_t *wxStrstr(const wchar_t *haystack, const wchar_t *needle)
    { return wcsstr(haystack, needle); }
inline const char *wxStrstr(const char *haystack, const wxString& needle)
    { return strstr(haystack, needle.mb_str()); }
inline const wchar_t *wxStrstr(const wchar_t *haystack, const wxString& needle)
    { return wcsstr(haystack, needle.wc_str()); }


inline const char *wxStrstr(const wxString& haystack, const wxString& needle)
    { return strstr(haystack.c_str(), needle.mb_str()); }
inline const char *wxStrstr(const wxCStrData& haystack, const wxString& needle)
    { return strstr(haystack, needle.mb_str()); }
inline const char *wxStrstr(const wxCStrData& haystack, const wxCStrData& needle)
    { return strstr(haystack, needle.AsCharBuf()); }

inline const char *wxStrstr(const wxString& haystack, const char *needle)
    { return strstr(haystack.c_str(), needle); }
inline const char *wxStrstr(const wxCStrData& haystack, const char *needle)
    { return strstr(haystack, needle); }
inline const wchar_t *wxStrstr(const wxString& haystack, const wchar_t *needle)
    { return wcsstr(haystack.c_str(), needle); }
inline const wchar_t *wxStrstr(const wxCStrData& haystack, const wchar_t *needle)
    { return wcsstr(haystack, needle); }

inline const char *wxStrchr(const char *s, char c)
    { return strchr(s, c); }
inline const wchar_t *wxStrchr(const wchar_t *s, wchar_t c)
    { return wcschr(s, c); }
inline const char *wxStrrchr(const char *s, char c)
    { return strrchr(s, c); }
inline const wchar_t *wxStrrchr(const wchar_t *s, wchar_t c)
    { return wcsrchr(s, c); }
inline const char *wxStrchr(const char *s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s, c) : 
# 609 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                             __null
# 609 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                 ; }
inline const wchar_t *wxStrchr(const wchar_t *s, const wxUniChar& c)
    { return wcschr(s, (wchar_t)c); }
inline const char *wxStrrchr(const char *s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s, c) : 
# 613 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                              __null
# 613 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                  ; }
inline const wchar_t *wxStrrchr(const wchar_t *s, const wxUniChar& c)
    { return wcsrchr(s, (wchar_t)c); }
inline const char *wxStrchr(const char *s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s, c) : 
# 617 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                             __null
# 617 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                 ; }
inline const wchar_t *wxStrchr(const wchar_t *s, const wxUniCharRef& c)
    { return wcschr(s, (wchar_t)c); }
inline const char *wxStrrchr(const char *s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s, c) : 
# 621 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                              __null
# 621 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                  ; }
inline const wchar_t *wxStrrchr(const wchar_t *s, const wxUniCharRef& c)
    { return wcsrchr(s, (wchar_t)c); }
template<typename T>
inline const T* wxStrchr(const wxScopedCharTypeBuffer<T>& s, T c)
    { return wxStrchr(s.data(), c); }
template<typename T>
inline const T* wxStrrchr(const wxScopedCharTypeBuffer<T>& s, T c)
    { return wxStrrchr(s.data(), c); }
template<typename T>
inline const T* wxStrchr(const wxScopedCharTypeBuffer<T>& s, const wxUniChar& c)
    { return wxStrchr(s.data(), (T)c); }
template<typename T>
inline const T* wxStrrchr(const wxScopedCharTypeBuffer<T>& s, const wxUniChar& c)
    { return wxStrrchr(s.data(), (T)c); }
template<typename T>
inline const T* wxStrchr(const wxScopedCharTypeBuffer<T>& s, const wxUniCharRef& c)
    { return wxStrchr(s.data(), (T)c); }
template<typename T>
inline const T* wxStrrchr(const wxScopedCharTypeBuffer<T>& s, const wxUniCharRef& c)
    { return wxStrrchr(s.data(), (T)c); }


inline const char* wxStrchr(const wxString& s, char c)
    { return strchr((const char*)s.c_str(), c); }
inline const char* wxStrrchr(const wxString& s, char c)
    { return strrchr((const char*)s.c_str(), c); }
inline const char* wxStrchr(const wxString& s, int c)
    { return strchr((const char*)s.c_str(), c); }
inline const char* wxStrrchr(const wxString& s, int c)
    { return strrchr((const char*)s.c_str(), c); }
inline const char* wxStrchr(const wxString& s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s.c_str(), c) : 
# 653 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                                     __null
# 653 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                         ; }
inline const char* wxStrrchr(const wxString& s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s.c_str(), c) : 
# 655 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                                      __null
# 655 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                          ; }
inline const char* wxStrchr(const wxString& s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s.c_str(), c) : 
# 657 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                                     __null
# 657 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                         ; }
inline const char* wxStrrchr(const wxString& s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s.c_str(), c) : 
# 659 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                                      __null
# 659 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                          ; }
inline const wchar_t* wxStrchr(const wxString& s, wchar_t c)
    { return wcschr((const wchar_t*)s.c_str(), c); }
inline const wchar_t* wxStrrchr(const wxString& s, wchar_t c)
    { return wcsrchr((const wchar_t*)s.c_str(), c); }
inline const char* wxStrchr(const wxCStrData& s, char c)
    { return strchr(s.AsChar(), c); }
inline const char* wxStrrchr(const wxCStrData& s, char c)
    { return strrchr(s.AsChar(), c); }
inline const char* wxStrchr(const wxCStrData& s, int c)
    { return strchr(s.AsChar(), c); }
inline const char* wxStrrchr(const wxCStrData& s, int c)
    { return strrchr(s.AsChar(), c); }
inline const char* wxStrchr(const wxCStrData& s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s, c) : 
# 673 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                             __null
# 673 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                 ; }
inline const char* wxStrrchr(const wxCStrData& s, const wxUniChar& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s, c) : 
# 675 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                              __null
# 675 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                  ; }
inline const char* wxStrchr(const wxCStrData& s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strchr(s, c) : 
# 677 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                             __null
# 677 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                 ; }
inline const char* wxStrrchr(const wxCStrData& s, const wxUniCharRef& uc)
    { char c; return uc.GetAsChar(&c) ? strrchr(s, c) : 
# 679 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                              __null
# 679 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                                  ; }
inline const wchar_t* wxStrchr(const wxCStrData& s, wchar_t c)
    { return wcschr(s.AsWChar(), c); }
inline const wchar_t* wxStrrchr(const wxCStrData& s, wchar_t c)
    { return wcsrchr(s.AsWChar(), c); }

inline const char *wxStrpbrk(const char *s, const char *accept)
    { return strpbrk(s, accept); }
inline const wchar_t *wxStrpbrk(const wchar_t *s, const wchar_t *accept)
    { return wcspbrk(s, accept); }
inline const char *wxStrpbrk(const char *s, const wxString& accept)
    { return strpbrk(s, accept.mb_str()); }
inline const char *wxStrpbrk(const char *s, const wxCStrData& accept)
    { return strpbrk(s, accept.AsCharBuf()); }
inline const wchar_t *wxStrpbrk(const wchar_t *s, const wxString& accept)
    { return wcspbrk(s, accept.wc_str()); }
inline const wchar_t *wxStrpbrk(const wchar_t *s, const wxCStrData& accept)
    { return wcspbrk(s, accept.AsWCharBuf()); }
inline const char *wxStrpbrk(const wxString& s, const wxString& accept)
    { return strpbrk(s.c_str(), accept.mb_str()); }
inline const char *wxStrpbrk(const wxString& s, const char *accept)
    { return strpbrk(s.c_str(), accept); }
inline const wchar_t *wxStrpbrk(const wxString& s, const wchar_t *accept)
    { return wcspbrk(s.wc_str(), accept); }
inline const char *wxStrpbrk(const wxString& s, const wxCStrData& accept)
    { return strpbrk(s.c_str(), accept.AsCharBuf()); }
inline const char *wxStrpbrk(const wxCStrData& s, const wxString& accept)
    { return strpbrk(s.AsChar(), accept.mb_str()); }
inline const char *wxStrpbrk(const wxCStrData& s, const char *accept)
    { return strpbrk(s.AsChar(), accept); }
inline const wchar_t *wxStrpbrk(const wxCStrData& s, const wchar_t *accept)
    { return wcspbrk(s.AsWChar(), accept); }
inline const char *wxStrpbrk(const wxCStrData& s, const wxCStrData& accept)
    { return strpbrk(s.AsChar(), accept.AsCharBuf()); }
template <typename S, typename T>
inline const T *wxStrpbrk(const S& s, const wxScopedCharTypeBuffer<T>& accept)
    { return wxStrpbrk(s, accept.data()); }



template <typename T>
inline char *wxStrstr(char *haystack, T needle)
    { return const_cast<char*>(wxStrstr(const_cast<const char*>(haystack), needle)); }
template <typename T>
inline wchar_t *wxStrstr(wchar_t *haystack, T needle)
    { return const_cast<wchar_t*>(wxStrstr(const_cast<const wchar_t*>(haystack), needle)); }

template <typename T>
inline char * wxStrchr(char *s, T c)
    { return const_cast<char*>(wxStrchr(const_cast<const char*>(s), c)); }
template <typename T>
inline wchar_t * wxStrchr(wchar_t *s, T c)
    { return (wchar_t *)wxStrchr((const wchar_t *)s, c); }
template <typename T>
inline char * wxStrrchr(char *s, T c)
    { return const_cast<char*>(wxStrrchr(const_cast<const char*>(s), c)); }
template <typename T>
inline wchar_t * wxStrrchr(wchar_t *s, T c)
    { return const_cast<wchar_t*>(wxStrrchr(const_cast<const wchar_t*>(s), c)); }

template <typename T>
inline char * wxStrpbrk(char *s, T accept)
    { return const_cast<char*>(wxStrpbrk(const_cast<const char*>(s), accept)); }
template <typename T>
inline wchar_t * wxStrpbrk(wchar_t *s, T accept)
    { return const_cast<wchar_t*>(wxStrpbrk(const_cast<const wchar_t*>(s), accept)); }
# 753 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline FILE *wxFopen(const wxString& path, const wxString& mode)
    { return _wfopen(path.fn_str(), mode.fn_str()); }
inline FILE *wxFreopen(const wxString& path, const wxString& mode, FILE *stream)
    { return _wfreopen(path.fn_str(), mode.fn_str(), stream); }
inline int wxRemove(const wxString& path)
    { return _wremove(path.fn_str()); }
inline int wxRename(const wxString& oldpath, const wxString& newpath)
    { return _wrename(oldpath.fn_str(), newpath.fn_str()); }

extern int wxPuts(const wxString& s);
extern int wxFputs(const wxString& s, FILE *stream);
extern void wxPerror(const wxString& s);

extern int wxFputc(const wxUniChar& c, FILE *stream);







inline char *wxFgets(char *s, int size, FILE *stream)
    { return fgets(s, size, stream); }

extern wchar_t *wxFgets(wchar_t *s, int size, FILE *stream);





inline int wxFgetc(FILE *stream) { return fgetc(stream); }
inline int wxUngetc(int c, FILE *stream) { return ungetc(c, stream); }
# 797 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline int wxAtoi(const wxString& str) { return atoi(str.mb_str()); }



inline long wxAtol(const wxString& str) { return wcstol(str.wc_str(), 
# 801 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                __null
# 801 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                , 10); }





inline double wxAtof(const wxString& str) { return wcstod(str.wc_str(), 
# 807 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                  __null
# 807 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                  ); }




inline double wxStrtod(const char *nptr, char **endptr)
    { return strtod(nptr, endptr); }
inline double wxStrtod(const wchar_t *nptr, wchar_t **endptr)
    { return wcstod(nptr, endptr); }
template<typename T>
inline double wxStrtod(const wxScopedCharTypeBuffer<T>& nptr, T **endptr)
    { return wxStrtod(nptr.data(), endptr); }
# 828 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
template<typename T> struct wxStrtoxCharType {};
template<> struct wxStrtoxCharType<char**>
{
    typedef const char* Type;
    static char** AsPointer(char **p) { return p; }
};
template<> struct wxStrtoxCharType<wchar_t**>
{
    typedef const wchar_t* Type;
    static wchar_t** AsPointer(wchar_t **p) { return p; }
};
template<> struct wxStrtoxCharType<int>
{
    typedef const char* Type;
    static char** AsPointer(int p)
    {
        do { if ( wxTheAssertHandler && !(p == 0) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h", 844, __FUNCTION__, "p == 0", "passing non-NULL int is invalid"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return 
# 845 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
              __null
# 845 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                  ;
    }
};

template<typename T>
inline double wxStrtod(const wxString& nptr, T endptr)
{
    if ( endptr == 0 )
    {



        return wxStrtod(nptr.wx_str(), (wxStringCharType**)
# 857 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
                                                          __null
# 857 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
                                                              );
    }
    else
    {



        typedef typename wxStrtoxCharType<T>::Type CharType;
        return wxStrtod((CharType)nptr.c_str(),
                        wxStrtoxCharType<T>::AsPointer(endptr));
    }
}
template<typename T>
inline double wxStrtod(const wxCStrData& nptr, T endptr)
    { return wxStrtod(nptr.AsString(), endptr); }
# 900 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline long wxStrtol(const char *nptr, char **endptr, int base) { return strtol(nptr, endptr, base); } inline long wxStrtol(const wchar_t *nptr, wchar_t **endptr, int base) { return wcstol(nptr, endptr, base); } template<typename T> inline long wxStrtol(const wxScopedCharTypeBuffer<T>& nptr, T **endptr, int) { return wxStrtol(nptr.data(), endptr); } template<typename T> inline long wxStrtol(const wxString& nptr, T endptr, int base) { if ( endptr == 0 ) return wxStrtol(nptr.wx_str(), (wxStringCharType**)
# 900 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
__null
# 900 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
, base); else { typedef typename wxStrtoxCharType<T>::Type CharType; return wxStrtol((CharType)nptr.c_str(), wxStrtoxCharType<T>::AsPointer(endptr), base); } } template<typename T> inline long wxStrtol(const wxCStrData& nptr, T endptr, int base) { return wxStrtol(nptr.AsString(), endptr, base); }
inline unsigned long wxStrtoul(const char *nptr, char **endptr, int base) { return strtoul(nptr, endptr, base); } inline unsigned long wxStrtoul(const wchar_t *nptr, wchar_t **endptr, int base) { return wcstoul(nptr, endptr, base); } template<typename T> inline unsigned long wxStrtoul(const wxScopedCharTypeBuffer<T>& nptr, T **endptr, int) { return wxStrtoul(nptr.data(), endptr); } template<typename T> inline unsigned long wxStrtoul(const wxString& nptr, T endptr, int base) { if ( endptr == 0 ) return wxStrtoul(nptr.wx_str(), (wxStringCharType**)
# 901 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
__null
# 901 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
, base); else { typedef typename wxStrtoxCharType<T>::Type CharType; return wxStrtoul((CharType)nptr.c_str(), wxStrtoxCharType<T>::AsPointer(endptr), base); } } template<typename T> inline unsigned long wxStrtoul(const wxCStrData& nptr, T endptr, int base) { return wxStrtoul(nptr.AsString(), endptr, base); }

inline long long wxStrtoll(const char *nptr, char **endptr, int base) { return wxCRT_StrtollA(nptr, endptr, base); } inline long long wxStrtoll(const wchar_t *nptr, wchar_t **endptr, int base) { return wxCRT_StrtollW(nptr, endptr, base); } template<typename T> inline long long wxStrtoll(const wxScopedCharTypeBuffer<T>& nptr, T **endptr, int) { return wxStrtoll(nptr.data(), endptr); } template<typename T> inline long long wxStrtoll(const wxString& nptr, T endptr, int base) { if ( endptr == 0 ) return wxStrtoll(nptr.wx_str(), (wxStringCharType**)
# 903 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
__null
# 903 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
, base); else { typedef typename wxStrtoxCharType<T>::Type CharType; return wxStrtoll((CharType)nptr.c_str(), wxStrtoxCharType<T>::AsPointer(endptr), base); } } template<typename T> inline long long wxStrtoll(const wxCStrData& nptr, T endptr, int base) { return wxStrtoll(nptr.AsString(), endptr, base); }
inline unsigned long long wxStrtoull(const char *nptr, char **endptr, int base) { return wxCRT_StrtoullA(nptr, endptr, base); } inline unsigned long long wxStrtoull(const wchar_t *nptr, wchar_t **endptr, int base) { return wxCRT_StrtoullW(nptr, endptr, base); } template<typename T> inline unsigned long long wxStrtoull(const wxScopedCharTypeBuffer<T>& nptr, T **endptr, int) { return wxStrtoull(nptr.data(), endptr); } template<typename T> inline unsigned long long wxStrtoull(const wxString& nptr, T endptr, int base) { if ( endptr == 0 ) return wxStrtoull(nptr.wx_str(), (wxStringCharType**)
# 904 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h" 3 4
__null
# 904 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
, base); else { typedef typename wxStrtoxCharType<T>::Type CharType; return wxStrtoull((CharType)nptr.c_str(), wxStrtoxCharType<T>::AsPointer(endptr), base); } } template<typename T> inline unsigned long long wxStrtoull(const wxCStrData& nptr, T endptr, int base) { return wxStrtoull(nptr.AsString(), endptr, base); }
# 916 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline int wxSystem(const wxString& str) { return _wsystem(str.wc_str()); }






inline char* wxGetenv(const char *name) { return getenv(name); }
inline wchar_t* wxGetenv(const wchar_t *name) { return _wgetenv(name); }
inline char* wxGetenv(const wxString& name) { return getenv(name.mb_str()); }
inline char* wxGetenv(const wxCStrData& name) { return getenv(name.AsCharBuf()); }
inline char* wxGetenv(const wxScopedCharBuffer& name) { return getenv(name.data()); }
inline wchar_t* wxGetenv(const wxScopedWCharBuffer& name) { return _wgetenv(name.data()); }





inline size_t wxStrftime(char *s, size_t max,
                         const wxString& format, const struct tm *tm)
    { return strftime(s, max, format.mb_str(), tm); }

inline size_t wxStrftime(wchar_t *s, size_t max,
                         const wxString& format, const struct tm *tm)
    { return wcsftime(s, max, format.wc_str(), tm); }
# 960 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrt.h"
inline bool wxIsalnum(const wxUniChar& c) { return iswalnum(c) != 0; }
inline bool wxIsalpha(const wxUniChar& c) { return iswalpha(c) != 0; }
inline bool wxIscntrl(const wxUniChar& c) { return iswcntrl(c) != 0; }
inline bool wxIsdigit(const wxUniChar& c) { return iswdigit(c) != 0; }
inline bool wxIsgraph(const wxUniChar& c) { return iswgraph(c) != 0; }
inline bool wxIslower(const wxUniChar& c) { return iswlower(c) != 0; }
inline bool wxIsprint(const wxUniChar& c) { return iswprint(c) != 0; }
inline bool wxIspunct(const wxUniChar& c) { return iswpunct(c) != 0; }
inline bool wxIsspace(const wxUniChar& c) { return iswspace(c) != 0; }
inline bool wxIsupper(const wxUniChar& c) { return iswupper(c) != 0; }
inline bool wxIsxdigit(const wxUniChar& c) { return iswxdigit(c) != 0; }

inline wxUniChar wxTolower(const wxUniChar& c) { return towlower((wxUChar)(wxChar)(c)); }
inline wxUniChar wxToupper(const wxUniChar& c) { return towupper((wxUChar)(wxChar)(c)); }






__attribute__((deprecated)) inline int wxIsctrl(const wxUniChar& c);
inline int wxIsctrl(const wxUniChar& c) { return wxIscntrl(c); }


inline bool wxIsascii(const wxUniChar& c) { return c.IsAscii(); }
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/crt.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h" 1
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdarg.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 2 3 4
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h" 2
# 165 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
    int
    wxCRT_VsnprintfW(wchar_t *buf, size_t len, const wchar_t *format, va_list argptr);







        int
        wxCRT_VsnprintfA(char *buf, size_t len, const char *format, va_list argptr);
# 290 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
template<typename T1> int wxPrintf(const wxFormatString& f1, T1 a1) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxPrintf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); return wprintf(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }

inline int wxPrintf(const wxFormatString& s)
{
    return wxPrintf("%s", s.InputAsString());
}

template<typename T1> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxFprintf(FILE* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef FILE* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return fwprintf(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }

inline int wxFprintf(FILE *f, const wxFormatString& s)
{
    return wxFprintf(f, "%s", s.InputAsString());
}
# 324 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
inline int
wxVprintf(const wxString& format, va_list ap)
{
    return vwprintf (wxFormatString(format), ap)
                                                       ;
}

inline int
wxVfprintf(FILE *f, const wxString& format, va_list ap)
{
    return vfwprintf (f, wxFormatString(format), ap)
                                                         ;
}
# 345 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
int wxDoSprintfWchar(char *str, const wxChar *format, ...);




inline int wxSprintf(char* f1, const wxFormatString& f2) { return wxDoSprintfWchar(f1, f2); } template<typename T1> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSprintf(char* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef char* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }


int
wxVsprintf(char *str, const wxString& format, va_list argptr);


int wxDoSnprintfWchar(char *str, size_t size, const wxChar *format, ...);




inline int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3) { return wxDoSnprintfWchar(f1, f2, f3); } template<typename T1> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSnprintf(char* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef char* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }


int
wxVsnprintf(char *str, size_t size, const wxString& format, va_list argptr);




int wxDoSprintfWchar(wchar_t *str, const wxChar *format, ...);




inline int wxSprintf(wchar_t* f1, const wxFormatString& f2) { return wxDoSprintfWchar(f1, f2); } template<typename T1> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSprintf(wchar_t* f1, const wxFormatString& f2, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef wchar_t* TF1; typedef const wxFormatString& TF2; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2))); return wxDoSprintfWchar(f1, f2, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }


int
wxVsprintf(wchar_t *str, const wxString& format, va_list argptr);


int wxDoSnprintfWchar(wchar_t *str, size_t size, const wxChar *format, ...);




inline int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3) { return wxDoSnprintfWchar(f1, f2, f3); } template<typename T1> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSnprintf(wchar_t* f1, size_t f2, const wxFormatString& f3, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef wchar_t* TF1; typedef size_t TF2; typedef const wxFormatString& TF3; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1)), (wxFormatStringArgumentFinder<TF2>::find(f2)), (wxFormatStringArgumentFinder<TF3>::find(f3))); return wxDoSnprintfWchar(f1, f2, f3, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }


int
wxVsnprintf(wchar_t *str, size_t size, const wxString& format, va_list argptr);
# 457 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/wxcrtvararg.h"
template<typename T1> int wxScanf(const char *format, T1 a1) { return scanf(format, a1); } template<typename T1, typename T2> int wxScanf(const char *format, T1 a1, T2 a2) { return scanf(format, a1, a2); } template<typename T1, typename T2, typename T3> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3) { return scanf(format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return scanf(format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return scanf(format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return scanf(format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return scanf(format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxScanf(const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return scanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxScanf(const wchar_t *format, T1 a1) { return wscanf(format, a1); } template<typename T1, typename T2> int wxScanf(const wchar_t *format, T1 a1, T2 a2) { return wscanf(format, a1, a2); } template<typename T1, typename T2, typename T3> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3) { return wscanf(format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return wscanf(format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return wscanf(format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return wscanf(format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxScanf(const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return wscanf(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }


template<typename T1> int wxFscanf(FILE *stream, const char *format, T1 a1) { return fscanf(stream, format, a1); } template<typename T1, typename T2> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2) { return fscanf(stream, format, a1, a2); } template<typename T1, typename T2, typename T3> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3) { return fscanf(stream, format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return fscanf(stream, format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return fscanf(stream, format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxFscanf(FILE *stream, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return fscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1) { return fwscanf(stream, format, a1); } template<typename T1, typename T2> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2) { return fwscanf(stream, format, a1, a2); } template<typename T1, typename T2, typename T3> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3) { return fwscanf(stream, format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return fwscanf(stream, format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return fwscanf(stream, format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxFscanf(FILE *stream, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return fwscanf(stream, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }


template<typename T1> int wxSscanf(const char *str, const char *format, T1 a1) { return sscanf(str, format, a1); } template<typename T1, typename T2> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2) { return sscanf(str, format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3) { return sscanf(str, format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return sscanf(str, format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return sscanf(str, format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return sscanf(str, format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const char *str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return sscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1) { return swscanf(str, format, a1); } template<typename T1, typename T2> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2) { return swscanf(str, format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3) { return swscanf(str, format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return swscanf(str, format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return swscanf(str, format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return swscanf(str, format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wchar_t *str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return swscanf(str, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1) { return sscanf(str.data(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2) { return sscanf(str.data(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3) { return sscanf(str.data(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return sscanf(str.data(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return sscanf(str.data(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxScopedCharBuffer& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return sscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1) { return swscanf(str.data(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2) { return swscanf(str.data(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3) { return swscanf(str.data(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return swscanf(str.data(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return swscanf(str.data(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxScopedWCharBuffer& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return swscanf(str.data(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxString& str, const char *format, T1 a1) { return sscanf(str.mb_str(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2) { return sscanf(str.mb_str(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3) { return sscanf(str.mb_str(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return sscanf(str.mb_str(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxString& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return sscanf(str.mb_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1) { return swscanf(str.wc_str(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2) { return swscanf(str.wc_str(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3) { return swscanf(str.wc_str(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return swscanf(str.wc_str(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxString& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return swscanf(str.wc_str(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxCStrData& str, const char *format, T1 a1) { return sscanf(str.AsCharBuf(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2) { return sscanf(str.AsCharBuf(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3) { return sscanf(str.AsCharBuf(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxCStrData& str, const char *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return sscanf(str.AsCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }

template<typename T1> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1) { return swscanf(str.AsWCharBuf(), format, a1); } template<typename T1, typename T2> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2) { return swscanf(str.AsWCharBuf(), format, a1, a2); } template<typename T1, typename T2, typename T3> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3); } template<typename T1, typename T2, typename T3, typename T4> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4); } template<typename T1, typename T2, typename T3, typename T4, typename T5> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> int wxSscanf(const wxCStrData& str, const wchar_t *format, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { return swscanf(str.AsWCharBuf(), format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30); }




int wxVsscanf(const char *str, const char *format, va_list ap);
int wxVsscanf(const wchar_t *str, const wchar_t *format, va_list ap);
int wxVsscanf(const wxScopedCharBuffer& str, const char *format, va_list ap);
int wxVsscanf(const wxScopedWCharBuffer& str, const wchar_t *format, va_list ap);
int wxVsscanf(const wxString& str, const char *format, va_list ap);
int wxVsscanf(const wxString& str, const wchar_t *format, va_list ap);
int wxVsscanf(const wxCStrData& str, const char *format, va_list ap);
int wxVsscanf(const wxCStrData& str, const wchar_t *format, va_list ap);
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/crt.h" 2
# 4306 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/string.h" 2






template<bool (T)(const wxUniChar& c)>
    inline bool wxStringCheck(const wxString& val)
    {
        for ( wxString::const_iterator i = val.begin();
              i != val.end();
              ++i )
            if (T(*i) == 0)
                return false;
        return true;
    }
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/memory.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h" 1
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h"
class wxMessageOutputBase
{
public:
    virtual ~wxMessageOutputBase() { }



    inline void Printf(const wxFormatString& f1) { DoPrintfWchar(f1); } template<typename T1> void Printf(const wxFormatString& f1, T1 a1) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get()); } template<typename T1, typename T2> void Printf(const wxFormatString& f1, T1 a1, T2 a2) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get()); } template<typename T1, typename T2, typename T3> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get()); } template<typename T1, typename T2, typename T3, typename T4> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get()); } template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25, typename T26, typename T27, typename T28, typename T29, typename T30> void Printf(const wxFormatString& f1, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20, T21 a21, T22 a22, T23 a23, T24 a24, T25 a25, T26 a26, T27 a27, T28 a28, T29 a29, T30 a30) { typedef const wxFormatString& TF1; const wxFormatString *fmt = ((wxFormatStringArgumentFinder<TF1>::find(f1))); DoPrintfWchar(f1, wxArgNormalizerWchar<T1>(a1, fmt, 1).get(), wxArgNormalizerWchar<T2>(a2, fmt, 2).get(), wxArgNormalizerWchar<T3>(a3, fmt, 3).get(), wxArgNormalizerWchar<T4>(a4, fmt, 4).get(), wxArgNormalizerWchar<T5>(a5, fmt, 5).get(), wxArgNormalizerWchar<T6>(a6, fmt, 6).get(), wxArgNormalizerWchar<T7>(a7, fmt, 7).get(), wxArgNormalizerWchar<T8>(a8, fmt, 8).get(), wxArgNormalizerWchar<T9>(a9, fmt, 9).get(), wxArgNormalizerWchar<T10>(a10, fmt, 10).get(), wxArgNormalizerWchar<T11>(a11, fmt, 11).get(), wxArgNormalizerWchar<T12>(a12, fmt, 12).get(), wxArgNormalizerWchar<T13>(a13, fmt, 13).get(), wxArgNormalizerWchar<T14>(a14, fmt, 14).get(), wxArgNormalizerWchar<T15>(a15, fmt, 15).get(), wxArgNormalizerWchar<T16>(a16, fmt, 16).get(), wxArgNormalizerWchar<T17>(a17, fmt, 17).get(), wxArgNormalizerWchar<T18>(a18, fmt, 18).get(), wxArgNormalizerWchar<T19>(a19, fmt, 19).get(), wxArgNormalizerWchar<T20>(a20, fmt, 20).get(), wxArgNormalizerWchar<T21>(a21, fmt, 21).get(), wxArgNormalizerWchar<T22>(a22, fmt, 22).get(), wxArgNormalizerWchar<T23>(a23, fmt, 23).get(), wxArgNormalizerWchar<T24>(a24, fmt, 24).get(), wxArgNormalizerWchar<T25>(a25, fmt, 25).get(), wxArgNormalizerWchar<T26>(a26, fmt, 26).get(), wxArgNormalizerWchar<T27>(a27, fmt, 27).get(), wxArgNormalizerWchar<T28>(a28, fmt, 28).get(), wxArgNormalizerWchar<T29>(a29, fmt, 29).get(), wxArgNormalizerWchar<T30>(a30, fmt, 30).get()); }
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h"
    virtual void Output(const wxString& str) = 0;

protected:



    virtual void DoPrintfWchar(const wxChar *format, ...) = 0;




};
# 75 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h"
class wxMessageOutput : public wxMessageOutputBase
{
public:
    virtual ~wxMessageOutput() { }



    static wxMessageOutput* Get();


    static wxMessageOutput* Set(wxMessageOutput* msgout);

protected:

    virtual void DoPrintfWchar(const wxChar *format, ...);





private:
    static wxMessageOutput* ms_msgOut;
};
# 107 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h"
class wxMessageOutputStderr : public wxMessageOutput
{
public:
    wxMessageOutputStderr(FILE *fp = 
# 110 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h" 3
                                    (__acrt_iob_func(2))
# 110 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msgout.h"
                                          ) : m_fp(fp) { }

    virtual void Output(const wxString& str);

protected:


    wxString AppendLineFeedIfNeeded(const wxString& str);

    FILE *m_fp;
};






enum wxMessageOutputFlags
{
    wxMSGOUT_PREFER_STDERR = 0,
    wxMSGOUT_PREFER_MSGBOX = 1
};

class wxMessageOutputBest : public wxMessageOutputStderr
{
public:
    wxMessageOutputBest(wxMessageOutputFlags flags = wxMSGOUT_PREFER_STDERR)
        : m_flags(flags) { }

    virtual void Output(const wxString& str);

private:
    wxMessageOutputFlags m_flags;
};







class wxMessageOutputMessageBox : public wxMessageOutput
{
public:
    wxMessageOutputMessageBox() { }

    virtual void Output(const wxString& str);
};







class wxMessageOutputDebug : public wxMessageOutputStderr
{
public:
    wxMessageOutputDebug() { }

    virtual void Output(const wxString& str);
};





class wxMessageOutputLog : public wxMessageOutput
{
public:
    wxMessageOutputLog() { }

    virtual void Output(const wxString& str);
};
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/memory.h" 2
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 2
# 56 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/xti.h" 1
# 57 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 1
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
class wxObject;
class wxString;
class wxClassInfo;
class wxHashTable;
class wxObject;
class wxPluginLibrary;
class wxHashTable_Node;





typedef wxObject *(*wxObjectConstructorFn)(void);

class wxClassInfo
{
    friend class wxObject;
    friend wxObject *wxCreateDynamicObject(const wxString& name);
public:
    wxClassInfo( const wxChar *className,
                 const wxClassInfo *baseInfo1,
                 const wxClassInfo *baseInfo2,
                 int size,
                 wxObjectConstructorFn ctor )
        : m_className(className)
        , m_objectSize(size)
        , m_objectConstructor(ctor)
        , m_baseInfo1(baseInfo1)
        , m_baseInfo2(baseInfo2)
        , m_next(sm_first)
        {
            sm_first = this;
            Register();
        }

    ~wxClassInfo();

    wxObject *CreateObject() const
        { return m_objectConstructor ? (*m_objectConstructor)() : 0; }
    bool IsDynamic() const { return (
# 66 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 3 4
                                    __null 
# 66 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
                                         != m_objectConstructor); }

    const wxChar *GetClassName() const { return m_className; }
    const wxChar *GetBaseClassName1() const
        { return m_baseInfo1 ? m_baseInfo1->GetClassName() : 
# 70 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 3 4
                                                            __null
# 70 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
                                                                ; }
    const wxChar *GetBaseClassName2() const
        { return m_baseInfo2 ? m_baseInfo2->GetClassName() : 
# 72 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 3 4
                                                            __null
# 72 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
                                                                ; }
    const wxClassInfo *GetBaseClass1() const { return m_baseInfo1; }
    const wxClassInfo *GetBaseClass2() const { return m_baseInfo2; }
    int GetSize() const { return m_objectSize; }

    wxObjectConstructorFn GetConstructor() const
        { return m_objectConstructor; }
    static const wxClassInfo *GetFirst() { return sm_first; }
    const wxClassInfo *GetNext() const { return m_next; }
    static wxClassInfo *FindClass(const wxString& className);




    bool IsKindOf(const wxClassInfo *info) const
    {
        return info != 0 &&
               ( info == this ||
                 ( m_baseInfo1 && m_baseInfo1->IsKindOf(info) ) ||
                 ( m_baseInfo2 && m_baseInfo2->IsKindOf(info) ) );
    }

    class const_iterator { typedef wxHashTable_Node Node; public: typedef const wxClassInfo* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; wxHashTable* m_table; public: typedef const_reference reference_type; typedef ptr_type pointer_type; const_iterator(Node* node, wxHashTable* table) : m_node(node), m_table(table) { } const_iterator() : m_node(
# 94 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 3 4
   __null
# 94 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
   ), m_table(
# 94 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 3 4
   __null
# 94 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
   ) { } value_type operator*() const; itor& operator++(); const itor operator++(int); bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; static const_iterator begin_classinfo(); static const_iterator end_classinfo();

private:
    const wxChar *m_className;
    int m_objectSize;
    wxObjectConstructorFn m_objectConstructor;



    const wxClassInfo *m_baseInfo1;
    const wxClassInfo *m_baseInfo2;




    static wxClassInfo *sm_first;
    wxClassInfo *m_next;

    static wxHashTable *sm_classTable;

protected:

    void Register();
    void Unregister();

    private: wxClassInfo(const wxClassInfo&); wxClassInfo& operator=(const wxClassInfo&);
};

 wxObject *wxCreateDynamicObject(const wxString& name);
# 199 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/flags.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/flags.h"
template <class T> class wxBitset
{
    friend class wxEnumData ;
public:

    wxBitset() { m_data = 0; }



    wxBitset(unsigned long val) { m_data = val ; }


    wxBitset(const wxBitset &src) { m_data = src.m_data; }


    wxBitset(const T el) { m_data |= 1 << el; }


    unsigned long to_ulong() const { return m_data ; }


    wxBitset &operator =(const wxBitset &rhs)
    {
        m_data = rhs.m_data;
        return *this;
    }



    wxBitset &operator |=(const wxBitset &rhs)
    {
        m_data |= rhs.m_data;
        return *this;
    }



    wxBitset &operator ^=(const wxBitset &rhs)
    {
        m_data ^= rhs.m_data;
        return *this;
    }



    wxBitset &operator &=(const wxBitset &rhs)
    {
        m_data &= rhs.m_data;
        return *this;
    }



    wxBitset operator |(const wxBitset &bitset2) const
    {
        wxBitset<T> s;
        s.m_data = m_data | bitset2.m_data;
        return s;
    }



    wxBitset operator ^(const wxBitset &bitset2) const
    {
        wxBitset<T> s;
        s.m_data = m_data ^ bitset2.m_data;
        return s;
    }



    wxBitset operator &(const wxBitset &bitset2) const
    {
        wxBitset<T> s;
        s.m_data = m_data & bitset2.m_data;
        return s;
    }


    wxBitset& set(const T el)
    {
        m_data |= 1 << el;
        return *this;
    }


    wxBitset& reset(const T el)
    {
        m_data &= ~(1 << el);
        return *this;
    }


    wxBitset& reset()
    {
        m_data = 0;
        return *this;
    }


    bool test(const T el) const
    {
        return (m_data & (1 << el)) ? true : false;
    }


    bool none() const
    {
        return m_data == 0;
    }


    bool any() const
    {
        return m_data != 0;
    }


    bool operator ==(const wxBitset &rhs) const
    {
        return m_data == rhs.m_data;
    }


    bool operator !=(const wxBitset &rhs) const
    {
        return !operator==(rhs);
    }

    bool operator[] (const T el) const { return test(el) ; }

private :
    unsigned long m_data;
};
# 200 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/rtti.h" 2
# 58 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 2
# 157 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
template <class T>
inline T *wxCheckCast(const void *ptr, T * = 
# 158 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
                                            __null
# 158 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
                                                )
{
    do { if ( wxTheAssertHandler && !(((T *) wxCheckDynamicCast( const_cast<wxObject *>(static_cast<const wxObject *>( const_cast<T *>(static_cast<const T *>(ptr)))), &T::ms_classInfo))) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h", 160, __FUNCTION__, "wxDynamicCast(ptr, T)", "wxStaticCast() used incorrectly"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
    return const_cast<T *>(static_cast<const T *>(ptr));
}
# 241 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
class wxRefCounter
{
public:
    wxRefCounter() { m_count = 1; }

    int GetRefCount() const { return m_count; }

    void IncRef() { m_count++; }
    void DecRef();

protected:


    virtual ~wxRefCounter() { }

private:

    int m_count;





    private: wxRefCounter(const wxRefCounter&); wxRefCounter& operator=(const wxRefCounter&);
};





typedef wxRefCounter wxObjectRefData;






template <class T>
class wxObjectDataPtr
{
public:
    typedef T element_type;

    explicit wxObjectDataPtr(T *ptr = 
# 284 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
                                       __null
# 284 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
                                           ) : m_ptr(ptr) {}


    wxObjectDataPtr(const wxObjectDataPtr<T> &tocopy)
        : m_ptr(tocopy.m_ptr)
    {
        if (m_ptr)
            m_ptr->IncRef();
    }

    ~wxObjectDataPtr()
    {
        if (m_ptr)
            m_ptr->DecRef();
    }

    T *get() const { return m_ptr; }



    typedef T *(wxObjectDataPtr<T>::*unspecified_bool_type)() const;
    operator unspecified_bool_type() const
    {
        return m_ptr ? &wxObjectDataPtr<T>::get : 
# 307 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
                                                 __null
# 307 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
                                                     ;
    }

    T& operator*() const
    {
        do { if ( wxTheAssertHandler && !(m_ptr != 
# 312 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
       __null
# 312 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
       ) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h", 312, __FUNCTION__, "m_ptr != __null", (const char*)
# 312 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
       __null
# 312 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return *(m_ptr);
    }

    T *operator->() const
    {
        do { if ( wxTheAssertHandler && !(m_ptr != 
# 318 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
       __null
# 318 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
       ) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h", 318, __FUNCTION__, "m_ptr != __null", (const char*)
# 318 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
       __null
# 318 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return get();
    }

    void reset(T *ptr)
    {
        if (m_ptr)
            m_ptr->DecRef();
        m_ptr = ptr;
    }

    wxObjectDataPtr& operator=(const wxObjectDataPtr &tocopy)
    {
        if (m_ptr)
            m_ptr->DecRef();
        m_ptr = tocopy.m_ptr;
        if (m_ptr)
            m_ptr->IncRef();
        return *this;
    }

    wxObjectDataPtr& operator=(T *ptr)
    {
        if (m_ptr)
            m_ptr->DecRef();
        m_ptr = ptr;
        return *this;
    }

private:
    T *m_ptr;
};





class wxObject
{
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;

public:
    wxObject() { m_refData = 
# 360 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
                            __null
# 360 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
                                ; }
    virtual ~wxObject() { UnRef(); }

    wxObject(const wxObject& other)
    {
         m_refData = other.m_refData;
         if (m_refData)
             m_refData->IncRef();
    }

    wxObject& operator=(const wxObject& other)
    {
        if ( this != &other )
        {
            Ref(other);
        }
        return *this;
    }

    bool IsKindOf(const wxClassInfo *info) const;
# 415 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
    wxObjectRefData *GetRefData() const { return m_refData; }
    void SetRefData(wxObjectRefData *data) { m_refData = data; }


    void Ref(const wxObject& clone);


    void UnRef();


    void UnShare() { AllocExclusive(); }


    bool IsSameAs(const wxObject& o) const { return m_refData == o.m_refData; }

protected:



    void AllocExclusive();





    virtual wxObjectRefData *CreateRefData() const;


    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    wxObjectRefData *m_refData;
};

inline wxObject *wxCheckDynamicCast(wxObject *obj, wxClassInfo *classInfo)
{
    return obj && obj->GetClassInfo()->IsKindOf(classInfo) ? obj : 
# 450 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 3 4
                                                                  __null
# 450 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h"
                                                                      ;
}

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/xti2.h" 1
# 454 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/object.h" 2
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 1
# 68 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stddef.h" 2 3 4
# 69 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 2



struct _wxHashTable_NodeBase
{
    _wxHashTable_NodeBase() : m_next(
# 74 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
                                    __null
# 74 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
                                        ) {}

    _wxHashTable_NodeBase* m_next;




};


class _wxHashTableBase2
{
public:
    typedef void (*NodeDtor)(_wxHashTable_NodeBase*);
    typedef unsigned long (*BucketFromNode)(_wxHashTableBase2*,_wxHashTable_NodeBase*);
    typedef _wxHashTable_NodeBase* (*ProcessNode)(_wxHashTable_NodeBase*);
protected:
    static _wxHashTable_NodeBase* DummyProcessNode(_wxHashTable_NodeBase* node);
    static void DeleteNodes( size_t buckets, _wxHashTable_NodeBase** table,
                             NodeDtor dtor );
    static _wxHashTable_NodeBase* GetFirstNode( size_t buckets,
                                                _wxHashTable_NodeBase** table )
    {
        for( size_t i = 0; i < buckets; ++i )
            if( table[i] )
                return table[i];
        return 
# 100 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
              __null
# 100 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
                  ;
    }


    enum { prime_count = 31 };
    static const unsigned long ms_primes[prime_count];


    static unsigned long GetNextPrime( unsigned long n );



    static unsigned long GetPreviousPrime( unsigned long n );

    static void CopyHashTable( _wxHashTable_NodeBase** srcTable,
                               size_t srcBuckets, _wxHashTableBase2* dst,
                               _wxHashTable_NodeBase** dstTable,
                               BucketFromNode func, ProcessNode proc );

    static void** AllocTable( size_t sz )
    {
        return (void **)calloc(sz, sizeof(void*));
    }
    static void FreeTable(void *table)
    {
        free(table);
    }
};
# 465 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
inline bool never_grow( size_t, size_t ) { return false; }
inline bool never_shrink( size_t, size_t ) { return false; }
inline bool grow_lf70( size_t buckets, size_t items )
{
    return float(items)/float(buckets) >= 0.85f;
}
# 530 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
struct wxIntegerHash
{
    wxIntegerHash() { }
    unsigned long operator()( long x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned long x ) const { return x; }
    unsigned long operator()( int x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned int x ) const { return x; }
    unsigned long operator()( short x ) const { return (unsigned long)x; }
    unsigned long operator()( unsigned short x ) const { return x; }

    unsigned long long operator()( long long x ) const { return static_cast<unsigned long long>(x); }
    unsigned long long operator()( unsigned long long x ) const { return x; }


    wxIntegerHash& operator=(const wxIntegerHash&) { return *this; }
};



struct wxIntegerEqual
{
    wxIntegerEqual() { }
    bool operator()( long a, long b ) const { return a == b; }
    bool operator()( unsigned long a, unsigned long b ) const { return a == b; }
    bool operator()( int a, int b ) const { return a == b; }
    bool operator()( unsigned int a, unsigned int b ) const { return a == b; }
    bool operator()( short a, short b ) const { return a == b; }
    bool operator()( unsigned short a, unsigned short b ) const { return a == b; }

    bool operator()( long long a, long long b ) const { return a == b; }
    bool operator()( unsigned long long a, unsigned long long b ) const { return a == b; }


    wxIntegerEqual& operator=(const wxIntegerEqual&) { return *this; }
};


struct wxPointerHash
{
    wxPointerHash() { }


    wxUIntPtr operator()( const void* k ) const { return wxPtrToUInt(k); }




    wxPointerHash& operator=(const wxPointerHash&) { return *this; }
};

struct wxPointerEqual
{
    wxPointerEqual() { }
    bool operator()( const void* a, const void* b ) const { return a == b; }

    wxPointerEqual& operator=(const wxPointerEqual&) { return *this; }
};


struct wxStringHash
{
    wxStringHash() {}
    unsigned long operator()( const wxString& x ) const
        { return stringHash( x.wx_str() ); }
    unsigned long operator()( const wchar_t* x ) const
        { return stringHash( x ); }
    unsigned long operator()( const char* x ) const
        { return stringHash( x ); }


    static unsigned long wxCharStringHash( const wxChar* x )
        { return stringHash(x); }

    static unsigned long charStringHash( const char* x )
        { return stringHash(x); }



    static unsigned long stringHash( const wchar_t* );
    static unsigned long stringHash( const char* );

    wxStringHash& operator=(const wxStringHash&) { return *this; }
};

struct wxStringEqual
{
    wxStringEqual() {}
    bool operator()( const wxString& a, const wxString& b ) const
        { return a == b; }
    bool operator()( const wxChar* a, const wxChar* b ) const
        { return wxStrcmp( a, b ) == 0; }

    bool operator()( const char* a, const char* b ) const
        { return strcmp( a, b ) == 0; }


    wxStringEqual& operator=(const wxStringEqual&) { return *this; }
};
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
class wxLongToLongHashMap_wxImplementation_Pair { public: typedef long first_type; typedef long second_type; typedef long t1; typedef long t2; typedef const long const_t1; typedef const long const_t2; wxLongToLongHashMap_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxLongToLongHashMap_wxImplementation_KeyEx { typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxLongToLongHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxLongToLongHashMap_wxImplementation_KeyEx& operator=(const wxLongToLongHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxLongToLongHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef long key_type; typedef wxLongToLongHashMap_wxImplementation_Pair value_type; typedef wxIntegerHash hasher; typedef wxIntegerEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const long const_key_type; typedef const wxLongToLongHashMap_wxImplementation_Pair const_mapped_type; public: typedef wxLongToLongHashMap_wxImplementation_KeyEx key_extractor; typedef wxLongToLongHashMap_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_ht(
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxLongToLongHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxLongToLongHashMap_wxImplementation_HashTable( const Self& ht ) : m_table(
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxLongToLongHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } iterator end() { return iterator(
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 746 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxLongToLongHashMap:public wxLongToLongHashMap_wxImplementation_HashTable { public: typedef long mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxLongToLongHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxLongToLongHashMap_wxImplementation_HashTable( hint, hf, eq, wxLongToLongHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxLongToLongHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxLongToLongHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } }
                                                                            ;

class wxStringToStringHashMap_wxImplementation_Pair { public: typedef wxString first_type; typedef wxString second_type; typedef wxString t1; typedef wxString t2; typedef const wxString const_t1; typedef const wxString const_t2; wxStringToStringHashMap_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxStringToStringHashMap_wxImplementation_KeyEx { typedef wxString key_type; typedef wxStringToStringHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxStringToStringHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxStringToStringHashMap_wxImplementation_KeyEx& operator=(const wxStringToStringHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxStringToStringHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxStringToStringHashMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxStringToStringHashMap_wxImplementation_Pair const_mapped_type; public: typedef wxStringToStringHashMap_wxImplementation_KeyEx key_extractor; typedef wxStringToStringHashMap_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_ht(
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxStringToStringHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxStringToStringHashMap_wxImplementation_HashTable( const Self& ht ) : m_table(
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxStringToStringHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } iterator end() { return iterator(
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 749 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxStringToStringHashMap:public wxStringToStringHashMap_wxImplementation_HashTable { public: typedef wxString mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxStringToStringHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxStringToStringHashMap_wxImplementation_HashTable( hint, hf, eq, wxStringToStringHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxStringToStringHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxStringToStringHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxStringToStringHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } }
                                                              ;

class wxStringToNumHashMap_wxImplementation_Pair { public: typedef wxString first_type; typedef wxUIntPtr second_type; typedef wxString t1; typedef wxUIntPtr t2; typedef const wxString const_t1; typedef const wxUIntPtr const_t2; wxStringToNumHashMap_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxStringToNumHashMap_wxImplementation_KeyEx { typedef wxString key_type; typedef wxStringToNumHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxStringToNumHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxStringToNumHashMap_wxImplementation_KeyEx& operator=(const wxStringToNumHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxStringToNumHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxStringToNumHashMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxStringToNumHashMap_wxImplementation_Pair const_mapped_type; public: typedef wxStringToNumHashMap_wxImplementation_KeyEx key_extractor; typedef wxStringToNumHashMap_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_ht(
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxStringToNumHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxStringToNumHashMap_wxImplementation_HashTable( const Self& ht ) : m_table(
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxStringToNumHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } iterator end() { return iterator(
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h" 3 4
__null
# 752 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/hashmap.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxStringToNumHashMap:public wxStringToNumHashMap_wxImplementation_HashTable { public: typedef wxUIntPtr mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxStringToNumHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxStringToNumHashMap_wxImplementation_HashTable( hint, hf, eq, wxStringToNumHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxStringToNumHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxStringToNumHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxStringToNumHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } }
                                                              ;
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 2

typedef int (*wxShadowObjectMethod)(void*, void*);
class wxShadowObjectMethods_wxImplementation_Pair { public: typedef wxString first_type; typedef wxShadowObjectMethod second_type; typedef wxString t1; typedef wxShadowObjectMethod t2; typedef const wxString const_t1; typedef const wxShadowObjectMethod const_t2; wxShadowObjectMethods_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxShadowObjectMethods_wxImplementation_KeyEx { typedef wxString key_type; typedef wxShadowObjectMethods_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxShadowObjectMethods_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxShadowObjectMethods_wxImplementation_KeyEx& operator=(const wxShadowObjectMethods_wxImplementation_KeyEx&) { return *this; } }; class wxShadowObjectMethods_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxShadowObjectMethods_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxShadowObjectMethods_wxImplementation_Pair const_mapped_type; public: typedef wxShadowObjectMethods_wxImplementation_KeyEx key_extractor; typedef wxShadowObjectMethods_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
), m_ht(
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxShadowObjectMethods_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxShadowObjectMethods_wxImplementation_HashTable( const Self& ht ) : m_table(
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxShadowObjectMethods_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
, this); } iterator end() { return iterator(
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxShadowObjectMethods:public wxShadowObjectMethods_wxImplementation_HashTable { public: typedef wxShadowObjectMethod mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxShadowObjectMethods( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxShadowObjectMethods_wxImplementation_HashTable( hint, hf, eq, wxShadowObjectMethods_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxShadowObjectMethods_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxShadowObjectMethods_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxShadowObjectMethods_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } }



 ;
class wxShadowObjectFields_wxImplementation_Pair { public: typedef wxString first_type; typedef void * second_type; typedef wxString t1; typedef void * t2; typedef const wxString const_t1; typedef const void * const_t2; wxShadowObjectFields_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxShadowObjectFields_wxImplementation_KeyEx { typedef wxString key_type; typedef wxShadowObjectFields_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxShadowObjectFields_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxShadowObjectFields_wxImplementation_KeyEx& operator=(const wxShadowObjectFields_wxImplementation_KeyEx&) { return *this; } }; class wxShadowObjectFields_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxShadowObjectFields_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxShadowObjectFields_wxImplementation_Pair const_mapped_type; public: typedef wxShadowObjectFields_wxImplementation_KeyEx key_extractor; typedef wxShadowObjectFields_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
), m_ht(
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxShadowObjectFields_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxShadowObjectFields_wxImplementation_HashTable( const Self& ht ) : m_table(
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxShadowObjectFields_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
, this); } iterator end() { return iterator(
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
__null
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxShadowObjectFields:public wxShadowObjectFields_wxImplementation_HashTable { public: typedef void * mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxShadowObjectFields( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxShadowObjectFields_wxImplementation_HashTable( hint, hf, eq, wxShadowObjectFields_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxShadowObjectFields_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxShadowObjectFields_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxShadowObjectFields_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } }



 ;

class wxShadowObject
{
public:
    wxShadowObject() { }

    void AddMethod( const wxString &name, wxShadowObjectMethod method )
    {
        wxShadowObjectMethods::iterator it = m_methods.find( name );
        if (it == m_methods.end())
            m_methods[ name ] = method;
        else
            it->second = method;
    }

    bool InvokeMethod( const wxString &name, void* window, void* param, int* returnValue )
    {
        wxShadowObjectMethods::iterator it = m_methods.find( name );
        if (it == m_methods.end())
            return false;
        wxShadowObjectMethod method = it->second;
        int ret = (*method)(window, param);
        if (returnValue)
            *returnValue = ret;
        return true;
    }

    void AddField( const wxString &name, void* initialValue = 
# 56 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
                                                             __null 
# 56 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
                                                                  )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            m_fields[ name ] = initialValue;
        else
            it->second = initialValue;
    }

    void SetField( const wxString &name, void* value )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            return;
        it->second = value;
    }

    void* GetField( const wxString &name, void *defaultValue = 
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h" 3 4
                                                              __null 
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
                                                                   )
    {
        wxShadowObjectFields::iterator it = m_fields.find( name );
        if (it == m_fields.end())
            return defaultValue;
        return it->second;
    }

private:
    wxShadowObjectMethods m_methods;
    wxShadowObjectFields m_fields;
};





enum wxClientDataType
{
    wxClientData_None,
    wxClientData_Object,
    wxClientData_Void
};

class wxClientData
{
public:
    wxClientData() { }
    virtual ~wxClientData() { }
};

class wxStringClientData : public wxClientData
{
public:
    wxStringClientData() : m_data() { }
    wxStringClientData( const wxString &data ) : m_data(data) { }
    void SetData( const wxString &data ) { m_data = data; }
    const wxString& GetData() const { return m_data; }

private:
    wxString m_data;
};
# 125 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/clntdata.h"
class wxClientDataContainer
{
public:
    wxClientDataContainer();
    virtual ~wxClientDataContainer();

    void SetClientObject( wxClientData *data ) { DoSetClientObject(data); }
    wxClientData *GetClientObject() const { return DoGetClientObject(); }

    void SetClientData( void *data ) { DoSetClientData(data); }
    void *GetClientData() const { return DoGetClientData(); }

protected:





    union
    {
        wxClientData *m_clientObject;
        void *m_clientData;
    };


    virtual void DoSetClientObject( wxClientData *data );
    virtual wxClientData *DoGetClientObject() const;

    virtual void DoSetClientData( void *data );
    virtual void *DoGetClientData() const;


    wxClientDataType m_clientDataType;

};
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 1
# 34 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 1
# 31 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h" 1
# 23 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/except.h" 1
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h" 2
# 53 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h"
namespace wxPrivate
{



    template <class ScopeGuardImpl>
    void OnScopeExit(ScopeGuardImpl& guard)
    {
        if ( !guard.WasDismissed() )
        {

            try
            {
                guard.Execute();
            }
            catch ( ... ) { ; }
        }
    }


    template <class T>
    void Use(const T& )
    {
    }
}
# 92 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h"
class wxScopeGuardImplBase
{
public:
    wxScopeGuardImplBase() : m_wasDismissed(false) { }

    wxScopeGuardImplBase(const wxScopeGuardImplBase& other)
        : m_wasDismissed(other.m_wasDismissed)
    {
        other.Dismiss();
    }

    void Dismiss() const { m_wasDismissed = true; }


    bool WasDismissed() const { return m_wasDismissed; }

protected:
    ~wxScopeGuardImplBase() { }


    mutable bool m_wasDismissed;

private:
    wxScopeGuardImplBase& operator=(const wxScopeGuardImplBase&);
};


typedef const wxScopeGuardImplBase& wxScopeGuard;





template <class F>
class wxScopeGuardImpl0 : public wxScopeGuardImplBase
{
public:
    static wxScopeGuardImpl0<F> MakeGuard(F fun)
    {
        return wxScopeGuardImpl0<F>(fun);
    }

    ~wxScopeGuardImpl0() { wxPrivate::OnScopeExit(*this); }

    void Execute() { m_fun(); }

protected:
    wxScopeGuardImpl0(F fun) : m_fun(fun) { }

    F m_fun;

    wxScopeGuardImpl0& operator=(const wxScopeGuardImpl0&);
};

template <class F>
inline wxScopeGuardImpl0<F> wxMakeGuard(F fun)
{
    return wxScopeGuardImpl0<F>::MakeGuard(fun);
}





template <class F, class P1>
class wxScopeGuardImpl1 : public wxScopeGuardImplBase
{
public:
    static wxScopeGuardImpl1<F, P1> MakeGuard(F fun, P1 p1)
    {
        return wxScopeGuardImpl1<F, P1>(fun, p1);
    }

    ~wxScopeGuardImpl1() { wxPrivate::OnScopeExit(* this); }

    void Execute() { m_fun(m_p1); }

protected:
    wxScopeGuardImpl1(F fun, P1 p1) : m_fun(fun), m_p1(p1) { }

    F m_fun;
    const P1 m_p1;

    wxScopeGuardImpl1& operator=(const wxScopeGuardImpl1&);
};

template <class F, class P1>
inline wxScopeGuardImpl1<F, P1> wxMakeGuard(F fun, P1 p1)
{
    return wxScopeGuardImpl1<F, P1>::MakeGuard(fun, p1);
}





template <class F, class P1, class P2>
class wxScopeGuardImpl2 : public wxScopeGuardImplBase
{
public:
    static wxScopeGuardImpl2<F, P1, P2> MakeGuard(F fun, P1 p1, P2 p2)
    {
        return wxScopeGuardImpl2<F, P1, P2>(fun, p1, p2);
    }

    ~wxScopeGuardImpl2() { wxPrivate::OnScopeExit(*this); }

    void Execute() { m_fun(m_p1, m_p2); }

protected:
    wxScopeGuardImpl2(F fun, P1 p1, P2 p2) : m_fun(fun), m_p1(p1), m_p2(p2) { }

    F m_fun;
    const P1 m_p1;
    const P2 m_p2;

    wxScopeGuardImpl2& operator=(const wxScopeGuardImpl2&);
};

template <class F, class P1, class P2>
inline wxScopeGuardImpl2<F, P1, P2> wxMakeGuard(F fun, P1 p1, P2 p2)
{
    return wxScopeGuardImpl2<F, P1, P2>::MakeGuard(fun, p1, p2);
}





template <class F, class P1, class P2, class P3>
class wxScopeGuardImpl3 : public wxScopeGuardImplBase
{
public:
    static wxScopeGuardImpl3<F, P1, P2, P3> MakeGuard(F fun, P1 p1, P2 p2, P3 p3)
    {
        return wxScopeGuardImpl3<F, P1, P2, P3>(fun, p1, p2, p3);
    }

    ~wxScopeGuardImpl3() { wxPrivate::OnScopeExit(*this); }

    void Execute() { m_fun(m_p1, m_p2, m_p3); }

protected:
    wxScopeGuardImpl3(F fun, P1 p1, P2 p2, P3 p3)
        : m_fun(fun), m_p1(p1), m_p2(p2), m_p3(p3) { }

    F m_fun;
    const P1 m_p1;
    const P2 m_p2;
    const P3 m_p3;

    wxScopeGuardImpl3& operator=(const wxScopeGuardImpl3&);
};

template <class F, class P1, class P2, class P3>
inline wxScopeGuardImpl3<F, P1, P2, P3> wxMakeGuard(F fun, P1 p1, P2 p2, P3 p3)
{
    return wxScopeGuardImpl3<F, P1, P2, P3>::MakeGuard(fun, p1, p2, p3);
}
# 260 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h"
template <class Obj, class MemFun>
class wxObjScopeGuardImpl0 : public wxScopeGuardImplBase
{
public:
    static wxObjScopeGuardImpl0<Obj, MemFun>
        MakeObjGuard(Obj& obj, MemFun memFun)
    {
        return wxObjScopeGuardImpl0<Obj, MemFun>(obj, memFun);
    }

    ~wxObjScopeGuardImpl0() { wxPrivate::OnScopeExit(*this); }

    void Execute() { (m_obj.*m_memfun)(); }

protected:
    wxObjScopeGuardImpl0(Obj& obj, MemFun memFun)
        : m_obj(obj), m_memfun(memFun) { }

    Obj& m_obj;
    MemFun m_memfun;
};

template <class Obj, class MemFun>
inline wxObjScopeGuardImpl0<Obj, MemFun> wxMakeObjGuard(Obj& obj, MemFun memFun)
{
    return wxObjScopeGuardImpl0<Obj, MemFun>::MakeObjGuard(obj, memFun);
}

template <class Obj, class MemFun, class P1>
class wxObjScopeGuardImpl1 : public wxScopeGuardImplBase
{
public:
    static wxObjScopeGuardImpl1<Obj, MemFun, P1>
        MakeObjGuard(Obj& obj, MemFun memFun, P1 p1)
    {
        return wxObjScopeGuardImpl1<Obj, MemFun, P1>(obj, memFun, p1);
    }

    ~wxObjScopeGuardImpl1() { wxPrivate::OnScopeExit(*this); }

    void Execute() { (m_obj.*m_memfun)(m_p1); }

protected:
    wxObjScopeGuardImpl1(Obj& obj, MemFun memFun, P1 p1)
        : m_obj(obj), m_memfun(memFun), m_p1(p1) { }

    Obj& m_obj;
    MemFun m_memfun;
    const P1 m_p1;
};

template <class Obj, class MemFun, class P1>
inline wxObjScopeGuardImpl1<Obj, MemFun, P1>
wxMakeObjGuard(Obj& obj, MemFun memFun, P1 p1)
{
    return wxObjScopeGuardImpl1<Obj, MemFun, P1>::MakeObjGuard(obj, memFun, p1);
}

template <class Obj, class MemFun, class P1, class P2>
class wxObjScopeGuardImpl2 : public wxScopeGuardImplBase
{
public:
    static wxObjScopeGuardImpl2<Obj, MemFun, P1, P2>
        MakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2)
    {
        return wxObjScopeGuardImpl2<Obj, MemFun, P1, P2>(obj, memFun, p1, p2);
    }

    ~wxObjScopeGuardImpl2() { wxPrivate::OnScopeExit(*this); }

    void Execute() { (m_obj.*m_memfun)(m_p1, m_p2); }

protected:
    wxObjScopeGuardImpl2(Obj& obj, MemFun memFun, P1 p1, P2 p2)
        : m_obj(obj), m_memfun(memFun), m_p1(p1), m_p2(p2) { }

    Obj& m_obj;
    MemFun m_memfun;
    const P1 m_p1;
    const P2 m_p2;
};

template <class Obj, class MemFun, class P1, class P2>
inline wxObjScopeGuardImpl2<Obj, MemFun, P1, P2>
wxMakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2)
{
    return wxObjScopeGuardImpl2<Obj, MemFun, P1, P2>::
                                            MakeObjGuard(obj, memFun, p1, p2);
}

template <class Obj, class MemFun, class P1, class P2, class P3>
class wxObjScopeGuardImpl3 : public wxScopeGuardImplBase
{
public:
    static wxObjScopeGuardImpl3<Obj, MemFun, P1, P2, P3>
        MakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2, P3 p3)
    {
        return wxObjScopeGuardImpl3<Obj, MemFun, P1, P2, P3>(obj, memFun, p1, p2, p3);
    }

    ~wxObjScopeGuardImpl3() { wxPrivate::OnScopeExit(*this); }

    void Execute() { (m_obj.*m_memfun)(m_p1, m_p2, m_p3); }

protected:
    wxObjScopeGuardImpl3(Obj& obj, MemFun memFun, P1 p1, P2 p2, P3 p3)
        : m_obj(obj), m_memfun(memFun), m_p1(p1), m_p2(p2), m_p3(p3) { }

    Obj& m_obj;
    MemFun m_memfun;
    const P1 m_p1;
    const P2 m_p2;
    const P3 m_p3;
};

template <class Obj, class MemFun, class P1, class P2, class P3>
inline wxObjScopeGuardImpl3<Obj, MemFun, P1, P2, P3>
wxMakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2, P3 p3)
{
    return wxObjScopeGuardImpl3<Obj, MemFun, P1, P2, P3>::
                                        MakeObjGuard(obj, memFun, p1, p2, p3);
}






namespace wxPrivate
{


class VariableSetterBase : public wxScopeGuardImplBase { };

typedef const VariableSetterBase& VariableSetter;

template <typename T, typename U>
class VariableSetterImpl : public VariableSetterBase
{
public:
    VariableSetterImpl(T& var, U value)
        : m_var(var),
          m_value(value)
    {
    }

    ~VariableSetterImpl() { wxPrivate::OnScopeExit(*this); }

    void Execute() { m_var = m_value; }

private:
    T& m_var;
    const U m_value;


    VariableSetterImpl<T, U>& operator=(const VariableSetterImpl<T, U>&);
};

template <typename T>
class VariableNullerImpl : public VariableSetterBase
{
public:
    VariableNullerImpl(T& var)
        : m_var(var)
    {
    }

    ~VariableNullerImpl() { wxPrivate::OnScopeExit(*this); }

    void Execute() { m_var = 
# 429 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h" 3 4
                            __null
# 429 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopeguard.h"
                                ; }

private:
    T& m_var;

    VariableNullerImpl<T>& operator=(const VariableNullerImpl<T>&);
};

}

template <typename T, typename U>
inline
wxPrivate::VariableSetterImpl<T, U> wxMakeVarSetter(T& var, U value)
{
      return wxPrivate::VariableSetterImpl<T, U>(var, value);
}




template <typename T>
inline
wxPrivate::VariableNullerImpl<T> wxMakeVarNuller(T& var)
{
    return wxPrivate::VariableNullerImpl<T>(var);
}
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/movable.h" 1
# 13 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/movable.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/pod.h" 1
# 33 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/pod.h"
template<typename T>
struct wxIsPod
{
    static const bool value = false;
};
# 47 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/pod.h"
template<> struct wxIsPod<bool> { static const bool value = true; };
template<> struct wxIsPod<unsigned char> { static const bool value = true; };
template<> struct wxIsPod<signed char> { static const bool value = true; };
template<> struct wxIsPod<unsigned int> { static const bool value = true; };
template<> struct wxIsPod<signed int> { static const bool value = true; };
template<> struct wxIsPod<unsigned short int> { static const bool value = true; };
template<> struct wxIsPod<signed short int> { static const bool value = true; };
template<> struct wxIsPod<signed long int> { static const bool value = true; };
template<> struct wxIsPod<unsigned long int> { static const bool value = true; };
template<> struct wxIsPod<float> { static const bool value = true; };
template<> struct wxIsPod<double> { static const bool value = true; };
template<> struct wxIsPod<long double> { static const bool value = true; };

template<> struct wxIsPod<wchar_t> { static const bool value = true; };


template<> struct wxIsPod<long long> { static const bool value = true; };
template<> struct wxIsPod<unsigned long long> { static const bool value = true; };
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/pod.h"
template<typename T>
struct wxIsPod<T*>
{
    static const bool value = true;
};

template<typename T>
struct wxIsPod<const T*>
{
    static const bool value = true;
};
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/movable.h" 2






template<typename T>
struct wxIsMovable
{
    static const bool value = wxIsPod<T>::value;
};
# 33 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/if.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/if.h"
namespace wxPrivate
{

template <bool Cond>
struct wxIfImpl
# 35 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/if.h"
;


template <>
struct wxIfImpl<true>
{
    template<typename TTrue, typename TFalse> struct Result
    {
        typedef TTrue value;
    };
};


template<>
struct wxIfImpl<false>
{
    template<typename TTrue, typename TFalse> struct Result
    {
        typedef TFalse value;
    };
};

}






template<bool Cond, typename TTrue, typename TFalse>
struct wxIf
{
    typedef typename wxPrivate::wxIfImpl<Cond>
                     ::template Result<TTrue, TFalse>::value
            value;
};
# 34 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/beforestd.h" 1
# 36 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 2
# 38 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 2



typedef int (*wxSortCallback)(const void* pItem1,
                              const void* pItem2,
                              const void* user_data);
 void wxQsort(void* pbase, size_t total_elems,
                              size_t size, wxSortCallback cmp,
                              const void* user_data);

namespace wxPrivate
{






template<typename T>
struct wxVectorMemOpsMovable
{
    static void Free(T* array)
        { free(array); }

    static T* Realloc(T* old, size_t newCapacity, size_t )
        { return (T*)realloc(old, newCapacity * sizeof(T)); }

    static void MemmoveBackward(T* dest, T* source, size_t count)
        { memmove(dest, source, count * sizeof(T)); }

    static void MemmoveForward(T* dest, T* source, size_t count)
        { memmove(dest, source, count * sizeof(T)); }
};


template<typename T>
struct wxVectorMemOpsGeneric
{
    static void Free(T* array)
        { ::operator delete(array); }

    static T* Realloc(T* old, size_t newCapacity, size_t occupiedSize)
    {
        T *mem = (T*)::operator new(newCapacity * sizeof(T));
        for ( size_t i = 0; i < occupiedSize; i++ )
        {
            ::new(mem + i) T(old[i]);
            old[i].~T();
        }
        ::operator delete(old);
        return mem;
    }

    static void MemmoveBackward(T* dest, T* source, size_t count)
    {
        do { if ( wxTheAssertHandler && !(dest < source) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h", 93, __FUNCTION__, "dest < source", (const char*)
# 93 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
       __null
# 93 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        T* destptr = dest;
        T* sourceptr = source;
        for ( size_t i = count; i > 0; --i, ++destptr, ++sourceptr )
        {
            ::new(destptr) T(*sourceptr);
            sourceptr->~T();
        }
    }

    static void MemmoveForward(T* dest, T* source, size_t count)
    {
        do { if ( wxTheAssertHandler && !(dest > source) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h", 105, __FUNCTION__, "dest > source", (const char*)
# 105 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
       __null
# 105 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        T* destptr = dest + count - 1;
        T* sourceptr = source + count - 1;
        for ( size_t i = count; i > 0; --i, --destptr, --sourceptr )
        {
            ::new(destptr) T(*sourceptr);
            sourceptr->~T();
        }
    }
};


}

template<typename T>
class wxVector
{
private:
# 132 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
    typedef typename wxIf< (wxIsMovable<T>::value),
                           wxPrivate::wxVectorMemOpsMovable<T>,
                           wxPrivate::wxVectorMemOpsGeneric<T> >::value
            Ops;

public:
    typedef size_t size_type;
    typedef size_t difference_type;
    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    class reverse_iterator
    {
    public:
        reverse_iterator() : m_ptr(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                  __null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                      ) { }
        explicit reverse_iterator(iterator it) : m_ptr(it) { }
        reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { }

        reference operator*() const { return *m_ptr; }
        pointer operator->() const { return m_ptr; }

        iterator base() const { return m_ptr; }

        reverse_iterator& operator++()
            { --m_ptr; return *this; }
        reverse_iterator operator++(int)
            { reverse_iterator tmp = *this; --m_ptr; return tmp; }
        reverse_iterator& operator--()
            { ++m_ptr; return *this; }
        reverse_iterator operator--(int)
            { reverse_iterator tmp = *this; ++m_ptr; return tmp; }

        reverse_iterator operator+(difference_type n) const
            { return reverse_iterator(m_ptr - n); }
        reverse_iterator& operator+=(difference_type n)
            { m_ptr -= n; return *this; }
        reverse_iterator operator-(difference_type n) const
            { return reverse_iterator(m_ptr + n); }
        reverse_iterator& operator-=(difference_type n)
            { m_ptr += n; return *this; }

        reference operator[](difference_type n) const
            { return *(*this + n); }

        bool operator ==(const reverse_iterator& it) const
            { return m_ptr == it.m_ptr; }
        bool operator !=(const reverse_iterator& it) const
            { return m_ptr != it.m_ptr; }

    private:
        value_type *m_ptr;

        friend class const_reverse_iterator;
    };

    class const_reverse_iterator
    {
    public:
        const_reverse_iterator() : m_ptr(
# 195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                        __null
# 195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                            ) { }
        explicit const_reverse_iterator(const_iterator it) : m_ptr(it) { }
        const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { }
        const_reverse_iterator(const const_reverse_iterator& it) : m_ptr(it.m_ptr) { }

        const_reference operator*() const { return *m_ptr; }
        const_pointer operator->() const { return m_ptr; }

        const_iterator base() const { return m_ptr; }

        const_reverse_iterator& operator++()
            { --m_ptr; return *this; }
        const_reverse_iterator operator++(int)
            { const_reverse_iterator tmp = *this; --m_ptr; return tmp; }
        const_reverse_iterator& operator--()
            { ++m_ptr; return *this; }
        const_reverse_iterator operator--(int)
            { const_reverse_iterator tmp = *this; ++m_ptr; return tmp; }

        const_reverse_iterator operator+(difference_type n) const
            { return const_reverse_iterator(m_ptr - n); }
        const_reverse_iterator& operator+=(difference_type n)
            { m_ptr -= n; return *this; }
        const_reverse_iterator operator-(difference_type n) const
            { return const_reverse_iterator(m_ptr + n); }
        const_reverse_iterator& operator-=(difference_type n)
            { m_ptr += n; return *this; }

        const_reference operator[](difference_type n) const
            { return *(*this + n); }

        bool operator ==(const const_reverse_iterator& it) const
            { return m_ptr == it.m_ptr; }
        bool operator !=(const const_reverse_iterator& it) const
            { return m_ptr != it.m_ptr; }

    protected:
        const value_type *m_ptr;
    };

    wxVector() : m_size(0), m_capacity(0), m_values(
# 235 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                                   __null
# 235 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                       ) {}

    wxVector(size_type p_size)
        : m_size(0), m_capacity(0), m_values(
# 238 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                            __null
# 238 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                )
    {
        reserve(p_size);
        for ( size_t n = 0; n < p_size; n++ )
            push_back(value_type());
    }

    wxVector(size_type p_size, const value_type& v)
        : m_size(0), m_capacity(0), m_values(
# 246 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                            __null
# 246 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                )
    {
        reserve(p_size);
        for ( size_t n = 0; n < p_size; n++ )
            push_back(v);
    }

    wxVector(const wxVector& c) : m_size(0), m_capacity(0), m_values(
# 253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                                                    __null
# 253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                                        )
    {
        Copy(c);
    }

    template <class InputIterator>
    wxVector(InputIterator first, InputIterator last)
        : m_size(0), m_capacity(0), m_values(
# 260 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                            __null
# 260 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                )
    {
        assign(first, last);
    }

    ~wxVector()
    {
        clear();
    }

    void assign(size_type p_size, const value_type& v)
    {
        clear();
        reserve(p_size);
        for ( size_t n = 0; n < p_size; n++ )
            push_back(v);
    }

    template <class InputIterator>
    void assign(InputIterator first, InputIterator last)
    {
        clear();





        for ( InputIterator it = first; it != last; ++it )
            push_back(*it);
    }

    void swap(wxVector& v)
    {
        wxSwap(m_size, v.m_size);
        wxSwap(m_capacity, v.m_capacity);
        wxSwap(m_values, v.m_values);
    }

    void clear()
    {

        for ( size_type i = 0; i < m_size; i++ )
        {
            m_values[i].~T();
        }

        Ops::Free(m_values);
        m_values = 
# 307 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                  __null
# 307 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                      ;
        m_size =
        m_capacity = 0;
    }

    void reserve(size_type n)
    {
        if ( n <= m_capacity )
            return;






        const size_type increment = m_size > 0
                                     ? m_size < ALLOC_MAX_SIZE
                                        ? m_size
                                        : (size_type)ALLOC_MAX_SIZE
                                     : (size_type)ALLOC_INITIAL_SIZE;
        if ( m_capacity + increment > n )
            n = m_capacity + increment;

        m_values = Ops::Realloc(m_values, n, m_size);
        m_capacity = n;
    }

    void resize(size_type n)
    {
        if ( n < m_size )
            Shrink(n);
        else if ( n > m_size )
            Extend(n, value_type());
    }

    void resize(size_type n, const value_type& v)
    {
        if ( n < m_size )
            Shrink(n);
        else if ( n > m_size )
            Extend(n, v);
    }

    size_type size() const
    {
        return m_size;
    }

    size_type capacity() const
    {
        return m_capacity;
    }

    bool empty() const
    {
        return size() == 0;
    }

    wxVector& operator=(const wxVector& vb)
    {
        if (this != &vb)
        {
            clear();
            Copy(vb);
        }
        return *this;
    }

    void push_back(const value_type& v)
    {
        reserve(size() + 1);



        void* const place = m_values + m_size;
        ::new(place) value_type(v);





        m_size++;
    }

    void pop_back()
    {
        erase(end() - 1);
    }

    const value_type& at(size_type idx) const
    {
        do { if ( wxTheAssertHandler && !(idx < m_size) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h", 398, __FUNCTION__, "idx < m_size", (const char*)
# 398 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
       __null
# 398 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return m_values[idx];
    }

    value_type& at(size_type idx)
    {
        do { if ( wxTheAssertHandler && !(idx < m_size) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h", 404, __FUNCTION__, "idx < m_size", (const char*)
# 404 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
       __null
# 404 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return m_values[idx];
    }

    const value_type& operator[](size_type idx) const { return at(idx); }
    value_type& operator[](size_type idx) { return at(idx); }
    const value_type& front() const { return at(0); }
    value_type& front() { return at(0); }
    const value_type& back() const { return at(size() - 1); }
    value_type& back() { return at(size() - 1); }

    const_iterator begin() const { return m_values; }
    iterator begin() { return m_values; }
    const_iterator end() const { return m_values + size(); }
    iterator end() { return m_values + size(); }

    reverse_iterator rbegin() { return reverse_iterator(end() - 1); }
    reverse_iterator rend() { return reverse_iterator(begin() - 1); }

    const_reverse_iterator rbegin() const { return const_reverse_iterator(end() - 1); }
    const_reverse_iterator rend() const { return const_reverse_iterator(begin() - 1); }

    iterator insert(iterator it, const value_type& v = value_type())
    {


        const size_t idx = it - begin();
        const size_t after = end() - it;

        reserve(size() + 1);


        value_type * const place = m_values + idx;



        if ( after > 0 )
            Ops::MemmoveForward(place + 1, place, after);



        wxScopeGuard moveBack = wxMakeGuard(
                Ops::MemmoveBackward, place, place + 1, after);
        if ( !after )
            moveBack.Dismiss();



        ::new(place) value_type(v);



        moveBack.Dismiss();
        m_size++;

        return begin() + idx;
    }

    iterator erase(iterator it)
    {
        return erase(it, it + 1);
    }

    iterator erase(iterator first, iterator last)
    {
        if ( first == last )
            return first;
        do { if ( wxTheAssertHandler && !(first < end() && last <= end()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h", 471, __FUNCTION__, "first < end() && last <= end()", (const char*)
# 471 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
       __null
# 471 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        const size_type idx = first - begin();
        const size_type count = last - first;
        const size_type after = end() - last;


        for ( iterator i = first; i < last; ++i )
            i->~T();


        if ( after > 0 )
        {
            Ops::MemmoveBackward(m_values + idx, m_values + idx + count, after);
        }

        m_size -= count;

        return begin() + idx;
    }


    __attribute__((deprecated)) size_type erase(size_type n);


private:

    enum { ALLOC_INITIAL_SIZE = 16 };
    enum { ALLOC_MAX_SIZE = 4096 };

    void Copy(const wxVector& vb)
    {
        reserve(vb.size());

        for ( const_iterator i = vb.begin(); i != vb.end(); ++i )
            push_back(*i);
    }

private:
    void Shrink(size_type n)
    {
        for ( size_type i = n; i < m_size; i++ )
            m_values[i].~T();
        m_size = n;
    }

    void Extend(size_type n, const value_type& v)
    {
        reserve(n);
        for ( size_type i = m_size; i < n; i++ )
            push_back(v);
    }

    size_type m_size,
              m_capacity;
    value_type *m_values;
};


template<typename T>
inline typename wxVector<T>::size_type wxVector<T>::erase(size_type n)
{
    erase(begin() + n);
    return n;
}




namespace wxPrivate
{



template<typename T>
struct wxVectorComparator
{
    static int
    Compare(const void* pitem1, const void* pitem2, const void* )
    {
        const T& item1 = *reinterpret_cast<const T*>(pitem1);
        const T& item2 = *reinterpret_cast<const T*>(pitem2);

        if (item1 < item2)
            return -1;
        else if (item2 < item1)
            return 1;
        else
            return 0;
    }
};

}



template<typename T>
void wxVectorSort(wxVector<T>& v)
{
    wxQsort(v.begin(), v.size(), sizeof(T),
            wxPrivate::wxVectorComparator<T>::Compare, 
# 571 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h" 3 4
                                                      __null
# 571 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/vector.h"
                                                          );
}
# 35 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 2
# 48 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
class wxObjectListNode;
typedef wxObjectListNode wxNode;
# 360 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
union wxListKeyValue
{
    long integer;
    wxString *string;
};







class wxListKey
{
public:

    wxListKey() : m_keyType(wxKEY_NONE)
        { }
    wxListKey(long i) : m_keyType(wxKEY_INTEGER)
        { m_key.integer = i; }
    wxListKey(const wxString& s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }
    wxListKey(const char *s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }
    wxListKey(const wchar_t *s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }


    wxKeyType GetKeyType() const { return m_keyType; }
    const wxString GetString() const
        { do { if ( wxTheAssertHandler && !(m_keyType == wxKEY_STRING) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 390, __FUNCTION__, "m_keyType == wxKEY_STRING", (const char*)
# 390 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
         __null
# 390 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
         ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return *m_key.string; }
    long GetNumber() const
        { do { if ( wxTheAssertHandler && !(m_keyType == wxKEY_INTEGER) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 392, __FUNCTION__, "m_keyType == wxKEY_INTEGER", (const char*)
# 392 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
         __null
# 392 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
         ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_key.integer; }




    bool operator==(wxListKeyValue value) const ;


    ~wxListKey()
    {
        if ( m_keyType == wxKEY_STRING )
            delete m_key.string;
    }

private:
    wxKeyType m_keyType;
    wxListKeyValue m_key;
};





extern wxListKey wxDefaultListKey;

class wxListBase;

class wxNodeBase
{
friend class wxListBase;
public:

    wxNodeBase(wxListBase *list = 
# 424 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                                 __null
# 424 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                                     ,
               wxNodeBase *previous = 
# 425 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                                     __null
# 425 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                                         ,
               wxNodeBase *next = 
# 426 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                                 __null
# 426 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                                     ,
               void *data = 
# 427 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                           __null
# 427 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                               ,
               const wxListKey& key = wxDefaultListKey);

    virtual ~wxNodeBase();


    wxString GetKeyString() const { return *m_key.string; }
    long GetKeyInteger() const { return m_key.integer; }


    void SetKeyString(const wxString& s) { m_key.string = new wxString(s); }
    void SetKeyInteger(long i) { m_key.integer = i; }



    __attribute__((deprecated)) wxNode *Next() const;
    __attribute__((deprecated)) wxNode *Previous() const;
    __attribute__((deprecated)) wxObject *Data() const;


protected:

    wxNodeBase *GetNext() const { return m_next; }
    wxNodeBase *GetPrevious() const { return m_previous; }

    void *GetData() const { return m_data; }
    void SetData(void *data) { m_data = data; }


    int IndexOf() const;

    virtual void DeleteData() { }
public:

    void** GetDataPtr() const { return &(const_cast<wxNodeBase*>(this)->m_data); }
private:

    wxListKeyValue m_key;

    void *m_data;
    wxNodeBase *m_next,
                *m_previous;

    wxListBase *m_list;

    private: wxNodeBase(const wxNodeBase&); wxNodeBase& operator=(const wxNodeBase&);
};





class wxList;

class wxListBase
{
friend class wxNodeBase;
friend class wxHashTableBase;

public:

    wxListBase(wxKeyType keyType = wxKEY_NONE)
        { Init(keyType); }
    virtual ~wxListBase();



    size_t GetCount() const { return m_count; }


    bool IsEmpty() const { return m_count == 0; }




    void Clear();


    void DeleteContents(bool destroy) { m_destroy = destroy; }


    bool GetDeleteContents() const
        { return m_destroy; }


    wxKeyType GetKeyType() const
        { return m_keyType; }


    void SetKeyType(wxKeyType keyType)
        { do { if ( wxTheAssertHandler && !(m_count==0) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 517, __FUNCTION__, "m_count==0", (const char*)
# 517 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
         __null
# 517 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
         ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_keyType = keyType; }



    __attribute__((deprecated)) int Number() const;
    __attribute__((deprecated)) wxNode *First() const;
    __attribute__((deprecated)) wxNode *Last() const;
    __attribute__((deprecated)) wxNode *Nth(size_t n) const;


    __attribute__((deprecated)) operator wxList&() const;


protected:





    virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,
                                   void *data,
                                   const wxListKey& key = wxDefaultListKey) = 0;




    wxListBase(size_t count, void *elements[]);

    wxListBase(void *object, ... );

protected:
    void Assign(const wxListBase& list)
        { Clear(); DoCopy(list); }


    wxNodeBase *GetFirst() const { return m_nodeFirst; }
    wxNodeBase *GetLast() const { return m_nodeLast; }


    wxNodeBase *Item(size_t index) const;


    void *operator[](size_t n) const
    {
        wxNodeBase *node = Item(n);

        return node ? node->GetData() : 
# 563 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                                       __null
# 563 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                                           ;
    }



    wxNodeBase *Prepend(void *object)
        { return (wxNodeBase *)wxListBase::Insert(object); }

    wxNodeBase *Append(void *object);

    wxNodeBase *Insert(void *object)
        { return Insert(static_cast<wxNodeBase *>(
# 574 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
                                                 __null
# 574 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
                                                     ), object); }

    wxNodeBase *Insert(size_t pos, void *object)
        { return pos == GetCount() ? Append(object)
                                   : Insert(Item(pos), object); }

    wxNodeBase *Insert(wxNodeBase *prev, void *object);


    wxNodeBase *Append(long key, void *object);
    wxNodeBase *Append(const wxString& key, void *object);



    wxNodeBase *DetachNode(wxNodeBase *node);

    bool DeleteNode(wxNodeBase *node);


    bool DeleteObject(void *object);



    wxNodeBase *Find(const void *object) const;


    wxNodeBase *Find(const wxListKey& key) const;


    int IndexOf( void *object ) const;



    void Sort(const wxSortCompareFunction compfunc);


    void *FirstThat(wxListIterateFunction func);
    void ForEach(wxListIterateFunction func);
    void *LastThat(wxListIterateFunction func);



    void Reverse();
    void DeleteNodes(wxNodeBase* first, wxNodeBase* last);
private:


    void Init(wxKeyType keyType = wxKEY_NONE);



    void DoCopy(const wxListBase& list);

    wxNodeBase *AppendCommon(wxNodeBase *node);

    void DoDeleteNode(wxNodeBase *node);

    size_t m_count;
    bool m_destroy;
    wxNodeBase *m_nodeFirst,
               *m_nodeLast;

    wxKeyType m_keyType;
};
# 1172 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
inline wxNode *wxNodeBase::Next() const { return (wxNode *)GetNext(); }
inline wxNode *wxNodeBase::Previous() const { return (wxNode *)GetPrevious(); }
inline wxObject *wxNodeBase::Data() const { return (wxObject *)GetData(); }





inline int wxListBase::Number() const { return (int)GetCount(); }
inline wxNode *wxListBase::First() const { return (wxNode *)GetFirst(); }
inline wxNode *wxListBase::Last() const { return (wxNode *)GetLast(); }
inline wxNode *wxListBase::Nth(size_t n) const { return (wxNode *)Item(n); }
inline wxListBase::operator wxList&() const { return *(wxList*)this; }
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
typedef int (*wxSortFuncFor_wxObjectList)(const wxObject **, const wxObject **); class wxObjectListNode : public wxNodeBase { public: wxObjectListNode(wxListBase *list = 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxObjectListNode *previous = 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxObjectListNode *next = 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxObject *data = 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxObjectListNode *GetNext() const { return (wxObjectListNode *)wxNodeBase::GetNext(); } wxObjectListNode *GetPrevious() const { return (wxObjectListNode *)wxNodeBase::GetPrevious(); } wxObject *GetData() const { return (wxObject *)wxNodeBase::GetData(); } void SetData(wxObject *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxObjectListNode(const wxObjectListNode&); wxObjectListNode& operator=(const wxObjectListNode&); }; class wxObjectList : public wxListBase { public: typedef wxObjectListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxObjectList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxObjectList(const wxObjectList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxObjectList(size_t count, wxObject *elements[]) : wxListBase(count, (void **)elements) { } wxObjectList& operator=(const wxObjectList& list) { if (&list != this) Assign(list); return *this; } wxObjectListNode *GetFirst() const { return (wxObjectListNode *)wxListBase::GetFirst(); } wxObjectListNode *GetLast() const { return (wxObjectListNode *)wxListBase::GetLast(); } wxObjectListNode *Item(size_t index) const { return (wxObjectListNode *)wxListBase::Item(index); } wxObject *operator[](size_t index) const { wxObjectListNode *node = Item(index); return node ? (wxObject*)(node->GetData()) : 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
; } wxObjectListNode *Append(wxObject *object) { return (wxObjectListNode *)wxListBase::Append(object); } wxObjectListNode *Insert(wxObject *object) { return (wxObjectListNode *)Insert(static_cast<wxObjectListNode *>(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), object); } wxObjectListNode *Insert(size_t pos, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(pos, object); } wxObjectListNode *Insert(wxObjectListNode *prev, wxObject *object) { return (wxObjectListNode *)wxListBase::Insert(prev, object); } wxObjectListNode *Append(long key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *Append(const wxChar *key, void *object) { return (wxObjectListNode *)wxListBase::Append(key, object); } wxObjectListNode *DetachNode(wxObjectListNode *node) { return (wxObjectListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxObjectListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxObject *object) { return wxListBase::DeleteObject(object); } void Erase(wxObjectListNode *it) { DeleteNode(it); } wxObjectListNode *Find(const wxObject *object) const { return (wxObjectListNode *)wxListBase::Find(object); } virtual wxObjectListNode *Find(const wxListKey& key) const { return (wxObjectListNode *)wxListBase::Find(key); } bool Member(const wxObject *object) const { return Find(object) != 
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
; } int IndexOf(wxObject *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxObjectList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxObjectListNode(this, (wxObjectListNode *)prev, (wxObjectListNode *)next, (wxObject *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxObject* value_type; typedef wxObject* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef iterator itor; typedef wxObject* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 ,
 1196
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 , __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 ,
 1196
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 , __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 ,
 1196
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 , __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 ,
 1196
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
 , __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxObjectList list; public: typedef wxObjectListNode Node; typedef wxObject* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxObjectList(size_type n, const_reference v = value_type()) { assign(n, v); } wxObjectList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1195 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxObjectList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxObjectList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxObjectList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } }
                                               ;

class wxList : public wxObjectList
{
public:




    wxList(int key_type = wxKEY_NONE);



   ~wxList() { }


    wxList& operator=(const wxList& list)
        { if (&list != this) Assign(list); return *this; }


    void Sort(wxSortCompareFunction compfunc) { wxListBase::Sort(compfunc); }



    template<typename T>
    wxVector<T> AsVector() const
    {
        wxVector<T> vector(size());
        size_t i = 0;

        for ( const_iterator it = begin(); it != end(); ++it )
        {
            vector[i++] = static_cast<T>(*it);
        }

        return vector;
    }


};






typedef int (*wxSortFuncFor_wxStringListBase)(const wxChar **, const wxChar **); class wxStringListNode : public wxNodeBase { public: wxStringListNode(wxListBase *list = 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxStringListNode *previous = 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxStringListNode *next = 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, wxChar *data = 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxStringListNode *GetNext() const { return (wxStringListNode *)wxNodeBase::GetNext(); } wxStringListNode *GetPrevious() const { return (wxStringListNode *)wxNodeBase::GetPrevious(); } wxChar *GetData() const { return (wxChar *)wxNodeBase::GetData(); } void SetData(wxChar *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxStringListNode(const wxStringListNode&); wxStringListNode& operator=(const wxStringListNode&); }; class wxStringListBase : public wxListBase { public: typedef wxStringListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxStringListBase(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxStringListBase(const wxStringListBase& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxStringListBase(size_t count, wxChar *elements[]) : wxListBase(count, (void **)elements) { } wxStringListBase& operator=(const wxStringListBase& list) { if (&list != this) Assign(list); return *this; } wxStringListNode *GetFirst() const { return (wxStringListNode *)wxListBase::GetFirst(); } wxStringListNode *GetLast() const { return (wxStringListNode *)wxListBase::GetLast(); } wxStringListNode *Item(size_t index) const { return (wxStringListNode *)wxListBase::Item(index); } wxChar *operator[](size_t index) const { wxStringListNode *node = Item(index); return node ? (wxChar*)(node->GetData()) : 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
; } wxStringListNode *Append(wxChar *object) { return (wxStringListNode *)wxListBase::Append(object); } wxStringListNode *Insert(wxChar *object) { return (wxStringListNode *)Insert(static_cast<wxStringListNode *>(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), object); } wxStringListNode *Insert(size_t pos, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(pos, object); } wxStringListNode *Insert(wxStringListNode *prev, wxChar *object) { return (wxStringListNode *)wxListBase::Insert(prev, object); } wxStringListNode *Append(long key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *Append(const wxChar *key, void *object) { return (wxStringListNode *)wxListBase::Append(key, object); } wxStringListNode *DetachNode(wxStringListNode *node) { return (wxStringListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxStringListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxChar *object) { return wxListBase::DeleteObject(object); } void Erase(wxStringListNode *it) { DeleteNode(it); } wxStringListNode *Find(const wxChar *object) const { return (wxStringListNode *)wxListBase::Find(object); } virtual wxStringListNode *Find(const wxListKey& key) const { return (wxStringListNode *)wxListBase::Find(key); } bool Member(const wxChar *object) const { return Find(object) != 
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
; } int IndexOf(wxChar *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxStringListBase func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxStringListNode(this, (wxStringListNode *)prev, (wxStringListNode *)next, (wxChar *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxChar* value_type; typedef wxChar* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef iterator itor; typedef wxChar* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 1242, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 1242, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 1242, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h", 1242, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxStringListBase list; public: typedef wxStringListNode Node; typedef wxChar* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
), m_init(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxStringListBase(size_type n, const_reference v = value_type()) { assign(n, v); } wxStringListBase(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h" 3 4
__null
# 1242 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/list.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxStringListBase& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxStringListBase& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxStringListBase& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };

class wxStringList : public wxStringListBase
{
public:






    wxStringList();
    wxStringList(const wxChar *first ...);




    wxStringList(const wxStringList& other) : wxStringListBase() { DeleteContents(true); DoCopy(other); }
    wxStringList& operator=(const wxStringList& other)
    {
        if (&other != this)
        {
            Clear();
            DoCopy(other);
        }
        return *this;
    }



    wxNode *Add(const wxChar *s);


    wxNode *Prepend(const wxChar *s);

    bool Delete(const wxChar *s);

    wxChar **ListToArray(bool new_copies = false) const;
    bool Member(const wxChar *s) const;


    void Sort();

private:
    void DoCopy(const wxStringList&);
};
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h" 1
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/math.h" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/math.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3





# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 1 3
# 10 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
       
# 11 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3





# 15 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);
# 372 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);
# 1576 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/math.h" 3
}




#pragma pack(pop)
# 46 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 2 3
# 77 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
extern "C++"
{
namespace std
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1888 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3

}





}
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 30 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h" 2
# 72 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cmath" 3
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h" 2
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
#pragma GCC diagnostic push
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 140 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   
    
# 141 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   inline bool wxIsSameDouble(double x, double y) { return x == y; }
   
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
#pragma GCC diagnostic pop
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   



inline bool wxIsNullDouble(double x) { return wxIsSameDouble(x, 0.); }

inline int wxRound(double x)
{
    do { if ( wxTheAssertHandler && !(x > 
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h" 3 4
   (-0x7fffffff - 1) 
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
   - 0.5 && x < 0x7fffffff + 0.5) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
    ,
 151
# 150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
    , __FUNCTION__, "x > INT_MIN - 0.5 && x < INT_MAX + 0.5", L"argument out of supported range"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                          ;




        return (int)(x < 0 ? x - 0.5 : x + 0.5);

}
# 171 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/math.h"
    extern "C" {


    wxFloat64 wxConvertFromIeeeExtended(const wxInt8 *bytes);
    void wxConvertToIeeeExtended(wxFloat64 num, wxInt8 *bytes);



    __attribute__((deprecated)) wxFloat64 ConvertFromIeeeExtended(const wxInt8 *bytes);
    __attribute__((deprecated)) void ConvertToIeeeExtended(wxFloat64 num, wxInt8 *bytes);



    }
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 2





class wxBitmap;
class wxBrush;
class wxColour;
class wxCursor;
class wxFont;
class wxIcon;
class wxPalette;
class wxPen;
class wxRegion;
class wxString;
class wxIconBundle;
class wxPoint;






enum wxBitmapType
{
    wxBITMAP_TYPE_INVALID,
    wxBITMAP_TYPE_BMP,
    wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_RESOURCE = wxBITMAP_TYPE_BMP_RESOURCE,
    wxBITMAP_TYPE_ICO,
    wxBITMAP_TYPE_ICO_RESOURCE,
    wxBITMAP_TYPE_CUR,
    wxBITMAP_TYPE_CUR_RESOURCE,
    wxBITMAP_TYPE_XBM,
    wxBITMAP_TYPE_XBM_DATA,
    wxBITMAP_TYPE_XPM,
    wxBITMAP_TYPE_XPM_DATA,
    wxBITMAP_TYPE_TIFF,
    wxBITMAP_TYPE_TIF = wxBITMAP_TYPE_TIFF,
    wxBITMAP_TYPE_TIFF_RESOURCE,
    wxBITMAP_TYPE_TIF_RESOURCE = wxBITMAP_TYPE_TIFF_RESOURCE,
    wxBITMAP_TYPE_GIF,
    wxBITMAP_TYPE_GIF_RESOURCE,
    wxBITMAP_TYPE_PNG,
    wxBITMAP_TYPE_PNG_RESOURCE,
    wxBITMAP_TYPE_JPEG,
    wxBITMAP_TYPE_JPEG_RESOURCE,
    wxBITMAP_TYPE_PNM,
    wxBITMAP_TYPE_PNM_RESOURCE,
    wxBITMAP_TYPE_PCX,
    wxBITMAP_TYPE_PCX_RESOURCE,
    wxBITMAP_TYPE_PICT,
    wxBITMAP_TYPE_PICT_RESOURCE,
    wxBITMAP_TYPE_ICON,
    wxBITMAP_TYPE_ICON_RESOURCE,
    wxBITMAP_TYPE_ANI,
    wxBITMAP_TYPE_IFF,
    wxBITMAP_TYPE_TGA,
    wxBITMAP_TYPE_MACCURSOR,
    wxBITMAP_TYPE_MACCURSOR_RESOURCE,

    wxBITMAP_TYPE_MAX,
    wxBITMAP_TYPE_ANY = 50
};


enum wxPolygonFillMode
{
    wxODDEVEN_RULE = 1,
    wxWINDING_RULE
};


enum wxStockCursor
{
    wxCURSOR_NONE,
    wxCURSOR_ARROW,
    wxCURSOR_RIGHT_ARROW,
    wxCURSOR_BULLSEYE,
    wxCURSOR_CHAR,
    wxCURSOR_CROSS,
    wxCURSOR_HAND,
    wxCURSOR_IBEAM,
    wxCURSOR_LEFT_BUTTON,
    wxCURSOR_MAGNIFIER,
    wxCURSOR_MIDDLE_BUTTON,
    wxCURSOR_NO_ENTRY,
    wxCURSOR_PAINT_BRUSH,
    wxCURSOR_PENCIL,
    wxCURSOR_POINT_LEFT,
    wxCURSOR_POINT_RIGHT,
    wxCURSOR_QUESTION_ARROW,
    wxCURSOR_RIGHT_BUTTON,
    wxCURSOR_SIZENESW,
    wxCURSOR_SIZENS,
    wxCURSOR_SIZENWSE,
    wxCURSOR_SIZEWE,
    wxCURSOR_SIZING,
    wxCURSOR_SPRAYCAN,
    wxCURSOR_WAIT,
    wxCURSOR_WATCH,
    wxCURSOR_BLANK,
# 139 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
    wxCURSOR_ARROWWAIT,





    wxCURSOR_MAX
};
# 250 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
class wxSize
{
public:

    int x, y;


    wxSize() : x(0), y(0) { }
    wxSize(int xx, int yy) : x(xx), y(yy) { }



    wxSize& operator+=(const wxSize& sz) { x += sz.x; y += sz.y; return *this; }
    wxSize& operator-=(const wxSize& sz) { x -= sz.x; y -= sz.y; return *this; }
    wxSize& operator/=(int i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(int i) { x *= i; y *= i; return *this; }
    wxSize& operator/=(unsigned int i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(unsigned int i) { x *= i; y *= i; return *this; }
    wxSize& operator/=(long i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(long i) { x *= i; y *= i; return *this; }
    wxSize& operator/=(unsigned long i) { x /= i; y /= i; return *this; }
    wxSize& operator*=(unsigned long i) { x *= i; y *= i; return *this; }
    wxSize& operator/=(double i) { x = int(x/i); y = int(y/i); return *this; }
    wxSize& operator*=(double i) { x = int(x*i); y = int(y*i); return *this; }

    void IncTo(const wxSize& sz)
        { if ( sz.x > x ) x = sz.x; if ( sz.y > y ) y = sz.y; }
    void DecTo(const wxSize& sz)
        { if ( sz.x < x ) x = sz.x; if ( sz.y < y ) y = sz.y; }
    void DecToIfSpecified(const wxSize& sz)
    {
        if ( sz.x != wxDefaultCoord && sz.x < x )
            x = sz.x;
        if ( sz.y != wxDefaultCoord && sz.y < y )
            y = sz.y;
    }

    void IncBy(int dx, int dy) { x += dx; y += dy; }
    void IncBy(const wxPoint& pt);
    void IncBy(const wxSize& sz) { IncBy(sz.x, sz.y); }
    void IncBy(int d) { IncBy(d, d); }

    void DecBy(int dx, int dy) { IncBy(-dx, -dy); }
    void DecBy(const wxPoint& pt);
    void DecBy(const wxSize& sz) { DecBy(sz.x, sz.y); }
    void DecBy(int d) { DecBy(d, d); }


    wxSize& Scale(float xscale, float yscale)
        { x = (int)(x*xscale); y = (int)(y*yscale); return *this; }


    void Set(int xx, int yy) { x = xx; y = yy; }
    void SetWidth(int w) { x = w; }
    void SetHeight(int h) { y = h; }

    int GetWidth() const { return x; }
    int GetHeight() const { return y; }

    bool IsFullySpecified() const { return x != wxDefaultCoord && y != wxDefaultCoord; }



    void SetDefaults(const wxSize& size)
    {
        if ( x == wxDefaultCoord )
            x = size.x;
        if ( y == wxDefaultCoord )
            y = size.y;
    }


    int GetX() const { return x; }
    int GetY() const { return y; }
};

inline bool operator==(const wxSize& s1, const wxSize& s2)
{
    return s1.x == s2.x && s1.y == s2.y;
}

inline bool operator!=(const wxSize& s1, const wxSize& s2)
{
    return s1.x != s2.x || s1.y != s2.y;
}

inline wxSize operator+(const wxSize& s1, const wxSize& s2)
{
    return wxSize(s1.x + s2.x, s1.y + s2.y);
}

inline wxSize operator-(const wxSize& s1, const wxSize& s2)
{
    return wxSize(s1.x - s2.x, s1.y - s2.y);
}

inline wxSize operator/(const wxSize& s, int i)
{
    return wxSize(s.x / i, s.y / i);
}

inline wxSize operator*(const wxSize& s, int i)
{
    return wxSize(s.x * i, s.y * i);
}

inline wxSize operator*(int i, const wxSize& s)
{
    return wxSize(s.x * i, s.y * i);
}

inline wxSize operator/(const wxSize& s, unsigned int i)
{
    return wxSize(s.x / i, s.y / i);
}

inline wxSize operator*(const wxSize& s, unsigned int i)
{
    return wxSize(s.x * i, s.y * i);
}

inline wxSize operator*(unsigned int i, const wxSize& s)
{
    return wxSize(s.x * i, s.y * i);
}

inline wxSize operator/(const wxSize& s, long i)
{
    return wxSize(s.x / i, s.y / i);
}

inline wxSize operator*(const wxSize& s, long i)
{
    return wxSize(int(s.x * i), int(s.y * i));
}

inline wxSize operator*(long i, const wxSize& s)
{
    return wxSize(int(s.x * i), int(s.y * i));
}

inline wxSize operator/(const wxSize& s, unsigned long i)
{
    return wxSize(int(s.x / i), int(s.y / i));
}

inline wxSize operator*(const wxSize& s, unsigned long i)
{
    return wxSize(int(s.x * i), int(s.y * i));
}

inline wxSize operator*(unsigned long i, const wxSize& s)
{
    return wxSize(int(s.x * i), int(s.y * i));
}

inline wxSize operator*(const wxSize& s, double i)
{
    return wxSize(int(s.x * i), int(s.y * i));
}

inline wxSize operator*(double i, const wxSize& s)
{
    return wxSize(int(s.x * i), int(s.y * i));
}







class wxRealPoint
{
public:
    double x;
    double y;

    wxRealPoint() : x(0.0), y(0.0) { }
    wxRealPoint(double xx, double yy) : x(xx), y(yy) { }
    wxRealPoint(const wxPoint& pt);




    wxRealPoint& operator+=(const wxRealPoint& p) { x += p.x; y += p.y; return *this; }
    wxRealPoint& operator-=(const wxRealPoint& p) { x -= p.x; y -= p.y; return *this; }

    wxRealPoint& operator+=(const wxSize& s) { x += s.GetWidth(); y += s.GetHeight(); return *this; }
    wxRealPoint& operator-=(const wxSize& s) { x -= s.GetWidth(); y -= s.GetHeight(); return *this; }
};


inline bool operator==(const wxRealPoint& p1, const wxRealPoint& p2)
{
    return wxIsSameDouble(p1.x, p2.x) && wxIsSameDouble(p1.y, p2.y);
}

inline bool operator!=(const wxRealPoint& p1, const wxRealPoint& p2)
{
    return !(p1 == p2);
}

inline wxRealPoint operator+(const wxRealPoint& p1, const wxRealPoint& p2)
{
    return wxRealPoint(p1.x + p2.x, p1.y + p2.y);
}


inline wxRealPoint operator-(const wxRealPoint& p1, const wxRealPoint& p2)
{
    return wxRealPoint(p1.x - p2.x, p1.y - p2.y);
}


inline wxRealPoint operator/(const wxRealPoint& s, int i)
{
    return wxRealPoint(s.x / i, s.y / i);
}

inline wxRealPoint operator*(const wxRealPoint& s, int i)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator*(int i, const wxRealPoint& s)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator/(const wxRealPoint& s, unsigned int i)
{
    return wxRealPoint(s.x / i, s.y / i);
}

inline wxRealPoint operator*(const wxRealPoint& s, unsigned int i)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator*(unsigned int i, const wxRealPoint& s)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator/(const wxRealPoint& s, long i)
{
    return wxRealPoint(s.x / i, s.y / i);
}

inline wxRealPoint operator*(const wxRealPoint& s, long i)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator*(long i, const wxRealPoint& s)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator/(const wxRealPoint& s, unsigned long i)
{
    return wxRealPoint(s.x / i, s.y / i);
}

inline wxRealPoint operator*(const wxRealPoint& s, unsigned long i)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator*(unsigned long i, const wxRealPoint& s)
{
    return wxRealPoint(s.x * i, s.y * i);
}

inline wxRealPoint operator*(const wxRealPoint& s, double i)
{
    return wxRealPoint(int(s.x * i), int(s.y * i));
}

inline wxRealPoint operator*(double i, const wxRealPoint& s)
{
    return wxRealPoint(int(s.x * i), int(s.y * i));
}






class wxPoint
{
public:
    int x, y;

    wxPoint() : x(0), y(0) { }
    wxPoint(int xx, int yy) : x(xx), y(yy) { }
    wxPoint(const wxRealPoint& pt) : x(int(pt.x)), y(int(pt.y)) { }




    wxPoint& operator+=(const wxPoint& p) { x += p.x; y += p.y; return *this; }
    wxPoint& operator-=(const wxPoint& p) { x -= p.x; y -= p.y; return *this; }

    wxPoint& operator+=(const wxSize& s) { x += s.GetWidth(); y += s.GetHeight(); return *this; }
    wxPoint& operator-=(const wxSize& s) { x -= s.GetWidth(); y -= s.GetHeight(); return *this; }


    bool IsFullySpecified() const { return x != wxDefaultCoord && y != wxDefaultCoord; }


    void SetDefaults(const wxPoint& pt)
    {
        if ( x == wxDefaultCoord )
            x = pt.x;
        if ( y == wxDefaultCoord )
            y = pt.y;
    }
};



inline bool operator==(const wxPoint& p1, const wxPoint& p2)
{
    return p1.x == p2.x && p1.y == p2.y;
}

inline bool operator!=(const wxPoint& p1, const wxPoint& p2)
{
    return !(p1 == p2);
}



inline wxPoint operator+(const wxPoint& p1, const wxPoint& p2)
{
    return wxPoint(p1.x + p2.x, p1.y + p2.y);
}

inline wxPoint operator-(const wxPoint& p1, const wxPoint& p2)
{
    return wxPoint(p1.x - p2.x, p1.y - p2.y);
}

inline wxPoint operator+(const wxPoint& p, const wxSize& s)
{
    return wxPoint(p.x + s.x, p.y + s.y);
}

inline wxPoint operator-(const wxPoint& p, const wxSize& s)
{
    return wxPoint(p.x - s.x, p.y - s.y);
}

inline wxPoint operator+(const wxSize& s, const wxPoint& p)
{
    return wxPoint(p.x + s.x, p.y + s.y);
}

inline wxPoint operator-(const wxSize& s, const wxPoint& p)
{
    return wxPoint(s.x - p.x, s.y - p.y);
}

inline wxPoint operator-(const wxPoint& p)
{
    return wxPoint(-p.x, -p.y);
}

inline wxPoint operator/(const wxPoint& s, int i)
{
    return wxPoint(s.x / i, s.y / i);
}

inline wxPoint operator*(const wxPoint& s, int i)
{
    return wxPoint(s.x * i, s.y * i);
}

inline wxPoint operator*(int i, const wxPoint& s)
{
    return wxPoint(s.x * i, s.y * i);
}

inline wxPoint operator/(const wxPoint& s, unsigned int i)
{
    return wxPoint(s.x / i, s.y / i);
}

inline wxPoint operator*(const wxPoint& s, unsigned int i)
{
    return wxPoint(s.x * i, s.y * i);
}

inline wxPoint operator*(unsigned int i, const wxPoint& s)
{
    return wxPoint(s.x * i, s.y * i);
}

inline wxPoint operator/(const wxPoint& s, long i)
{
    return wxPoint(s.x / i, s.y / i);
}

inline wxPoint operator*(const wxPoint& s, long i)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

inline wxPoint operator*(long i, const wxPoint& s)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

inline wxPoint operator/(const wxPoint& s, unsigned long i)
{
    return wxPoint(s.x / i, s.y / i);
}

inline wxPoint operator*(const wxPoint& s, unsigned long i)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

inline wxPoint operator*(unsigned long i, const wxPoint& s)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

inline wxPoint operator*(const wxPoint& s, double i)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

inline wxPoint operator*(double i, const wxPoint& s)
{
    return wxPoint(int(s.x * i), int(s.y * i));
}

typedef wxPoint _WX_LIST_ITEM_TYPE_wxPointList; typedef int (*wxSortFuncFor_wxPointList)(const wxPoint **, const wxPoint **); class wxwxPointListNode : public wxNodeBase { public: wxwxPointListNode(wxListBase *list = 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, wxwxPointListNode *previous = 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, wxwxPointListNode *next = 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, wxPoint *data = 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxPointListNode *GetNext() const { return (wxwxPointListNode *)wxNodeBase::GetNext(); } wxwxPointListNode *GetPrevious() const { return (wxwxPointListNode *)wxNodeBase::GetPrevious(); } wxPoint *GetData() const { return (wxPoint *)wxNodeBase::GetData(); } void SetData(wxPoint *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxPointListNode(const wxwxPointListNode&); wxwxPointListNode& operator=(const wxwxPointListNode&); }; class wxPointList : public wxListBase { public: typedef wxwxPointListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxPointList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxPointList(const wxPointList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxPointList(size_t count, wxPoint *elements[]) : wxListBase(count, (void **)elements) { } wxPointList& operator=(const wxPointList& list) { if (&list != this) Assign(list); return *this; } wxwxPointListNode *GetFirst() const { return (wxwxPointListNode *)wxListBase::GetFirst(); } wxwxPointListNode *GetLast() const { return (wxwxPointListNode *)wxListBase::GetLast(); } wxwxPointListNode *Item(size_t index) const { return (wxwxPointListNode *)wxListBase::Item(index); } wxPoint *operator[](size_t index) const { wxwxPointListNode *node = Item(index); return node ? (wxPoint*)(node->GetData()) : 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
; } wxwxPointListNode *Append(wxPoint *object) { return (wxwxPointListNode *)wxListBase::Append(object); } wxwxPointListNode *Insert(wxPoint *object) { return (wxwxPointListNode *)Insert(static_cast<wxwxPointListNode *>(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), object); } wxwxPointListNode *Insert(size_t pos, wxPoint *object) { return (wxwxPointListNode *)wxListBase::Insert(pos, object); } wxwxPointListNode *Insert(wxwxPointListNode *prev, wxPoint *object) { return (wxwxPointListNode *)wxListBase::Insert(prev, object); } wxwxPointListNode *Append(long key, void *object) { return (wxwxPointListNode *)wxListBase::Append(key, object); } wxwxPointListNode *Append(const wxChar *key, void *object) { return (wxwxPointListNode *)wxListBase::Append(key, object); } wxwxPointListNode *DetachNode(wxwxPointListNode *node) { return (wxwxPointListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxPointListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxPoint *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxPointListNode *it) { DeleteNode(it); } wxwxPointListNode *Find(const wxPoint *object) const { return (wxwxPointListNode *)wxListBase::Find(object); } virtual wxwxPointListNode *Find(const wxListKey& key) const { return (wxwxPointListNode *)wxListBase::Find(key); } bool Member(const wxPoint *object) const { return Find(object) != 
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
; } int IndexOf(wxPoint *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxPointList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxPointListNode(this, (wxwxPointListNode *)prev, (wxwxPointListNode *)next, (wxPoint *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxPoint* value_type; typedef wxPoint* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxPointList list; public: typedef wxwxPointListNode Node; typedef iterator itor; typedef wxPoint* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_init(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h", 690, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h", 690, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxPointList list; public: typedef wxwxPointListNode Node; typedef wxPoint* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_init(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h", 690, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h", 690, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxPointList list; public: typedef wxwxPointListNode Node; typedef wxPoint* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_init(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxPointList list; public: typedef wxwxPointListNode Node; typedef wxPoint* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_init(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxPointList(size_type n, const_reference v = value_type()) { assign(n, v); } wxPointList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 690 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxPointList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxPointList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxPointList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





class wxRect
{
public:
    wxRect()
        : x(0), y(0), width(0), height(0)
        { }
    wxRect(int xx, int yy, int ww, int hh)
        : x(xx), y(yy), width(ww), height(hh)
        { }
    wxRect(const wxPoint& topLeft, const wxPoint& bottomRight);
    wxRect(const wxPoint& pt, const wxSize& size)
        : x(pt.x), y(pt.y), width(size.x), height(size.y)
        { }
    wxRect(const wxSize& size)
        : x(0), y(0), width(size.x), height(size.y)
        { }



    int GetX() const { return x; }
    void SetX(int xx) { x = xx; }

    int GetY() const { return y; }
    void SetY(int yy) { y = yy; }

    int GetWidth() const { return width; }
    void SetWidth(int w) { width = w; }

    int GetHeight() const { return height; }
    void SetHeight(int h) { height = h; }

    wxPoint GetPosition() const { return wxPoint(x, y); }
    void SetPosition( const wxPoint &p ) { x = p.x; y = p.y; }

    wxSize GetSize() const { return wxSize(width, height); }
    void SetSize( const wxSize &s ) { width = s.GetWidth(); height = s.GetHeight(); }

    bool IsEmpty() const { return (width <= 0) || (height <= 0); }

    int GetLeft() const { return x; }
    int GetTop() const { return y; }
    int GetBottom() const { return y + height - 1; }
    int GetRight() const { return x + width - 1; }

    void SetLeft(int left) { x = left; }
    void SetRight(int right) { width = right - x + 1; }
    void SetTop(int top) { y = top; }
    void SetBottom(int bottom) { height = bottom - y + 1; }

    wxPoint GetTopLeft() const { return GetPosition(); }
    wxPoint GetLeftTop() const { return GetTopLeft(); }
    void SetTopLeft(const wxPoint &p) { SetPosition(p); }
    void SetLeftTop(const wxPoint &p) { SetTopLeft(p); }

    wxPoint GetBottomRight() const { return wxPoint(GetRight(), GetBottom()); }
    wxPoint GetRightBottom() const { return GetBottomRight(); }
    void SetBottomRight(const wxPoint &p) { SetRight(p.x); SetBottom(p.y); }
    void SetRightBottom(const wxPoint &p) { SetBottomRight(p); }

    wxPoint GetTopRight() const { return wxPoint(GetRight(), GetTop()); }
    wxPoint GetRightTop() const { return GetTopRight(); }
    void SetTopRight(const wxPoint &p) { SetRight(p.x); SetTop(p.y); }
    void SetRightTop(const wxPoint &p) { SetTopRight(p); }

    wxPoint GetBottomLeft() const { return wxPoint(GetLeft(), GetBottom()); }
    wxPoint GetLeftBottom() const { return GetBottomLeft(); }
    void SetBottomLeft(const wxPoint &p) { SetLeft(p.x); SetBottom(p.y); }
    void SetLeftBottom(const wxPoint &p) { SetBottomLeft(p); }


    wxRect& Inflate(wxCoord dx, wxCoord dy);
    wxRect& Inflate(const wxSize& d) { return Inflate(d.x, d.y); }
    wxRect& Inflate(wxCoord d) { return Inflate(d, d); }
    wxRect Inflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Inflate(dx, dy);
        return r;
    }

    wxRect& Deflate(wxCoord dx, wxCoord dy) { return Inflate(-dx, -dy); }
    wxRect& Deflate(const wxSize& d) { return Inflate(-d.x, -d.y); }
    wxRect& Deflate(wxCoord d) { return Inflate(-d); }
    wxRect Deflate(wxCoord dx, wxCoord dy) const
    {
        wxRect r = *this;
        r.Deflate(dx, dy);
        return r;
    }

    void Offset(wxCoord dx, wxCoord dy) { x += dx; y += dy; }
    void Offset(const wxPoint& pt) { Offset(pt.x, pt.y); }

    wxRect& Intersect(const wxRect& rect);
    wxRect Intersect(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Intersect(rect);
        return r;
    }

    wxRect& Union(const wxRect& rect);
    wxRect Union(const wxRect& rect) const
    {
        wxRect r = *this;
        r.Union(rect);
        return r;
    }


    bool Contains(int x, int y) const;
    bool Contains(const wxPoint& pt) const { return Contains(pt.x, pt.y); }

    bool Contains(const wxRect& rect) const;
# 819 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
    bool Intersects(const wxRect& rect) const;


    wxRect& operator+=(const wxRect& rect);


    wxRect& operator*=(const wxRect& rect);



    wxRect CentreIn(const wxRect& r, int dir = wxBOTH) const
    {
        return wxRect(dir & wxHORIZONTAL ? r.x + (r.width - width)/2 : x,
                      dir & wxVERTICAL ? r.y + (r.height - height)/2 : y,
                      width, height);
    }

    wxRect CenterIn(const wxRect& r, int dir = wxBOTH) const
    {
        return CentreIn(r, dir);
    }

public:
    int x, y, width, height;
};



inline bool operator==(const wxRect& r1, const wxRect& r2)
{
    return (r1.x == r2.x) && (r1.y == r2.y) &&
           (r1.width == r2.width) && (r1.height == r2.height);
}

inline bool operator!=(const wxRect& r1, const wxRect& r2)
{
    return !(r1 == r2);
}


 wxRect operator+(const wxRect& r1, const wxRect& r2);


 wxRect operator*(const wxRect& r1, const wxRect& r2);
# 876 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
inline void wxSize::IncBy(const wxPoint& pt) { IncBy(pt.x, pt.y); }
inline void wxSize::DecBy(const wxPoint& pt) { DecBy(pt.x, pt.y); }





typedef wxInt8 wxDash;

class wxGDIObjListBase {
public:
    wxGDIObjListBase();
    ~wxGDIObjListBase();

protected:
    wxList list;
};

class wxStringToColourHashMap_wxImplementation_Pair { public: typedef wxString first_type; typedef wxColour* second_type; typedef wxString t1; typedef wxColour* t2; typedef const wxString const_t1; typedef const wxColour* const_t2; wxStringToColourHashMap_wxImplementation_Pair(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; class wxStringToColourHashMap_wxImplementation_KeyEx { typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair pair_type; typedef const key_type const_key_type; typedef const pair_type const_pair_type; typedef const_key_type& const_key_reference; typedef const_pair_type& const_pair_reference; public: wxStringToColourHashMap_wxImplementation_KeyEx() { } const_key_reference operator()( const_pair_reference pair ) const { return pair.first; } wxStringToColourHashMap_wxImplementation_KeyEx& operator=(const wxStringToColourHashMap_wxImplementation_KeyEx&) { return *this; } }; class wxStringToColourHashMap_wxImplementation_HashTable : protected _wxHashTableBase2 { public: typedef wxString key_type; typedef wxStringToColourHashMap_wxImplementation_Pair value_type; typedef wxStringHash hasher; typedef wxStringEqual key_equal; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type& reference; typedef const value_type& const_reference; typedef const wxString const_key_type; typedef const wxStringToColourHashMap_wxImplementation_Pair const_mapped_type; public: typedef wxStringToColourHashMap_wxImplementation_KeyEx key_extractor; typedef wxStringToColourHashMap_wxImplementation_HashTable Self; protected: _wxHashTable_NodeBase** m_table; size_t m_tableBuckets; size_t m_items; hasher m_hasher; key_equal m_equals; key_extractor m_getKey; public: struct Node:public _wxHashTable_NodeBase { public: Node( const value_type& value ) : m_value( value ) {} Node* next() { return static_cast<Node*>(m_next); } value_type m_value; }; protected: static void DeleteNode( _wxHashTable_NodeBase* node ) { delete static_cast<Node*>(node); } public: class Iterator { public: Node* m_node; Self* m_ht; Iterator() : m_node(
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_ht(
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
) {} Iterator( Node* node, const Self* ht ) : m_node(node), m_ht(const_cast<Self*>(ht)) {} bool operator ==( const Iterator& it ) const { return m_node == it.m_node; } bool operator !=( const Iterator& it ) const { return m_node != it.m_node; } protected: Node* GetNextNode() { size_type bucket = GetBucketForNode(m_ht,m_node); for( size_type i = bucket + 1; i < m_ht->m_tableBuckets; ++i ) { if( m_ht->m_table[i] ) return static_cast<Node*>(m_ht->m_table[i]); } return 
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
; } void PlusPlus() { Node* next = m_node->next(); m_node = next ? next : GetNextNode(); } }; friend class Iterator; public: class iterator : public Iterator { public: iterator() : Iterator() {} iterator( Node* node, Self* ht ) : Iterator( node, ht ) {} iterator& operator++() { PlusPlus(); return *this; } iterator operator++(int) { iterator it=*this;PlusPlus();return it; } reference operator *() const { return m_node->m_value; } pointer operator ->() const { return &(m_node->m_value); } }; class const_iterator : public Iterator { public: const_iterator() : Iterator() {} const_iterator(iterator i) : Iterator(i) {} const_iterator( Node* node, const Self* ht ) : Iterator(node, const_cast<Self*>(ht)) {} const_iterator& operator++() { PlusPlus();return *this; } const_iterator operator++(int) { const_iterator it=*this;PlusPlus();return it; } const_reference operator *() const { return m_node->m_value; } const_pointer operator ->() const { return &(m_node->m_value); } }; wxStringToColourHashMap_wxImplementation_HashTable( size_type sz = 10, const hasher& hfun = hasher(), const key_equal& k_eq = key_equal(), const key_extractor& k_ex = key_extractor() ) : m_tableBuckets( GetNextPrime( (unsigned long) sz ) ), m_items( 0 ), m_hasher( hfun ), m_equals( k_eq ), m_getKey( k_ex ) { m_table = (_wxHashTable_NodeBase**)AllocTable(m_tableBuckets); } wxStringToColourHashMap_wxImplementation_HashTable( const Self& ht ) : m_table(
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
), m_tableBuckets( 0 ), m_items( ht.m_items ), m_hasher( ht.m_hasher ), m_equals( ht.m_equals ), m_getKey( ht.m_getKey ) { HashCopy( ht ); } const Self& operator=( const Self& ht ) { if (&ht != this) { clear(); m_hasher = ht.m_hasher; m_equals = ht.m_equals; m_getKey = ht.m_getKey; m_items = ht.m_items; HashCopy( ht ); } return *this; } ~wxStringToColourHashMap_wxImplementation_HashTable() { clear(); FreeTable(m_table); } hasher hash_funct() { return m_hasher; } key_equal key_eq() { return m_equals; } void clear() { DeleteNodes(m_tableBuckets, m_table, DeleteNode); m_items = 0; } size_type size() const { return m_items; } size_type max_size() const { return size_type(-1); } bool empty() const { return size() == 0; } const_iterator end() const { return const_iterator(
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, this); } iterator end() { return iterator(
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
, this); } const_iterator begin() const { return const_iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } iterator begin() { return iterator(static_cast<Node*>(GetFirstNode(m_tableBuckets, m_table)), this); } size_type erase( const const_key_type& key ) { _wxHashTable_NodeBase** node = GetNodePtr(key); if( !node ) return 0; --m_items; _wxHashTable_NodeBase* temp = (*node)->m_next; delete static_cast<Node*>(*node); (*node) = temp; if( never_shrink( m_tableBuckets, m_items ) ) ResizeTable( GetPreviousPrime( (unsigned long) m_tableBuckets ) - 1 ); return 1; } protected: static size_type GetBucketForNode( Self* ht, Node* node ) { return ht->m_hasher( ht->m_getKey( node->m_value ) ) % ht->m_tableBuckets; } static Node* CopyNode( Node* node ) { return new Node( *node ); } Node* GetOrCreateNode( const value_type& value, bool& created ) { const const_key_type& key = m_getKey( value ); size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) { created = false; return node; } node = node->next(); } created = true; return CreateNode( value, bucket); } Node * CreateNode( const value_type& value, size_t bucket ) { Node* node = new Node( value ); node->m_next = m_table[bucket]; m_table[bucket] = node; ++m_items; if( grow_lf70( m_tableBuckets, m_items ) ) ResizeTable( m_tableBuckets ); return node; } void CreateNode( const value_type& value ) { CreateNode(value, m_hasher( m_getKey(value) ) % m_tableBuckets ); } _wxHashTable_NodeBase** GetNodePtr(const const_key_type& key) const { size_t bucket = m_hasher( key ) % m_tableBuckets; _wxHashTable_NodeBase** node = &m_table[bucket]; while( *node ) { if (m_equals(m_getKey(static_cast<Node*>(*node)->m_value), key)) return node; node = &(*node)->m_next; } return 
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
; } Node* GetNode( const const_key_type& key ) const { size_t bucket = m_hasher( key ) % m_tableBuckets; Node* node = static_cast<Node*>(m_table[bucket]); while( node ) { if( m_equals( m_getKey( node->m_value ), key ) ) return node; node = node->next(); } return 
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h" 3 4
__null
# 894 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
; } void ResizeTable( size_t newSize ) { newSize = GetNextPrime( (unsigned long)newSize ); _wxHashTable_NodeBase** srcTable = m_table; size_t srcBuckets = m_tableBuckets; m_table = (_wxHashTable_NodeBase**)AllocTable( newSize ); m_tableBuckets = newSize; CopyHashTable( srcTable, srcBuckets, this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)&DummyProcessNode ); FreeTable(srcTable); } void HashCopy( const Self& ht ) { ResizeTable( ht.size() ); CopyHashTable( ht.m_table, ht.m_tableBuckets, (_wxHashTableBase2*)this, m_table, (BucketFromNode)GetBucketForNode, (ProcessNode)CopyNode ); } }; class wxStringToColourHashMap:public wxStringToColourHashMap_wxImplementation_HashTable { public: typedef wxColour* mapped_type; class Insert_Result { public: typedef iterator first_type; typedef bool second_type; typedef iterator t1; typedef bool t2; typedef const iterator const_t1; typedef const bool const_t2; Insert_Result(const const_t1& f, const const_t2& s) : first(const_cast<t1&>(f)), second(const_cast<t2&>(s)) {} t1 first; t2 second; }; explicit wxStringToColourHashMap( size_type hint = 100, hasher hf = hasher(), key_equal eq = key_equal() ) : wxStringToColourHashMap_wxImplementation_HashTable( hint, hf, eq, wxStringToColourHashMap_wxImplementation_KeyEx() ) {} mapped_type& operator[]( const const_key_type& key ) { bool created; return GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( key, mapped_type() ), created)->m_value.second; } const_iterator find( const const_key_type& key ) const { return const_iterator( GetNode( key ), this ); } iterator find( const const_key_type& key ) { return iterator( GetNode( key ), this ); } Insert_Result insert( const value_type& v ) { bool created; Node *node = GetOrCreateNode( wxStringToColourHashMap_wxImplementation_Pair( v.first, v.second ), created); return Insert_Result(iterator(node, this), created); } size_type erase( const key_type& k ) { return wxStringToColourHashMap_wxImplementation_HashTable::erase( k ); } void erase( const iterator& it ) { erase( (*it).first ); } size_type count( const const_key_type& key ) { return GetNode( key ) ? 1u : 0u; } };

class wxColourDatabase
{
public:
    wxColourDatabase();
    ~wxColourDatabase();


    wxColour Find(const wxString& name) const;
    wxString FindName(const wxColour& colour) const;


    void AddColour(const wxString& name, const wxColour& colour);
# 921 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
private:


    void Initialize();

    wxStringToColourHashMap *m_map;
};

class wxResourceCache: public wxList
{
public:
    wxResourceCache() { }

    wxResourceCache(const unsigned int keyType) : wxList(keyType) { }

    virtual ~wxResourceCache();
};
# 954 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
class wxStockGDI
{
public:
    enum Item {
        BRUSH_BLACK,
        BRUSH_BLUE,
        BRUSH_CYAN,
        BRUSH_GREEN,
        BRUSH_YELLOW,
        BRUSH_GREY,
        BRUSH_LIGHTGREY,
        BRUSH_MEDIUMGREY,
        BRUSH_RED,
        BRUSH_TRANSPARENT,
        BRUSH_WHITE,
        COLOUR_BLACK,
        COLOUR_BLUE,
        COLOUR_CYAN,
        COLOUR_GREEN,
        COLOUR_YELLOW,
        COLOUR_LIGHTGREY,
        COLOUR_RED,
        COLOUR_WHITE,
        CURSOR_CROSS,
        CURSOR_HOURGLASS,
        CURSOR_STANDARD,
        FONT_ITALIC,
        FONT_NORMAL,
        FONT_SMALL,
        FONT_SWISS,
        PEN_BLACK,
        PEN_BLACKDASHED,
        PEN_BLUE,
        PEN_CYAN,
        PEN_GREEN,
        PEN_YELLOW,
        PEN_GREY,
        PEN_LIGHTGREY,
        PEN_MEDIUMGREY,
        PEN_RED,
        PEN_TRANSPARENT,
        PEN_WHITE,
        ITEMCOUNT
    };

    wxStockGDI();
    virtual ~wxStockGDI();
    static void DeleteAll();

    static wxStockGDI& instance() { return *ms_instance; }

    static const wxBrush* GetBrush(Item item);
    static const wxColour* GetColour(Item item);
    static const wxCursor* GetCursor(Item item);

    virtual const wxFont* GetFont(Item item);
    static const wxPen* GetPen(Item item);

protected:
    static wxStockGDI* ms_instance;

    static wxObject* ms_stockObject[ITEMCOUNT];

    private: wxStockGDI(const wxStockGDI&); wxStockGDI& operator=(const wxStockGDI&);
};
# 1064 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdicmn.h"
extern wxBitmap wxNullBitmap;
extern wxIcon wxNullIcon;
extern wxCursor wxNullCursor;
extern wxPen wxNullPen;
extern wxBrush wxNullBrush;
extern wxPalette wxNullPalette;
extern wxFont wxNullFont;
extern wxColour wxNullColour;
extern wxIconBundle wxNullIconBundle;

extern wxColourDatabase* wxTheColourDatabase;

extern const char wxPanelNameStr[];

extern const wxSize wxDefaultSize;
extern const wxPoint wxDefaultPosition;






extern void wxInitializeStockLists();
extern void wxDeleteStockLists();


extern bool wxColourDisplay();


extern int wxDisplayDepth();



extern void wxDisplaySize(int *width, int *height);
extern wxSize wxGetDisplaySize();
extern void wxDisplaySizeMM(int *width, int *height);
extern wxSize wxGetDisplaySizeMM();
extern wxSize wxGetDisplayPPI();


extern void wxClientDisplayRect(int *x, int *y, int *width, int *height);
extern wxRect wxGetClientDisplayRect();


extern void wxSetCursor(const wxCursor& cursor);
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h" 1
# 38 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/cursor.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/cursor.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 1
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdiobj.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdiobj.h"
class wxGDIRefData : public wxObjectRefData
{
public:


    wxGDIRefData() { }



    virtual bool IsOk() const { return true; }

private:
    private: wxGDIRefData(const wxGDIRefData&); wxGDIRefData& operator=(const wxGDIRefData&);
};





class wxGDIObject : public wxObject
{
public:

    virtual bool IsOk() const
    {


        return m_refData && static_cast<wxGDIRefData *>(m_refData)->IsOk();
    }


    bool IsNull() const { return m_refData == 
# 53 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdiobj.h" 3 4
                                             __null
# 53 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/gdiobj.h"
                                                 ; }



    bool Ok() const { return IsOk(); }



    virtual bool RealizeResource() { return false; }


    virtual bool FreeResource(bool = false) { return false; }

    virtual bool IsFree() const { return false; }


    virtual WXHANDLE GetResourceHandle() const { return 0; }


protected:



    virtual wxObjectRefData *CreateRefData() const
    {
        return CreateGDIRefData();
    }

    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const
    {
        return CloneGDIRefData(static_cast<const wxGDIRefData *>(data));
    }

    virtual wxGDIRefData *CreateGDIRefData() const = 0;
    virtual wxGDIRefData *CloneGDIRefData(const wxGDIRefData *data) const = 0;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 2



class wxGDIImageRefData;
class wxGDIImageHandler;
class wxGDIImage;

typedef wxGDIImageHandler _WX_LIST_ITEM_TYPE_wxGDIImageHandlerList; typedef int (*wxSortFuncFor_wxGDIImageHandlerList)(const wxGDIImageHandler **, const wxGDIImageHandler **); class wxwxGDIImageHandlerListNode : public wxNodeBase { public: wxwxGDIImageHandlerListNode(wxListBase *list = 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, wxwxGDIImageHandlerListNode *previous = 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, wxwxGDIImageHandlerListNode *next = 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, wxGDIImageHandler *data = 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxGDIImageHandlerListNode *GetNext() const { return (wxwxGDIImageHandlerListNode *)wxNodeBase::GetNext(); } wxwxGDIImageHandlerListNode *GetPrevious() const { return (wxwxGDIImageHandlerListNode *)wxNodeBase::GetPrevious(); } wxGDIImageHandler *GetData() const { return (wxGDIImageHandler *)wxNodeBase::GetData(); } void SetData(wxGDIImageHandler *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxGDIImageHandlerListNode(const wxwxGDIImageHandlerListNode&); wxwxGDIImageHandlerListNode& operator=(const wxwxGDIImageHandlerListNode&); }; class wxGDIImageHandlerList : public wxListBase { public: typedef wxwxGDIImageHandlerListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxGDIImageHandlerList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxGDIImageHandlerList(const wxGDIImageHandlerList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxGDIImageHandlerList(size_t count, wxGDIImageHandler *elements[]) : wxListBase(count, (void **)elements) { } wxGDIImageHandlerList& operator=(const wxGDIImageHandlerList& list) { if (&list != this) Assign(list); return *this; } wxwxGDIImageHandlerListNode *GetFirst() const { return (wxwxGDIImageHandlerListNode *)wxListBase::GetFirst(); } wxwxGDIImageHandlerListNode *GetLast() const { return (wxwxGDIImageHandlerListNode *)wxListBase::GetLast(); } wxwxGDIImageHandlerListNode *Item(size_t index) const { return (wxwxGDIImageHandlerListNode *)wxListBase::Item(index); } wxGDIImageHandler *operator[](size_t index) const { wxwxGDIImageHandlerListNode *node = Item(index); return node ? (wxGDIImageHandler*)(node->GetData()) : 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
; } wxwxGDIImageHandlerListNode *Append(wxGDIImageHandler *object) { return (wxwxGDIImageHandlerListNode *)wxListBase::Append(object); } wxwxGDIImageHandlerListNode *Insert(wxGDIImageHandler *object) { return (wxwxGDIImageHandlerListNode *)Insert(static_cast<wxwxGDIImageHandlerListNode *>(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
), object); } wxwxGDIImageHandlerListNode *Insert(size_t pos, wxGDIImageHandler *object) { return (wxwxGDIImageHandlerListNode *)wxListBase::Insert(pos, object); } wxwxGDIImageHandlerListNode *Insert(wxwxGDIImageHandlerListNode *prev, wxGDIImageHandler *object) { return (wxwxGDIImageHandlerListNode *)wxListBase::Insert(prev, object); } wxwxGDIImageHandlerListNode *Append(long key, void *object) { return (wxwxGDIImageHandlerListNode *)wxListBase::Append(key, object); } wxwxGDIImageHandlerListNode *Append(const wxChar *key, void *object) { return (wxwxGDIImageHandlerListNode *)wxListBase::Append(key, object); } wxwxGDIImageHandlerListNode *DetachNode(wxwxGDIImageHandlerListNode *node) { return (wxwxGDIImageHandlerListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxGDIImageHandlerListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxGDIImageHandler *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxGDIImageHandlerListNode *it) { DeleteNode(it); } wxwxGDIImageHandlerListNode *Find(const wxGDIImageHandler *object) const { return (wxwxGDIImageHandlerListNode *)wxListBase::Find(object); } virtual wxwxGDIImageHandlerListNode *Find(const wxListKey& key) const { return (wxwxGDIImageHandlerListNode *)wxListBase::Find(key); } bool Member(const wxGDIImageHandler *object) const { return Find(object) != 
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
; } int IndexOf(wxGDIImageHandler *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxGDIImageHandlerList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxGDIImageHandlerListNode(this, (wxwxGDIImageHandlerListNode *)prev, (wxwxGDIImageHandlerListNode *)next, (wxGDIImageHandler *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxGDIImageHandler* value_type; typedef wxGDIImageHandler* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxGDIImageHandlerList list; public: typedef wxwxGDIImageHandlerListNode Node; typedef iterator itor; typedef wxGDIImageHandler* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
), m_init(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h", 26, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h", 26, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxGDIImageHandlerList list; public: typedef wxwxGDIImageHandlerListNode Node; typedef wxGDIImageHandler* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
), m_init(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h", 26, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h", 26, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxGDIImageHandlerList list; public: typedef wxwxGDIImageHandlerListNode Node; typedef wxGDIImageHandler* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
), m_init(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxGDIImageHandlerList list; public: typedef wxwxGDIImageHandlerListNode Node; typedef wxGDIImageHandler* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
), m_init(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxGDIImageHandlerList(size_type n, const_reference v = value_type()) { assign(n, v); } wxGDIImageHandlerList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
__null
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxGDIImageHandlerList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxGDIImageHandlerList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxGDIImageHandlerList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





class wxGDIImageRefData : public wxGDIRefData
{
public:
    wxGDIImageRefData()
    {
        m_width = m_height = m_depth = 0;

        m_handle = 0;
    }

    wxGDIImageRefData(const wxGDIImageRefData& data) : wxGDIRefData()
    {
        m_width = data.m_width;
        m_height = data.m_height;
        m_depth = data.m_depth;


        m_handle = 
# 49 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
                  __null
# 49 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
                      ;
    }


    virtual bool IsOk() const { return m_handle != 0; }

    void SetSize(int w, int h) { m_width = w; m_height = h; }


    virtual void Free() = 0;




    int m_width, m_height;


    int m_depth;


    union
    {
        WXHANDLE m_handle;
        WXHBITMAP m_hBitmap;
        WXHICON m_hIcon;
        WXHCURSOR m_hCursor;
    };
};







class wxGDIImage : public wxGDIObject
{
public:

    static wxGDIImageHandlerList& GetHandlers() { return ms_handlers; }

    static void AddHandler(wxGDIImageHandler *handler);
    static void InsertHandler(wxGDIImageHandler *handler);
    static bool RemoveHandler(const wxString& name);

    static wxGDIImageHandler *FindHandler(const wxString& name);
    static wxGDIImageHandler *FindHandler(const wxString& extension, long type);
    static wxGDIImageHandler *FindHandler(long type);

    static void InitStandardHandlers();
    static void CleanUpHandlers();


    wxGDIImageRefData *GetGDIImageData() const
        { return (wxGDIImageRefData *)m_refData; }


    WXHANDLE GetHandle() const
        { return IsNull() ? 0 : GetGDIImageData()->m_handle; }
    void SetHandle(WXHANDLE handle)
        { AllocExclusive(); GetGDIImageData()->m_handle = handle; }

    int GetWidth() const { return IsNull() ? 0 : GetGDIImageData()->m_width; }
    int GetHeight() const { return IsNull() ? 0 : GetGDIImageData()->m_height; }
    int GetDepth() const { return IsNull() ? 0 : GetGDIImageData()->m_depth; }

    wxSize GetSize() const
    {
        return IsNull() ? wxSize(0,0) :
               wxSize(GetGDIImageData()->m_width, GetGDIImageData()->m_height);
    }

    void SetWidth(int w) { AllocExclusive(); GetGDIImageData()->m_width = w; }
    void SetHeight(int h) { AllocExclusive(); GetGDIImageData()->m_height = h; }
    void SetDepth(int d) { AllocExclusive(); GetGDIImageData()->m_depth = d; }

    void SetSize(int w, int h)
    {
        AllocExclusive();
        GetGDIImageData()->SetSize(w, h);
    }
    void SetSize(const wxSize& size) { SetSize(size.x, size.y); }


    bool FreeResource(bool force = false);
    virtual WXHANDLE GetResourceHandle() const;

protected:

    virtual wxGDIImageRefData *CreateData() const = 0;


    virtual wxGDIRefData *CreateGDIRefData() const { return CreateData(); }


    virtual wxGDIRefData *
    CloneGDIRefData(const wxGDIRefData *) const
    {
        do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h", 147, __FUNCTION__, "Assert failure", L"must be implemented if used"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

        return 
# 149 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h" 3 4
              __null
# 149 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/gdiimage.h"
                  ;
    }

    static wxGDIImageHandlerList ms_handlers;
};





class wxGDIImageHandler : public wxObject
{
public:

    wxGDIImageHandler() { m_type = wxBITMAP_TYPE_INVALID; }
    wxGDIImageHandler(const wxString& name,
                      const wxString& ext,
                      wxBitmapType type)
        : m_name(name), m_extension(ext), m_type(type) { }


    void SetName(const wxString& name) { m_name = name; }
    void SetExtension(const wxString& ext) { m_extension = ext; }
    void SetType(wxBitmapType type) { m_type = type; }

    const wxString& GetName() const { return m_name; }
    const wxString& GetExtension() const { return m_extension; }
    wxBitmapType GetType() const { return m_type; }


    virtual bool Create(wxGDIImage *image,
                        const void* data,
                        wxBitmapType flags,
                        int width, int height, int depth = 1) = 0;
    virtual bool Load(wxGDIImage *image,
                      const wxString& name,
                      wxBitmapType flags,
                      int desiredWidth, int desiredHeight) = 0;
    virtual bool Save(const wxGDIImage *image,
                      const wxString& name,
                      wxBitmapType type) const = 0;

protected:
    wxString m_name;
    wxString m_extension;
    wxBitmapType m_type;
};
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/cursor.h" 2

class wxImage;


class wxCursor : public wxGDIImage
{
public:

    wxCursor();
    wxCursor(const wxImage& image);
    wxCursor(const wxString& name,
             wxBitmapType type = wxBITMAP_TYPE_CUR_RESOURCE,
             int hotSpotX = 0, int hotSpotY = 0);
    wxCursor(wxStockCursor id) { InitFromStock(id); }

    wxCursor(int id) { InitFromStock((wxStockCursor)id); }

    virtual ~wxCursor();


    void SetHCURSOR(WXHCURSOR cursor) { SetHandle((WXHANDLE)cursor); }
    WXHCURSOR GetHCURSOR() const { return (WXHCURSOR)GetHandle(); }

protected:
    void InitFromStock(wxStockCursor);

    virtual wxGDIImageRefData *CreateData() const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 39 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h" 2
# 69 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
inline int wxStringSortAscending(wxString* s1, wxString* s2)
{
    return s1->Cmp(*s2);
}

inline int wxStringSortDescending(wxString* s1, wxString* s2)
{
    return wxStringSortAscending(s2, s1);
}
# 115 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/beforestd.h" 1
# 116 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 2
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 1 3
# 58 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 3
       
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 3





# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 3





# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3






# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
namespace std
{

# 62 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    locale() throw();
# 126 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.tcc" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.tcc" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_classes.h" 2 3
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 2 3




# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 3






# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/error_constants.h" 1 3
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/error_constants.h" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cerrno" 3
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/error_constants.h" 2 3

namespace std
{




  enum class errc
    {
      address_family_not_supported = 102,
      address_in_use = 100,
      address_not_available = 101,
      already_connected = 113,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,

      bad_message = 104,

      broken_pipe = 32,
      connection_aborted = 106,
      connection_already_in_progress = 103,
      connection_refused = 107,
      connection_reset = 108,
      cross_device_link = 18,
      destination_address_required = 109,
      device_or_resource_busy = 16,
      directory_not_empty = 41,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 38,
      function_not_supported = 40,
      host_unreachable = 110,

      identifier_removed = 111,

      illegal_byte_sequence = 42,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 115,
      network_down = 116,
      network_reset = 117,
      network_unreachable = 118,
      no_buffer_space = 119,

      no_child_process = 10,


      no_link = 121,

      no_lock_available = 39,

      no_message_available = 120,




      no_protocol_option = 123,

      no_space_on_device = 28,


      no_stream_resources = 124,

      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 128,

      not_a_stream = 125,

      not_connected = 126,
      not_enough_memory = 12,

      not_supported = 129,

      operation_canceled = 105,
      operation_in_progress = 112,

      operation_not_permitted = 1,

      operation_not_supported = 130,

      operation_would_block = 140,


      owner_dead = 133,

      permission_denied = 13,
      protocol_error = 134,
      protocol_not_supported = 135,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 36,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,

      state_not_recoverable = 127,


      stream_timeout = 137,


      text_file_busy = 139,


      timed_out = 138,

      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 114,

      value_too_large = 132,

      wrong_protocol_type = 136
   };


}
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 2 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdexcept" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdexcept" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdexcept" 3




namespace std
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 2 3

namespace std
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 414 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/system_error" 3

}
# 47 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 2 3


namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
  class ios_base
  {
# 246 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
  public:
# 255 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 631 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 647 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 664 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 690 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 741 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 753 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 764 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 775 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 794 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 810 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 831 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 848 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 862 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
# 45 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
namespace std
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf.tcc" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf.tcc" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/streambuf" 2 3
# 44 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwctype" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwctype" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwctype" 3
# 80 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 1 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 3
       
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/cctype" 3
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/ctype_base.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);

    static const mask blank = 1 << 10;

  };


}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3






# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf_iterator.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf_iterator.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf_iterator.h" 3




namespace std
{

# 49 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 139 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      ;
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3

namespace std
{

# 71 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1156 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/ctype_inline.h" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32/bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2505 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/locale_facets.h" 2 3
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 2 3



namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.tcc" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.tcc" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/basic_ios.h" 2 3
# 45 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ios" 2 3
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 2 3


namespace std
{

# 57 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      flush();
# 357 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      pos_type
      tellp();
# 368 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream.tcc" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream.tcc" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream" 2 3
# 65 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3




namespace std
{

# 57 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      int_type
      get();
# 315 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      int_type
      peek();
# 485 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      unget();
# 555 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      int
      sync();
# 570 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      pos_type
      tellg();
# 585 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/istream.tcc" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/istream.tcc" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/istream" 2 3
# 66 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stream_iterator.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stream_iterator.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stream_iterator.h" 3



namespace std
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(std::__addressof(__s))
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return std::__addressof((operator*())); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 184 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iterator" 2 3
# 117 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 2
# 118 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 2



# 120 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
class wxArrayString
{
public:

  typedef int ( *CompareFunction)(const wxString& first,
                                 const wxString& second);


  typedef int ( *CompareFunction2)(wxString* first,
                                  wxString* second);



  wxArrayString() { Init(false); }
# 142 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
  explicit wxArrayString(int autoSort) { Init(autoSort != 0); }

  wxArrayString(size_t sz, const char** a);
  wxArrayString(size_t sz, const wchar_t** a);

  wxArrayString(size_t sz, const wxString* a);

  wxArrayString(const wxArrayString& array);

  wxArrayString& operator=(const wxArrayString& src);

 ~wxArrayString();



  void Empty();

  void Clear();

  void Alloc(size_t nCount);

  void Shrink();



  size_t GetCount() const { return m_nCount; }

  bool IsEmpty() const { return m_nCount == 0; }

  size_t Count() const { return m_nCount; }



  wxString& Item(size_t nIndex)
    {
        do { if ( wxTheAssertHandler && !(nIndex < m_nCount) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
# 177 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
        ,
 178
# 177 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
        , __FUNCTION__, "nIndex < m_nCount", L"wxArrayString: index out of bounds"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                 ;

        return m_pItems[nIndex];
    }
  const wxString& Item(size_t nIndex) const { return const_cast<wxArrayString*>(this)->Item(nIndex); }


  wxString& operator[](size_t nIndex) { return Item(nIndex); }
  const wxString& operator[](size_t nIndex) const { return Item(nIndex); }

  wxString& Last()
  {
      do { if ( wxTheAssertHandler && !(!IsEmpty()) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
# 190 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
      ,
 191
# 190 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
      , __FUNCTION__, "!IsEmpty()", L"wxArrayString: index out of bounds"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                               ;
      return Item(GetCount() - 1);
  }
  const wxString& Last() const { return const_cast<wxArrayString*>(this)->Last(); }







  int Index (const wxString& str, bool bCase = true, bool bFromEnd = false) const;


  size_t Add(const wxString& str, size_t nInsert = 1);

  void Insert(const wxString& str, size_t uiIndex, size_t nInsert = 1);

  void SetCount(size_t count);

  void Remove(const wxString& sz);

  void RemoveAt(size_t nIndex, size_t nRemove = 1);




  void Sort(bool reverseOrder = false);

  void Sort(CompareFunction compareFunction);
  void Sort(CompareFunction2 compareFunction);



  bool operator==(const wxArrayString& a) const;

  bool operator!=(const wxArrayString& a) const { return !(*this == a); }


  typedef wxString value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef int difference_type;
  typedef size_t size_type;


  class reverse_iterator
  {
    typedef wxString value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    reverse_iterator() : m_ptr(
# 253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 3 4
                              __null
# 253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
                                  ) { }
    explicit reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { reverse_iterator tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  class const_reverse_iterator
  {
    typedef wxString value_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef const_reverse_iterator itor;
    friend itor operator+(int o, const itor& it);
    friend itor operator+(const itor& it, int o);
    friend itor operator-(const itor& it, int o);
    friend difference_type operator -(const itor& i1, const itor& i2);
  public:
    pointer m_ptr;
    const_reverse_iterator() : m_ptr(
# 279 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 3 4
                                    __null
# 279 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
                                        ) { }
    explicit const_reverse_iterator(pointer ptr) : m_ptr(ptr) { }
    const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { }
    const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { }
    reference operator*() const { return *m_ptr; }
    pointer operator->() const { return m_ptr; }
    itor& operator++() { --m_ptr; return *this; }
    const itor operator++(int)
      { itor tmp = *this; --m_ptr; return tmp; }
    itor& operator--() { ++m_ptr; return *this; }
    const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; }
    bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; }
    bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; }
  };

  wxArrayString(const_iterator first, const_iterator last)
    { Init(false); assign(first, last); }
  wxArrayString(size_type n, const_reference v) { Init(false); assign(n, v); }


  template <class Iterator>
  void assign(Iterator first, Iterator last)
  {
      clear();
      reserve(std::distance(first, last));
      for(; first != last; ++first)
          push_back(*first);
  }
# 317 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
  void assign(size_type n, const_reference v)
    { clear(); Add(v, n); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  iterator begin() { return m_pItems; }
  const_iterator begin() const { return m_pItems; }
  size_type capacity() const { return m_nSize; }
  void clear() { Clear(); }
  bool empty() const { return IsEmpty(); }
  iterator end() { return begin() + GetCount(); }
  const_iterator end() const { return begin() + GetCount(); }
  iterator erase(iterator first, iterator last)
  {
      size_t idx = first - begin();
      RemoveAt(idx, last - first);
      return begin() + idx;
  }
  iterator erase(iterator it) { return erase(it, it + 1); }
  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  void insert(iterator it, size_type n, const_reference v)
    { Insert(v, it - begin(), n); }
  iterator insert(iterator it, const_reference v = value_type())
    { size_t idx = it - begin(); Insert(v, idx); return begin() + idx; }
  void insert(iterator it, const_iterator first, const_iterator last);
  size_type max_size() const { return 0x7fffffff; }
  void pop_back() { RemoveAt(GetCount() - 1); }
  void push_back(const_reference v) { Add(v); }
  reverse_iterator rbegin() { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(end() - 1); }
  reverse_iterator rend() { return reverse_iterator(begin() - 1); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(begin() - 1); }
  void reserve(size_type n) ;
  void resize(size_type n, value_type v = value_type());
  size_type size() const { return GetCount(); }
  void swap(wxArrayString& other)
  {
      wxSwap(m_nSize, other.m_nSize);
      wxSwap(m_nCount, other.m_nCount);
      wxSwap(m_pItems, other.m_pItems);
      wxSwap(m_autoSort, other.m_autoSort);
  }

protected:
  void Init(bool autoSort);
  void Copy(const wxArrayString& src);

private:



  wxString *Grow(size_t nIncrement);

  size_t m_nSize,
          m_nCount;

  wxString *m_pItems;

  bool m_autoSort;
};

class wxSortedArrayString : public wxArrayString
{
public:
  wxSortedArrayString() : wxArrayString(true)
    { }
  wxSortedArrayString(const wxArrayString& array) : wxArrayString(true)
    { Copy(array); }
};





class wxCArrayString
{
public:
    wxCArrayString( const wxArrayString& array )
        : m_array( array ), m_strings( 
# 397 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 3 4
                                      __null 
# 397 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
                                           )
    { }
    ~wxCArrayString() { delete[] m_strings; }

    size_t GetCount() const { return m_array.GetCount(); }
    wxString* GetStrings()
    {
        if( m_strings ) return m_strings;
        size_t count = m_array.GetCount();
        m_strings = new wxString[count];
        for( size_t i = 0; i < count; ++i )
            m_strings[i] = m_array[i];
        return m_strings;
    }

    wxString* Release()
    {
        wxString *r = GetStrings();
        m_strings = 
# 415 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h" 3 4
                   __null
# 415 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
                       ;
        return r;
    }

private:
    const wxArrayString& m_array;
    wxString* m_strings;
};
# 433 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
 wxString wxJoin(const wxArrayString& arr,
                                 const wxChar sep,
                                 const wxChar escape = L'\\');

 wxArrayString wxSplit(const wxString& str,
                                       const wxChar sep,
                                       const wxChar escape = L'\\');
# 456 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h"
class wxArrayStringsAdapter
{
public:

    wxArrayStringsAdapter(const wxArrayString& strings)
        : m_type(wxSTRING_ARRAY), m_size(strings.size())
    {
        m_data.array = &strings;
    }


    wxArrayStringsAdapter(unsigned int n, const wxString *strings)
        : m_type(wxSTRING_POINTER), m_size(n)
    {
        m_data.ptr = strings;
    }


    wxArrayStringsAdapter(const wxString& s)
        : m_type(wxSTRING_POINTER), m_size(1)
    {
        m_data.ptr = &s;
    }




    size_t GetCount() const { return m_size; }
    bool IsEmpty() const { return GetCount() == 0; }
    const wxString& operator[] (unsigned int i) const
    {
        do { if ( wxTheAssertHandler && !(i < GetCount()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/arrstr.h", 487, __FUNCTION__, "i < GetCount()", L"index out of bounds"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        if(m_type == wxSTRING_POINTER)
            return m_data.ptr[i];
        return m_data.array->Item(i);
    }
    wxArrayString AsArrayString() const
    {
        if(m_type == wxSTRING_ARRAY)
            return *m_data.array;
        return wxArrayString(GetCount(), m_data.ptr);
    }

private:

    enum wxStringContainerType
    {
        wxSTRING_ARRAY,
        wxSTRING_POINTER
    };

    wxStringContainerType m_type;
    size_t m_size;
    union
    {
        const wxString * ptr;
        const wxArrayString * array;
    } m_data;

    private: wxArrayStringsAdapter& operator=(const wxArrayStringsAdapter&);
};
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 2
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 1 3
# 16 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
#pragma pack(push,_CRT_PACKING)



# 19 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
extern "C" {
# 69 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fstat32(int _FileDes,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stat32(const char *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fstat64(int _FileDes,struct _stat64 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fstat32i64(int _FileDes,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _fstat64i32(int _FileDes,struct _stat64i32 *_Stat);
# 97 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stat64(const char *_Name,struct _stat64 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stat32i64(const char *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _stat64i32(const char *_Name,struct _stat64i32 *_Stat);
# 174 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
int __attribute__((__cdecl__)) fstat(int _Desc,struct stat *_Stat);
# 185 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
int __attribute__((__cdecl__)) stat(const char *_Filename,struct stat *_Stat);
int __attribute__((__cdecl__)) wstat(const wchar_t *_Filename,struct stat *_Stat);
# 285 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/sys/stat.h" 3
}


#pragma pack(pop)
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 2
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/fcntl.h" 1 3
# 74 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 2
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"

# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
enum wxSeekMode
{
  wxFromStart,
  wxFromCurrent,
  wxFromEnd
};

enum wxFileKind
{
  wxFILE_KIND_UNKNOWN,
  wxFILE_KIND_DISK,
  wxFILE_KIND_TERMINAL,
  wxFILE_KIND_PIPE
};



enum wxPosixPermissions
{

    wxS_IRUSR = 00400,
    wxS_IWUSR = 00200,
    wxS_IXUSR = 00100,

    wxS_IRGRP = 00040,
    wxS_IWGRP = 00020,
    wxS_IXGRP = 00010,

    wxS_IROTH = 00004,
    wxS_IWOTH = 00002,
    wxS_IXOTH = 00001,


    wxPOSIX_USER_READ = wxS_IRUSR,
    wxPOSIX_USER_WRITE = wxS_IWUSR,
    wxPOSIX_USER_EXECUTE = wxS_IXUSR,

    wxPOSIX_GROUP_READ = wxS_IRGRP,
    wxPOSIX_GROUP_WRITE = wxS_IWGRP,
    wxPOSIX_GROUP_EXECUTE = wxS_IXGRP,

    wxPOSIX_OTHERS_READ = wxS_IROTH,
    wxPOSIX_OTHERS_WRITE = wxS_IWOTH,
    wxPOSIX_OTHERS_EXECUTE = wxS_IXOTH,




    wxS_DEFAULT = (wxPOSIX_USER_READ | wxPOSIX_USER_WRITE |
                   wxPOSIX_GROUP_READ | wxPOSIX_GROUP_WRITE |
                   wxPOSIX_OTHERS_READ | wxPOSIX_OTHERS_WRITE),




    wxS_DIR_DEFAULT = (wxPOSIX_USER_READ | wxPOSIX_USER_WRITE | wxPOSIX_USER_EXECUTE |
                       wxPOSIX_GROUP_READ | wxPOSIX_GROUP_WRITE | wxPOSIX_GROUP_EXECUTE |
                       wxPOSIX_OTHERS_READ | wxPOSIX_OTHERS_WRITE | wxPOSIX_OTHERS_EXECUTE)
};
# 220 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
       
# 243 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
        typedef long long wxFileOffset;
# 422 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
           
           
# 527 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
inline int wxAccess(const wxString& path, mode_t mode)
    { return _waccess(path.fn_str(), mode); }
inline int wxChmod(const wxString& path, mode_t mode)
    { return _wchmod(path.fn_str(), mode); }
inline int wxOpen(const wxString& path, int flags, mode_t mode)
    { return _wopen(path.fn_str(), flags, mode); }



inline int wxStat(const wxString& path, struct 
# 536 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 3
                                       _stat64 
# 536 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
                                                    *buf)
    { return 
# 537 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 3
            _wstat64
# 537 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
                      (path.fn_str(), buf); }
inline int wxLstat(const wxString& path, struct 
# 538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 3
                                        _stat64 
# 538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
                                                     *buf)
    { return 
# 539 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 3
            _wstat64
# 539 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
                       (path.fn_str(), buf); }
inline int wxRmDir(const wxString& path)
    { return _wrmdir(path.fn_str()); }


inline int wxMkDir(const wxString& path, mode_t = 0)
    { return _wmkdir(path.fn_str()); }
# 565 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
const int wxInvalidOffset = -1;





 bool wxFileExists(const wxString& filename);


 bool wxDirExists(const wxString& pathName);

 bool wxIsAbsolutePath(const wxString& filename);


 wxChar* wxFileNameFromPath(wxChar *path);
 wxString wxFileNameFromPath(const wxString& path);


 wxString wxPathOnly(const wxString& path);




__attribute__((deprecated)) void wxDos2UnixFilename(char *s);
__attribute__((deprecated)) void wxDos2UnixFilename(wchar_t *s);

__attribute__((deprecated)) void wxUnix2DosFilename(char *s)
                                                       ;
__attribute__((deprecated)) void wxUnix2DosFilename(wchar_t *s)
                                                          ;




__attribute__((deprecated)) void wxStripExtension(char *buffer);
__attribute__((deprecated)) void wxStripExtension(wchar_t *buffer);
__attribute__((deprecated)) void wxStripExtension(wxString& buffer);


__attribute__((deprecated)) wxChar* wxGetTempFileName(const wxString& prefix, wxChar *buf = 
# 604 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h" 3 4
__null
# 604 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
);
__attribute__((deprecated)) bool wxGetTempFileName(const wxString& prefix, wxString& buf);


__attribute__((deprecated)) char* wxExpandPath(char *dest, const wxString& path);
__attribute__((deprecated)) wchar_t* wxExpandPath(wchar_t *dest, const wxString& path);





__attribute__((deprecated)) wxChar* wxContractPath(const wxString& filename, const wxString& envname = wxEmptyString, const wxString& user = wxEmptyString)


                                                                          ;



__attribute__((deprecated)) char* wxRealPath(char *path);
__attribute__((deprecated)) wchar_t* wxRealPath(wchar_t *path);
__attribute__((deprecated)) wxString wxRealPath(const wxString& path);



__attribute__((deprecated)) wxChar* wxCopyAbsolutePath(const wxString& path);







 wxString wxFindFirstFile(const wxString& spec, int flags = 1);
 wxString wxFindNextFile();


 bool wxIsWild(const wxString& pattern);




 bool wxMatchWild(const wxString& pattern, const wxString& text, bool dot_special = true);


 bool wxConcatFiles(const wxString& file1, const wxString& file2, const wxString& file3);


 bool wxCopyFile(const wxString& file1, const wxString& file2,
                                 bool overwrite = true);


 bool wxRemoveFile(const wxString& file);


 bool wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite = true);
# 670 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
 wxString wxGetCwd();


 bool wxSetWorkingDirectory(const wxString& d);


 bool wxMkdir(const wxString& dir, int perm = wxS_DIR_DEFAULT);


 bool wxRmdir(const wxString& dir, int flags = 0);


 wxFileKind wxGetFileKind(int fd);
 wxFileKind wxGetFileKind(FILE *fp);
# 695 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
 bool wxIsWritable(const wxString &path);
 bool wxIsReadable(const wxString &path);
 bool wxIsExecutable(const wxString &path);
# 745 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
inline bool wxIsPathSeparator(wxChar c)
{




    return c == L'\\' || c == L'/';

}


 bool wxEndsWithPathSeparator(const wxString& filename);





__attribute__((deprecated)) void wxSplitPath(const wxString& fileName, wxString *pstrPath, wxString *pstrName, wxString *pstrExt)


                                                                    ;



 bool wxFindFileInPath(wxString *pStr, const wxString& szPath, const wxString& szFile);



 wxString wxGetOSDirectory();




 time_t wxFileModificationTime(const wxString& filename);
# 787 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
 int wxParseCommonDialogsFilter(const wxString& wildCard, wxArrayString& descriptions, wxArrayString& filters);
# 829 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/filefn.h"
class wxPathList : public wxArrayString
{
public:
    wxPathList() {}
    wxPathList(const wxArrayString &arr)
        { Add(arr); }


    void AddEnvList(const wxString& envVariable);


    bool Add(const wxString& path);
    void Add(const wxArrayString &paths);


    wxString FindValidPath(const wxString& filename) const;



    wxString FindAbsoluteValidPath(const wxString& filename) const;


    bool EnsureFileAccessible(const wxString& path);





};
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/versioninfo.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/versioninfo.h"
class wxVersionInfo
{
public:
    wxVersionInfo(const wxString& name = wxString(),
                  int major = 0,
                  int minor = 0,
                  int micro = 0,
                  const wxString& description = wxString(),
                  const wxString& copyright = wxString())
    {
        m_name = name;
        m_major = major;
        m_minor = minor;
        m_micro = micro;
        m_description = description;
        m_copyright = copyright;
    }




    const wxString& GetName() const { return m_name; }

    int GetMajor() const { return m_major; }
    int GetMinor() const { return m_minor; }
    int GetMicro() const { return m_micro; }

    wxString ToString() const
    {
        return HasDescription() ? GetDescription() : GetVersionString();
    }

    wxString GetVersionString() const
    {
        wxString str;
        str << m_name << ' ' << GetMajor() << '.' << GetMinor();
        if ( GetMicro() )
            str << '.' << GetMicro();

        return str;
    }

    bool HasDescription() const { return !m_description.empty(); }
    const wxString& GetDescription() const { return m_description; }

    bool HasCopyright() const { return !m_copyright.empty(); }
    const wxString& GetCopyright() const { return m_copyright; }

private:
    wxString m_name,
             m_description,
             m_copyright;

    int m_major,
        m_minor,
        m_micro;
};
# 23 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/implicitconversion.h" 1
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/implicitconversion.h"
namespace wxPrivate
{
# 42 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/implicitconversion.h"
template<typename T>
struct TypeHierarchy
{


    static const int level = 9999;
};







template<> struct TypeHierarchy<char> { static const int level = 1; };
template<> struct TypeHierarchy<unsigned char> { static const int level = 2; };
template<> struct TypeHierarchy<short> { static const int level = 3; };
template<> struct TypeHierarchy<unsigned short> { static const int level = 4; };
template<> struct TypeHierarchy<int> { static const int level = 5; };
template<> struct TypeHierarchy<unsigned int> { static const int level = 6; };
template<> struct TypeHierarchy<long> { static const int level = 7; };
template<> struct TypeHierarchy<unsigned long> { static const int level = 8; };

template<> struct TypeHierarchy<long long> { static const int level = 9; };
template<> struct TypeHierarchy<unsigned long long> { static const int level = 10; };

template<> struct TypeHierarchy<float> { static const int level = 11; };
template<> struct TypeHierarchy<double> { static const int level = 12; };
template<> struct TypeHierarchy<long double> { static const int level = 13; };



      template<> struct TypeHierarchy<wchar_t> : public TypeHierarchy<short> {};
# 86 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/implicitconversion.h"
}



template<typename T1, typename T2>
struct wxImplicitConversionType
{
    typedef typename wxIf
            <

                (int)(wxPrivate::TypeHierarchy<T1>::level) < (int)(wxPrivate::TypeHierarchy<T2>::level),
                T2,

                T1
            >::value
            value;
};


template<typename T1, typename T2, typename T3>
struct wxImplicitConversionType3 : public wxImplicitConversionType<
                        T1,
                        typename wxImplicitConversionType<T2,T3>::value>
{
};
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/mousestate.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/mousestate.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/kbdstate.h" 1
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/kbdstate.h"
class wxKeyboardState
{
public:
    wxKeyboardState(bool controlDown = false,
                    bool shiftDown = false,
                    bool altDown = false,
                    bool metaDown = false)
        : m_controlDown(controlDown),
          m_shiftDown(shiftDown),
          m_altDown(altDown),
          m_metaDown(metaDown)



    {
    }
# 45 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/kbdstate.h"
    int GetModifiers() const
    {
        return (m_controlDown ? wxMOD_CONTROL : 0) |
               (m_shiftDown ? wxMOD_SHIFT : 0) |
               (m_metaDown ? wxMOD_META : 0) |



               (m_altDown ? wxMOD_ALT : 0);
    }


    bool HasAnyModifiers() const { return GetModifiers() != wxMOD_NONE; }



    bool HasModifiers() const
    {
        return ControlDown() || RawControlDown() || AltDown();
    }


    bool ControlDown() const { return m_controlDown; }
    bool RawControlDown() const
    {



        return m_controlDown;

    }
    bool ShiftDown() const { return m_shiftDown; }
    bool MetaDown() const { return m_metaDown; }
    bool AltDown() const { return m_altDown; }






    bool CmdDown() const
    {
        return ControlDown();
    }




    void SetControlDown(bool down) { m_controlDown = down; }
    void SetRawControlDown(bool down)
    {



        m_controlDown = down;

    }
    void SetShiftDown(bool down) { m_shiftDown = down; }
    void SetAltDown(bool down) { m_altDown = down; }
    void SetMetaDown(bool down) { m_metaDown = down; }





public:
    bool m_controlDown : 1;
    bool m_shiftDown : 1;
    bool m_altDown : 1;
    bool m_metaDown : 1;



};
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/mousestate.h" 2


enum wxMouseButton
{
    wxMOUSE_BTN_ANY = -1,
    wxMOUSE_BTN_NONE = 0,
    wxMOUSE_BTN_LEFT = 1,
    wxMOUSE_BTN_MIDDLE = 2,
    wxMOUSE_BTN_RIGHT = 3,
    wxMOUSE_BTN_AUX1 = 4,
    wxMOUSE_BTN_AUX2 = 5,
    wxMOUSE_BTN_MAX
};
# 36 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/mousestate.h"
class wxMouseState : public wxKeyboardState
{
public:
    wxMouseState()
        : m_leftDown(false), m_middleDown(false), m_rightDown(false),
          m_aux1Down(false), m_aux2Down(false),
          m_x(0), m_y(0)
    {
    }





    wxCoord GetX() const { return m_x; }
    wxCoord GetY() const { return m_y; }
    wxPoint GetPosition() const { return wxPoint(m_x, m_y); }
    void GetPosition(wxCoord *x, wxCoord *y) const
    {
        if ( x )
            *x = m_x;
        if ( y )
            *y = m_y;
    }


    void GetPosition(long *x, long *y) const
    {
        if ( x )
            *x = m_x;
        if ( y )
            *y = m_y;
    }


    bool LeftIsDown() const { return m_leftDown; }
    bool MiddleIsDown() const { return m_middleDown; }
    bool RightIsDown() const { return m_rightDown; }
    bool Aux1IsDown() const { return m_aux1Down; }
    bool Aux2IsDown() const { return m_aux2Down; }

    bool ButtonIsDown(wxMouseButton but) const
    {
        switch ( but )
        {
            case wxMOUSE_BTN_ANY:
                return LeftIsDown() || MiddleIsDown() || RightIsDown() ||
                            Aux1IsDown() || Aux2IsDown();

            case wxMOUSE_BTN_LEFT:
                return LeftIsDown();

            case wxMOUSE_BTN_MIDDLE:
                return MiddleIsDown();

            case wxMOUSE_BTN_RIGHT:
                return RightIsDown();

            case wxMOUSE_BTN_AUX1:
                return Aux1IsDown();

            case wxMOUSE_BTN_AUX2:
                return Aux2IsDown();

            case wxMOUSE_BTN_NONE:
            case wxMOUSE_BTN_MAX:
                break;
        }

        do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/mousestate.h", 105, __FUNCTION__, "Assert failure", L"invalid parameter"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return false;
    }



    void SetX(wxCoord x) { m_x = x; }
    void SetY(wxCoord y) { m_y = y; }
    void SetPosition(wxPoint pos) { m_x = pos.x; m_y = pos.y; }

    void SetLeftDown(bool down) { m_leftDown = down; }
    void SetMiddleDown(bool down) { m_middleDown = down; }
    void SetRightDown(bool down) { m_rightDown = down; }
    void SetAux1Down(bool down) { m_aux1Down = down; }
    void SetAux2Down(bool down) { m_aux2Down = down; }


    void SetState(const wxMouseState& state) { *this = state; }






    __attribute__((deprecated)) bool LeftDown() const { return LeftIsDown(); }
    __attribute__((deprecated)) bool MiddleDown() const { return MiddleIsDown(); }
    __attribute__((deprecated)) bool RightDown() const { return RightIsDown(); }






    bool m_leftDown : 1;
    bool m_middleDown : 1;
    bool m_rightDown : 1;
    bool m_aux1Down : 1;
    bool m_aux2Down : 1;

    wxCoord m_x,
            m_y;
};
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2


class wxArrayString;
class wxArrayInt;



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 1
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 2
# 88 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    class wxLongLongNative;
    class wxULongLongNative;
    typedef wxLongLongNative wxLongLong;
    typedef wxULongLongNative wxULongLong;
# 102 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 1
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 2
# 103 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 2



class wxLongLongNative
{
public:


    wxLongLongNative() : m_ll(0) { }

    wxLongLongNative(long long ll) : m_ll(ll) { }

    wxLongLongNative(wxInt32 hi, wxUint32 lo)
    {

        m_ll = ((long long) hi) << 32;
        m_ll |= (long long) lo;
    }
# 132 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    wxLongLongNative& operator=(long long ll)
        { m_ll = ll; return *this; }
    wxLongLongNative& operator=(unsigned long long ll)
        { m_ll = ll; return *this; }

    wxLongLongNative& operator=(const wxULongLongNative &ll);
    wxLongLongNative& operator=(int l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(long l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(unsigned int l)
        { m_ll = l; return *this; }
    wxLongLongNative& operator=(unsigned long l)
        { m_ll = l; return *this; }
# 155 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    wxLongLongNative& Assign(double d)
        { m_ll = (long long)d; return *this; }





    wxInt32 GetHi() const
        { return ((wxInt32)(m_ll >> 32)); }

    wxUint32 GetLo() const
        { return ((wxUint32)(m_ll)); }


    wxLongLongNative Abs() const { return wxLongLongNative(*this).Abs(); }
    wxLongLongNative& Abs() { if ( m_ll < 0 ) m_ll = -m_ll; return *this; }


    long long GetValue() const { return m_ll; }


    long ToLong() const
    {
        do { if ( wxTheAssertHandler && !((m_ll >= 
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 3 4
       (-0x7fffffffL - 1L)
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
       ) && (m_ll <= 0x7fffffffL)) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
        ,
 179
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
        , __FUNCTION__, "(m_ll >= LONG_MIN) && (m_ll <= LONG_MAX)", L"wxLongLong to long conversion loss of precision"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                              ;

        return ((long)(m_ll));
    }


    double ToDouble() const { return ((double)(m_ll)); }







    wxLongLongNative operator+(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll + ll.m_ll); }
    wxLongLongNative& operator+=(const wxLongLongNative& ll)
        { m_ll += ll.m_ll; return *this; }

    wxLongLongNative operator+(const long long ll) const
        { return wxLongLongNative(m_ll + ll); }
    wxLongLongNative& operator+=(const long long ll)
        { m_ll += ll; return *this; }


    wxLongLongNative& operator++()
        { m_ll++; return *this; }


    wxLongLongNative operator++(int)
        { wxLongLongNative value(*this); m_ll++; return value; }


    wxLongLongNative operator-() const
        { return wxLongLongNative(-m_ll); }
    wxLongLongNative& Negate() { m_ll = -m_ll; return *this; }


    wxLongLongNative operator-(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll - ll.m_ll); }
    wxLongLongNative& operator-=(const wxLongLongNative& ll)
        { m_ll -= ll.m_ll; return *this; }

    wxLongLongNative operator-(const long long ll) const
        { return wxLongLongNative(m_ll - ll); }
    wxLongLongNative& operator-=(const long long ll)
        { m_ll -= ll; return *this; }


    wxLongLongNative& operator--()
        { m_ll--; return *this; }


    wxLongLongNative operator--(int)
        { wxLongLongNative value(*this); m_ll--; return value; }



    wxLongLongNative operator<<(int shift) const
        { return wxLongLongNative(m_ll << shift); }
    wxLongLongNative& operator<<=(int shift)
        { m_ll <<= shift; return *this; }


    wxLongLongNative operator>>(int shift) const
        { return wxLongLongNative(m_ll >> shift); }
    wxLongLongNative& operator>>=(int shift)
        { m_ll >>= shift; return *this; }


    wxLongLongNative operator&(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll & ll.m_ll); }
    wxLongLongNative& operator&=(const wxLongLongNative& ll)
        { m_ll &= ll.m_ll; return *this; }

    wxLongLongNative operator|(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll | ll.m_ll); }
    wxLongLongNative& operator|=(const wxLongLongNative& ll)
        { m_ll |= ll.m_ll; return *this; }

    wxLongLongNative operator^(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll ^ ll.m_ll); }
    wxLongLongNative& operator^=(const wxLongLongNative& ll)
        { m_ll ^= ll.m_ll; return *this; }


    wxLongLongNative operator*(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll * ll.m_ll); }
    wxLongLongNative operator*(long l) const
        { return wxLongLongNative(m_ll * l); }
    wxLongLongNative& operator*=(const wxLongLongNative& ll)
        { m_ll *= ll.m_ll; return *this; }
    wxLongLongNative& operator*=(long l)
        { m_ll *= l; return *this; }

    wxLongLongNative operator/(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll / ll.m_ll); }
    wxLongLongNative operator/(long l) const
        { return wxLongLongNative(m_ll / l); }
    wxLongLongNative& operator/=(const wxLongLongNative& ll)
        { m_ll /= ll.m_ll; return *this; }
    wxLongLongNative& operator/=(long l)
        { m_ll /= l; return *this; }

    wxLongLongNative operator%(const wxLongLongNative& ll) const
        { return wxLongLongNative(m_ll % ll.m_ll); }
    wxLongLongNative operator%(long l) const
        { return wxLongLongNative(m_ll % l); }


    bool operator==(const wxLongLongNative& ll) const
        { return m_ll == ll.m_ll; }
    bool operator==(long l) const
        { return m_ll == l; }
    bool operator!=(const wxLongLongNative& ll) const
        { return m_ll != ll.m_ll; }
    bool operator!=(long l) const
        { return m_ll != l; }
    bool operator<(const wxLongLongNative& ll) const
        { return m_ll < ll.m_ll; }
    bool operator<(long l) const
        { return m_ll < l; }
    bool operator>(const wxLongLongNative& ll) const
        { return m_ll > ll.m_ll; }
    bool operator>(long l) const
        { return m_ll > l; }
    bool operator<=(const wxLongLongNative& ll) const
        { return m_ll <= ll.m_ll; }
    bool operator<=(long l) const
        { return m_ll <= l; }
    bool operator>=(const wxLongLongNative& ll) const
        { return m_ll >= ll.m_ll; }
    bool operator>=(long l) const
        { return m_ll >= l; }




    wxString ToString() const;


    void *asArray() const;



    friend
    std:: ostream& operator<<(std:: ostream&, const wxLongLongNative&);


    friend
    wxString& operator<<(wxString&, const wxLongLongNative&);


    friend
    class wxTextOutputStream& operator<<(class wxTextOutputStream&, const wxLongLongNative&);
    friend
    class wxTextInputStream& operator>>(class wxTextInputStream&, wxLongLongNative&);


private:
    long long m_ll;
};


class wxULongLongNative
{
public:


    wxULongLongNative() : m_ll(0) { }

    wxULongLongNative(unsigned long long ll) : m_ll(ll) { }

    wxULongLongNative(wxUint32 hi, wxUint32 lo) : m_ll(0)
    {

        m_ll = ((unsigned long long) hi) << 32;
        m_ll |= (unsigned long long) lo;
    }
# 370 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    wxULongLongNative& operator=(unsigned long long ll)
        { m_ll = ll; return *this; }
    wxULongLongNative& operator=(long long ll)
        { m_ll = ll; return *this; }

    wxULongLongNative& operator=(int l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(long l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(unsigned int l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(unsigned long l)
        { m_ll = l; return *this; }
    wxULongLongNative& operator=(const wxLongLongNative &ll)
        { m_ll = ll.GetValue(); return *this; }
# 394 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    wxUint32 GetHi() const
        { return ((wxUint32)(m_ll >> 32)); }

    wxUint32 GetLo() const
        { return ((wxUint32)(m_ll)); }


    unsigned long long GetValue() const { return m_ll; }


    unsigned long ToULong() const
    {
        do { if ( wxTheAssertHandler && !(m_ll <= 
# 406 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 3 4
       (0x7fffffffL * 2UL + 1UL)
# 406 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
       ) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
# 406 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
        ,
 407
# 406 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
        , __FUNCTION__, "m_ll <= ULONG_MAX", L"wxULongLong to long conversion loss of precision"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                               ;

        return ((unsigned long)(m_ll));
    }
# 421 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
    double ToDouble() const { return ((double)(m_ll)); }




    wxULongLongNative operator+(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll + ll.m_ll); }
    wxULongLongNative& operator+=(const wxULongLongNative& ll)
        { m_ll += ll.m_ll; return *this; }

    wxULongLongNative operator+(const unsigned long long ll) const
        { return wxULongLongNative(m_ll + ll); }
    wxULongLongNative& operator+=(const unsigned long long ll)
        { m_ll += ll; return *this; }


    wxULongLongNative& operator++()
        { m_ll++; return *this; }


    wxULongLongNative operator++(int)
        { wxULongLongNative value(*this); m_ll++; return value; }


    wxULongLongNative operator-(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll - ll.m_ll); }
    wxULongLongNative& operator-=(const wxULongLongNative& ll)
        { m_ll -= ll.m_ll; return *this; }

    wxULongLongNative operator-(const unsigned long long ll) const
        { return wxULongLongNative(m_ll - ll); }
    wxULongLongNative& operator-=(const unsigned long long ll)
        { m_ll -= ll; return *this; }


    wxULongLongNative& operator--()
        { m_ll--; return *this; }


    wxULongLongNative operator--(int)
        { wxULongLongNative value(*this); m_ll--; return value; }



    wxULongLongNative operator<<(int shift) const
        { return wxULongLongNative(m_ll << shift); }
    wxULongLongNative& operator<<=(int shift)
        { m_ll <<= shift; return *this; }


    wxULongLongNative operator>>(int shift) const
        { return wxULongLongNative(m_ll >> shift); }
    wxULongLongNative& operator>>=(int shift)
        { m_ll >>= shift; return *this; }


    wxULongLongNative operator&(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll & ll.m_ll); }
    wxULongLongNative& operator&=(const wxULongLongNative& ll)
        { m_ll &= ll.m_ll; return *this; }

    wxULongLongNative operator|(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll | ll.m_ll); }
    wxULongLongNative& operator|=(const wxULongLongNative& ll)
        { m_ll |= ll.m_ll; return *this; }

    wxULongLongNative operator^(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll ^ ll.m_ll); }
    wxULongLongNative& operator^=(const wxULongLongNative& ll)
        { m_ll ^= ll.m_ll; return *this; }


    wxULongLongNative operator*(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll * ll.m_ll); }
    wxULongLongNative operator*(unsigned long l) const
        { return wxULongLongNative(m_ll * l); }
    wxULongLongNative& operator*=(const wxULongLongNative& ll)
        { m_ll *= ll.m_ll; return *this; }
    wxULongLongNative& operator*=(unsigned long l)
        { m_ll *= l; return *this; }

    wxULongLongNative operator/(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll / ll.m_ll); }
    wxULongLongNative operator/(unsigned long l) const
        { return wxULongLongNative(m_ll / l); }
    wxULongLongNative& operator/=(const wxULongLongNative& ll)
        { m_ll /= ll.m_ll; return *this; }
    wxULongLongNative& operator/=(unsigned long l)
        { m_ll /= l; return *this; }

    wxULongLongNative operator%(const wxULongLongNative& ll) const
        { return wxULongLongNative(m_ll % ll.m_ll); }
    wxULongLongNative operator%(unsigned long l) const
        { return wxULongLongNative(m_ll % l); }


    bool operator==(const wxULongLongNative& ll) const
        { return m_ll == ll.m_ll; }
    bool operator==(unsigned long l) const
        { return m_ll == l; }
    bool operator!=(const wxULongLongNative& ll) const
        { return m_ll != ll.m_ll; }
    bool operator!=(unsigned long l) const
        { return m_ll != l; }
    bool operator<(const wxULongLongNative& ll) const
        { return m_ll < ll.m_ll; }
    bool operator<(unsigned long l) const
        { return m_ll < l; }
    bool operator>(const wxULongLongNative& ll) const
        { return m_ll > ll.m_ll; }
    bool operator>(unsigned long l) const
        { return m_ll > l; }
    bool operator<=(const wxULongLongNative& ll) const
        { return m_ll <= ll.m_ll; }
    bool operator<=(unsigned long l) const
        { return m_ll <= l; }
    bool operator>=(const wxULongLongNative& ll) const
        { return m_ll >= ll.m_ll; }
    bool operator>=(unsigned long l) const
        { return m_ll >= l; }




    wxString ToString() const;


    void *asArray() const;



    friend
    std:: ostream& operator<<(std:: ostream&, const wxULongLongNative&);


    friend
    wxString& operator<<(wxString&, const wxULongLongNative&);


    friend
    class wxTextOutputStream& operator<<(class wxTextOutputStream&, const wxULongLongNative&);
    friend
    class wxTextInputStream& operator>>(class wxTextInputStream&, wxULongLongNative&);


private:
    unsigned long long m_ll;
};

inline
wxLongLongNative& wxLongLongNative::operator=(const wxULongLongNative &ll)
{
    m_ll = ll.GetValue();
    return *this;
}
# 1044 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
inline bool operator<(long l, const wxLongLong& ll) { return ll > l; }
inline bool operator>(long l, const wxLongLong& ll) { return ll < l; }
inline bool operator<=(long l, const wxLongLong& ll) { return ll >= l; }
inline bool operator>=(long l, const wxLongLong& ll) { return ll <= l; }
inline bool operator==(long l, const wxLongLong& ll) { return ll == l; }
inline bool operator!=(long l, const wxLongLong& ll) { return ll != l; }

inline wxLongLong operator+(long l, const wxLongLong& ll) { return ll + l; }
inline wxLongLong operator-(long l, const wxLongLong& ll)
{
    return wxLongLong(l) - ll;
}

inline bool operator<(unsigned long l, const wxULongLong& ull) { return ull > l; }
inline bool operator>(unsigned long l, const wxULongLong& ull) { return ull < l; }
inline bool operator<=(unsigned long l, const wxULongLong& ull) { return ull >= l; }
inline bool operator>=(unsigned long l, const wxULongLong& ull) { return ull <= l; }
inline bool operator==(unsigned long l, const wxULongLong& ull) { return ull == l; }
inline bool operator!=(unsigned long l, const wxULongLong& ull) { return ull != l; }

inline wxULongLong operator+(unsigned long l, const wxULongLong& ull) { return ull + l; }

inline wxLongLong operator-(unsigned long l, const wxULongLong& ull)
{
    wxULongLong ret = wxULongLong(l) - ull;
    return wxLongLong((wxInt32)ret.GetHi(),ret.GetLo());
}



 class wxTextOutputStream &operator<<(class wxTextOutputStream &stream, unsigned long long value);
 class wxTextOutputStream &operator<<(class wxTextOutputStream &stream, long long value);

 class wxTextInputStream &operator>>(class wxTextInputStream &stream, unsigned long long &value);
 class wxTextInputStream &operator>>(class wxTextInputStream &stream, long long &value);
# 1094 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 1 3
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
       
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
# 158 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3

# 158 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1593 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 1095 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h" 2


# 1096 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
namespace std
{







  template<> class numeric_limits<wxLongLong> : public numeric_limits<long long> {};
  template<> class numeric_limits<wxULongLong> : public numeric_limits<unsigned long long> {};


}
# 1127 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h"
template<>
struct wxArgNormalizer<wxLongLong>
{
     wxArgNormalizer(wxLongLong value,
                     const wxFormatString *fmt, unsigned index)
         : m_value(value)
     {
         do { if ( !fmt ) break; const int argtype = fmt->GetArgumentType(index); do { if ( wxTheAssertHandler && !((argtype & (wxFormatString::Arg_LongLongInt)) == argtype) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/longlong.h", 1134, __FUNCTION__, "(argtype & (wxFormatString::Arg_LongLongInt)) == argtype", "format specifier doesn't match argument type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); } while ( (void)0, 0 );
     }

     long long get() const { return m_value.GetValue(); }

     wxLongLong m_value;
};
# 36 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platinfo.h" 1
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platinfo.h"
enum wxOperatingSystemId
{
    wxOS_UNKNOWN = 0,

    wxOS_MAC_OS = 1 << 0,
    wxOS_MAC_OSX_DARWIN = 1 << 1,
    wxOS_MAC = wxOS_MAC_OS|wxOS_MAC_OSX_DARWIN,

    wxOS_WINDOWS_9X = 1 << 2,
    wxOS_WINDOWS_NT = 1 << 3,
    wxOS_WINDOWS_MICRO = 1 << 4,
    wxOS_WINDOWS_CE = 1 << 5,
    wxOS_WINDOWS = wxOS_WINDOWS_9X |
                   wxOS_WINDOWS_NT |
                   wxOS_WINDOWS_MICRO |
                   wxOS_WINDOWS_CE,

    wxOS_UNIX_LINUX = 1 << 6,
    wxOS_UNIX_FREEBSD = 1 << 7,
    wxOS_UNIX_OPENBSD = 1 << 8,
    wxOS_UNIX_NETBSD = 1 << 9,
    wxOS_UNIX_SOLARIS = 1 << 10,
    wxOS_UNIX_AIX = 1 << 11,
    wxOS_UNIX_HPUX = 1 << 12,
    wxOS_UNIX = wxOS_UNIX_LINUX |
                wxOS_UNIX_FREEBSD |
                wxOS_UNIX_OPENBSD |
                wxOS_UNIX_NETBSD |
                wxOS_UNIX_SOLARIS |
                wxOS_UNIX_AIX |
                wxOS_UNIX_HPUX,



    wxOS_DOS = 1 << 15,
    wxOS_OS2 = 1 << 16
};



enum wxPortId
{
    wxPORT_UNKNOWN = 0,

    wxPORT_BASE = 1 << 0,

    wxPORT_MSW = 1 << 1,
    wxPORT_MOTIF = 1 << 2,
    wxPORT_GTK = 1 << 3,
    wxPORT_DFB = 1 << 4,
    wxPORT_X11 = 1 << 5,
    wxPORT_PM = 1 << 6,
    wxPORT_OS2 = wxPORT_PM,
    wxPORT_MAC = 1 << 7,
    wxPORT_OSX = wxPORT_MAC,
    wxPORT_COCOA = 1 << 8,
    wxPORT_WINCE = 1 << 9
};




enum wxArchitecture
{
    wxARCH_INVALID = -1,

    wxARCH_32,
    wxARCH_64,

    wxARCH_MAX
};



enum wxEndianness
{
    wxENDIAN_INVALID = -1,

    wxENDIAN_BIG,
    wxENDIAN_LITTLE,
    wxENDIAN_PDP,

    wxENDIAN_MAX
};


struct wxLinuxDistributionInfo
{
    wxString Id;
    wxString Release;
    wxString CodeName;
    wxString Description;

    bool operator==(const wxLinuxDistributionInfo& ldi) const
    {
        return Id == ldi.Id &&
               Release == ldi.Release &&
               CodeName == ldi.CodeName &&
               Description == ldi.Description;
    }

    bool operator!=(const wxLinuxDistributionInfo& ldi) const
    { return !(*this == ldi); }
};
# 137 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platinfo.h"
class wxPlatformInfo
{
public:
    wxPlatformInfo();
    wxPlatformInfo(wxPortId pid,
                   int tkMajor = -1, int tkMinor = -1,
                   wxOperatingSystemId id = wxOS_UNKNOWN,
                   int osMajor = -1, int osMinor = -1,
                   wxArchitecture arch = wxARCH_INVALID,
                   wxEndianness endian = wxENDIAN_INVALID,
                   bool usingUniversal = false);



    bool operator==(const wxPlatformInfo &t) const;

    bool operator!=(const wxPlatformInfo &t) const
        { return !(*this == t); }



    static const wxPlatformInfo& Get();






    static wxOperatingSystemId GetOperatingSystemId(const wxString &name);
    static wxPortId GetPortId(const wxString &portname);

    static wxArchitecture GetArch(const wxString &arch);
    static wxEndianness GetEndianness(const wxString &end);




    static wxString GetOperatingSystemFamilyName(wxOperatingSystemId os);
    static wxString GetOperatingSystemIdName(wxOperatingSystemId os);
    static wxString GetPortIdName(wxPortId port, bool usingUniversal);
    static wxString GetPortIdShortName(wxPortId port, bool usingUniversal);

    static wxString GetArchName(wxArchitecture arch);
    static wxString GetEndiannessName(wxEndianness end);





    int GetOSMajorVersion() const
        { return m_osVersionMajor; }
    int GetOSMinorVersion() const
        { return m_osVersionMinor; }


    bool CheckOSVersion(int major, int minor) const
    {
        return DoCheckVersion(GetOSMajorVersion(),
                              GetOSMinorVersion(),
                              major,
                              minor);
    }

    int GetToolkitMajorVersion() const
        { return m_tkVersionMajor; }
    int GetToolkitMinorVersion() const
        { return m_tkVersionMinor; }

    bool CheckToolkitVersion(int major, int minor) const
    {
        return DoCheckVersion(GetToolkitMajorVersion(),
                              GetToolkitMinorVersion(),
                              major,
                              minor);
    }

    bool IsUsingUniversalWidgets() const
        { return m_usingUniversal; }

    wxOperatingSystemId GetOperatingSystemId() const
        { return m_os; }
    wxLinuxDistributionInfo GetLinuxDistributionInfo() const
        { return m_ldi; }
    wxPortId GetPortId() const
        { return m_port; }
    wxArchitecture GetArchitecture() const
        { return m_arch; }
    wxEndianness GetEndianness() const
        { return m_endian; }





    wxString GetOperatingSystemFamilyName() const
        { return GetOperatingSystemFamilyName(m_os); }
    wxString GetOperatingSystemIdName() const
        { return GetOperatingSystemIdName(m_os); }
    wxString GetPortIdName() const
        { return GetPortIdName(m_port, m_usingUniversal); }
    wxString GetPortIdShortName() const
        { return GetPortIdShortName(m_port, m_usingUniversal); }
    wxString GetArchName() const
        { return GetArchName(m_arch); }
    wxString GetEndiannessName() const
        { return GetEndiannessName(m_endian); }
    wxString GetOperatingSystemDescription() const
        { return m_osDesc; }
    wxString GetDesktopEnvironment() const
        { return m_desktopEnv; }

    static wxString GetOperatingSystemDirectory();
# 257 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/platinfo.h"
    void SetOSVersion(int major, int minor)
        { m_osVersionMajor=major; m_osVersionMinor=minor; }
    void SetToolkitVersion(int major, int minor)
        { m_tkVersionMajor=major; m_tkVersionMinor=minor; }

    void SetOperatingSystemId(wxOperatingSystemId n)
        { m_os = n; }
    void SetOperatingSystemDescription(const wxString& desc)
        { m_osDesc = desc; }
    void SetPortId(wxPortId n)
        { m_port = n; }
    void SetArchitecture(wxArchitecture n)
        { m_arch = n; }
    void SetEndianness(wxEndianness n)
        { m_endian = n; }

    void SetDesktopEnvironment(const wxString& de)
        { m_desktopEnv = de; }
    void SetLinuxDistributionInfo(const wxLinuxDistributionInfo& di)
        { m_ldi = di; }





    bool IsOk() const
    {
        return m_osVersionMajor != -1 && m_osVersionMinor != -1 &&
               m_os != wxOS_UNKNOWN &&
               !m_osDesc.IsEmpty() &&
               m_tkVersionMajor != -1 && m_tkVersionMinor != -1 &&
               m_port != wxPORT_UNKNOWN &&
               m_arch != wxARCH_INVALID &&
               m_endian != wxENDIAN_INVALID;


    }


protected:
    static bool DoCheckVersion(int majorCur, int minorCur, int major, int minor)
    {
        return majorCur > major || (majorCur == major && minorCur >= minor);
    }

    void InitForCurrentPlatform();







    int m_osVersionMajor,
        m_osVersionMinor;


    wxOperatingSystemId m_os;


    wxString m_osDesc;





    wxString m_desktopEnv;
    wxLinuxDistributionInfo m_ldi;







    int m_tkVersionMajor, m_tkVersionMinor;


    wxPortId m_port;


    bool m_usingUniversal;






    wxArchitecture m_arch;


    wxEndianness m_endian;
};
# 39 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 2
# 53 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
class wxProcess;
class wxFrame;
class wxWindow;
class wxWindowList;
class wxEventLoop;





template<typename T1, typename T2>
inline typename wxImplicitConversionType<T1,T2>::value
wxMax(T1 a, T2 b)
{
    typedef typename wxImplicitConversionType<T1,T2>::value ResultType;



    return static_cast<ResultType>(a) > static_cast<ResultType>(b) ? a : b;
}

template<typename T1, typename T2>
inline typename wxImplicitConversionType<T1,T2>::value
wxMin(T1 a, T2 b)
{
    typedef typename wxImplicitConversionType<T1,T2>::value ResultType;

    return static_cast<ResultType>(a) < static_cast<ResultType>(b) ? a : b;
}

template<typename T1, typename T2, typename T3>
inline typename wxImplicitConversionType3<T1,T2,T3>::value
wxClip(T1 a, T2 b, T3 c)
{
    typedef typename wxImplicitConversionType3<T1,T2,T3>::value ResultType;

    if ( static_cast<ResultType>(a) < static_cast<ResultType>(b) )
        return b;

    if ( static_cast<ResultType>(a) > static_cast<ResultType>(c) )
        return c;

    return a;
}
# 106 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
    typedef wxLongLong wxMemorySize;
# 117 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
__attribute__((deprecated)) inline bool wxStringEq(const char *s1, const char *s2) { return strcmp(s1, s2) == 0; }



__attribute__((deprecated)) inline bool wxStringEq(const wchar_t *s1, const wchar_t *s2) { return wcscmp(s1, s2) == 0; }
# 132 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
 void wxBell();



 void wxInfoMessageBox(wxWindow* parent);


 wxVersionInfo wxGetLibraryVersionInfo();


 wxString wxGetOsDescription();


 wxOperatingSystemId wxGetOsVersion(int *majorVsn = 
# 145 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                                   __null
# 145 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                       ,
                                                    int *minorVsn = 
# 146 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                                   __null
# 146 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                       );


 bool wxIsPlatformLittleEndian();


 bool wxIsPlatform64Bit();







 wxString wxNow();


 const wxChar *wxGetInstallPrefix();

 wxString wxGetDataDir();






 bool wxGetKeyState(wxKeyCode key);




 bool wxSetDetectableAutoRepeat( bool flag );


 wxMouseState wxGetMouseState();
# 206 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
class wxPlatform
{
public:
    wxPlatform() { Init(); }
    wxPlatform(const wxPlatform& platform) { Copy(platform); }
    void operator = (const wxPlatform& platform) { if (&platform != this) Copy(platform); }
    void Copy(const wxPlatform& platform);


    wxPlatform(int defValue) { Init(); m_longValue = (long)defValue; }
    wxPlatform(long defValue) { Init(); m_longValue = defValue; }
    wxPlatform(const wxString& defValue) { Init(); m_stringValue = defValue; }
    wxPlatform(double defValue) { Init(); m_doubleValue = defValue; }

    static wxPlatform If(int platform, long value);
    static wxPlatform IfNot(int platform, long value);
    wxPlatform& ElseIf(int platform, long value);
    wxPlatform& ElseIfNot(int platform, long value);
    wxPlatform& Else(long value);

    static wxPlatform If(int platform, int value) { return If(platform, (long)value); }
    static wxPlatform IfNot(int platform, int value) { return IfNot(platform, (long)value); }
    wxPlatform& ElseIf(int platform, int value) { return ElseIf(platform, (long) value); }
    wxPlatform& ElseIfNot(int platform, int value) { return ElseIfNot(platform, (long) value); }
    wxPlatform& Else(int value) { return Else((long) value); }

    static wxPlatform If(int platform, double value);
    static wxPlatform IfNot(int platform, double value);
    wxPlatform& ElseIf(int platform, double value);
    wxPlatform& ElseIfNot(int platform, double value);
    wxPlatform& Else(double value);

    static wxPlatform If(int platform, const wxString& value);
    static wxPlatform IfNot(int platform, const wxString& value);
    wxPlatform& ElseIf(int platform, const wxString& value);
    wxPlatform& ElseIfNot(int platform, const wxString& value);
    wxPlatform& Else(const wxString& value);

    long GetInteger() const { return m_longValue; }
    const wxString& GetString() const { return m_stringValue; }
    double GetDouble() const { return m_doubleValue; }

    operator int() const { return (int) GetInteger(); }
    operator long() const { return GetInteger(); }
    operator double() const { return GetDouble(); }
    operator const wxString&() const { return GetString(); }

    static void AddPlatform(int platform);
    static bool Is(int platform);
    static void ClearPlatforms();

private:

    void Init() { m_longValue = 0; m_doubleValue = 0.0; }

    long m_longValue;
    double m_doubleValue;
    wxString m_stringValue;
    static wxArrayInt* sm_customPlatforms;
};


inline bool wxPlatformIs(int platform) { return wxPlatform::Is(platform); }






 void wxRegisterId(int id);


 int wxGetCurrentId();


 int wxNewId();






 int wxHexToDec(const wxString& buf);


inline int wxHexToDec(const char* buf)
{
    int firstDigit, secondDigit;

    if (buf[0] >= 'A')
        firstDigit = buf[0] - 'A' + 10;
    else
        firstDigit = buf[0] - '0';

    if (buf[1] >= 'A')
        secondDigit = buf[1] - 'A' + 10;
    else
        secondDigit = buf[1] - '0';

    return (firstDigit & 0xF) * 16 + (secondDigit & 0xF );
}



 void wxDecToHex(int dec, wxChar *buf);
 void wxDecToHex(int dec, char* ch1, char* ch2);
 wxString wxDecToHex(int dec);
# 321 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
enum
{

    wxEXEC_ASYNC = 0,


    wxEXEC_SYNC = 1,



    wxEXEC_SHOW_CONSOLE = 2,



    wxEXEC_NOHIDE = wxEXEC_SHOW_CONSOLE,






    wxEXEC_MAKE_GROUP_LEADER = 4,




    wxEXEC_NODISABLE = 8,




    wxEXEC_NOEVENTS = 16,



    wxEXEC_HIDE_CONSOLE = 32,


    wxEXEC_BLOCK = wxEXEC_SYNC | wxEXEC_NOEVENTS
};


typedef wxStringToStringHashMap wxEnvVariableHashMap;



struct wxExecuteEnv
{
    wxString cwd;
    wxEnvVariableHashMap env;
};






 long wxExecute(const wxString& command,
                                int flags = wxEXEC_ASYNC,
                                wxProcess *process = 
# 380 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                    __null
# 380 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                        ,
                                const wxExecuteEnv *env = 
# 381 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                         __null
# 381 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                             );
 long wxExecute(char **argv,
                                int flags = wxEXEC_ASYNC,
                                wxProcess *process = 
# 384 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                    __null
# 384 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                        ,
                                const wxExecuteEnv *env = 
# 385 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                         __null
# 385 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                             );

 long wxExecute(wchar_t **argv,
                                int flags = wxEXEC_ASYNC,
                                wxProcess *process = 
# 389 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                    __null
# 389 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                        ,
                                const wxExecuteEnv *env = 
# 390 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                         __null
# 390 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                             );




 long wxExecute(const wxString& command,
                                wxArrayString& output,
                                int flags = 0,
                                const wxExecuteEnv *env = 
# 398 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                         __null
# 398 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                             );


 long wxExecute(const wxString& command,
                                wxArrayString& output,
                                wxArrayString& error,
                                int flags = 0,
                                const wxExecuteEnv *env = 
# 405 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                         __null
# 405 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                             );



 bool wxExecuteDDE(const wxString& ddeServer,
                                   const wxString& ddeTopic,
                                   const wxString& ddeCommand);


enum wxSignal
{
    wxSIGNONE = 0,
    wxSIGHUP,
    wxSIGINT,
    wxSIGQUIT,
    wxSIGILL,
    wxSIGTRAP,
    wxSIGABRT,
    wxSIGIOT = wxSIGABRT,
    wxSIGEMT,
    wxSIGFPE,
    wxSIGKILL,
    wxSIGBUS,
    wxSIGSEGV,
    wxSIGSYS,
    wxSIGPIPE,
    wxSIGALRM,
    wxSIGTERM


};

enum wxKillError
{
    wxKILL_OK,
    wxKILL_BAD_SIGNAL,
    wxKILL_ACCESS_DENIED,
    wxKILL_NO_PROCESS,
    wxKILL_ERROR
};

enum wxKillFlags
{
    wxKILL_NOCHILDREN = 0,
    wxKILL_CHILDREN = 1
};

enum wxShutdownFlags
{
    wxSHUTDOWN_FORCE = 1,
    wxSHUTDOWN_POWEROFF = 2,
    wxSHUTDOWN_REBOOT = 4,
    wxSHUTDOWN_LOGOFF = 8
};


 bool wxShutdown(int flags = wxSHUTDOWN_POWEROFF);





 int wxKill(long pid,
                       wxSignal sig = wxSIGTERM,
                       wxKillError *rc = 
# 469 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                        __null
# 469 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                            ,
                       int flags = wxKILL_NOCHILDREN);



 bool wxShell(const wxString& command = wxEmptyString);



 bool wxShell(const wxString& command, wxArrayString& output);


 void wxSleep(int nSecs);


 void wxMilliSleep(unsigned long milliseconds);


 void wxMicroSleep(unsigned long microseconds);



__attribute__((deprecated)) void wxUsleep(unsigned long milliseconds);



 unsigned long wxGetProcessId();


 wxMemorySize wxGetFreeMemory();
# 513 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
 bool wxGetEnv(const wxString& var, wxString *value);


 bool wxSetEnv(const wxString& var, const wxString& value);


 bool wxUnsetEnv(const wxString& var);


inline bool wxSetEnv(const wxString& var, const char *value)
    { return wxSetEnv(var, wxString(value)); }
inline bool wxSetEnv(const wxString& var, const wchar_t *value)
    { return wxSetEnv(var, wxString(value)); }
template<typename T>
inline bool wxSetEnv(const wxString& var, const wxScopedCharTypeBuffer<T>& value)
    { return wxSetEnv(var, wxString(value)); }
inline bool wxSetEnv(const wxString& var, const wxCStrData& value)
    { return wxSetEnv(var, wxString(value)); }


__attribute__((deprecated)) inline bool wxSetEnv(const wxString& var, int value);
inline bool wxSetEnv(const wxString& var, int value)
{
    do { if ( wxTheAssertHandler && !(value == 0) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h", 536, __FUNCTION__, "value == 0", "using non-NULL integer as string?"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    wxUnusedVar(value);

    return wxUnsetEnv(var);
}




 bool wxGetEnvMap(wxEnvVariableHashMap *map);
# 555 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
 bool wxGetEmailAddress(wxChar *buf, int maxSize);
 wxString wxGetEmailAddress();


 bool wxGetHostName(wxChar *buf, int maxSize);
 wxString wxGetHostName();


 wxString wxGetFullHostName();
 bool wxGetFullHostName(wxChar *buf, int maxSize);


 bool wxGetUserId(wxChar *buf, int maxSize);
 wxString wxGetUserId();


 bool wxGetUserName(wxChar *buf, int maxSize);
 wxString wxGetUserName();


 wxString wxGetHomeDir();
 const wxChar* wxGetHomeDir(wxString *pstr);



 wxString wxGetUserHome(const wxString& user = wxEmptyString);



    typedef wxLongLong wxDiskspaceSize_t;





 bool wxGetDiskSpace(const wxString& path,
                                     wxDiskspaceSize_t *pTotal = 
# 591 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                                __null
# 591 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                    ,
                                     wxDiskspaceSize_t *pFree = 
# 592 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                               __null
# 592 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                   );



typedef int (*wxSortCallback)(const void* pItem1,
                              const void* pItem2,
                              const void* user_data);


 void wxQsort(void* pbase, size_t total_elems,
                              size_t size, wxSortCallback cmp,
                              const void* user_data);
# 613 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
enum
{
    wxBROWSER_NEW_WINDOW = 0x01,
    wxBROWSER_NOBUSYCURSOR = 0x02
};


 bool wxLaunchDefaultBrowser(const wxString& url, int flags = 0);


 bool wxLaunchDefaultApplication(const wxString& path, int flags = 0);






enum
{

    wxStrip_Mnemonics = 1,


    wxStrip_Accel = 2,


    wxStrip_All = wxStrip_Mnemonics | wxStrip_Accel
};


 wxString
wxStripMenuCodes(const wxString& str, int flags = wxStrip_All);
# 668 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
 int wxFindMenuItemId(wxFrame *frame, const wxString& menuString, const wxString& itemString);



 wxWindow* wxGenericFindWindowAtPoint(const wxPoint& pt);
 wxWindow* wxFindWindowAtPoint(const wxPoint& pt);






 wxWindow* wxFindWindowByLabel(const wxString& title, wxWindow *parent = 
# 680 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                                                        __null
# 680 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                                            );




 wxWindow* wxFindWindowByName(const wxString& name, wxWindow *parent = 
# 685 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                                                      __null
# 685 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                                                          );






 bool wxSafeYield(wxWindow *win = 
# 692 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                                 __null
# 692 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                                     , bool onlyIfNeeded = false);


 void wxEnableTopLevelWindows(bool enable = true);



 bool wxCheckForInterrupt(wxWindow *wnd);


 void wxFlushEvents();



class wxWindowDisabler
{
public:


    wxWindowDisabler(bool disable = true);


    wxWindowDisabler(wxWindow *winToSkip);


    ~wxWindowDisabler();

private:

    void DoDisable(wxWindow *winToSkip = 
# 721 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                        __null
# 721 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                            );




    wxWindowList *m_winDisabled;
    bool m_disabled;

    private: wxWindowDisabler(const wxWindowDisabler&); wxWindowDisabler& operator=(const wxWindowDisabler&);
};






 void wxBeginBusyCursor(const wxCursor *cursor = wxStockGDI::GetCursor(wxStockGDI::CURSOR_HOURGLASS));


 void wxEndBusyCursor();


 bool wxIsBusy();


class wxBusyCursor
{
public:
    wxBusyCursor(const wxCursor* cursor = wxStockGDI::GetCursor(wxStockGDI::CURSOR_HOURGLASS))
        { wxBeginBusyCursor(cursor); }
    ~wxBusyCursor()
        { wxEndBusyCursor(); }


    static const wxCursor &GetStoredCursor();
    static const wxCursor GetBusyCursor();
};

void wxGetMousePosition( int* x, int* y );
# 797 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
 bool wxYield();




 bool wxYieldIfNeeded();
# 811 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
    extern const wxChar* wxUserResourceStr;
# 823 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
    bool
    wxLoadUserResource(const void **outData,
                       size_t *outLen,
                       const wxString& resourceName,
                       const wxChar* resourceType = wxUserResourceStr,
                       WXHINSTANCE module = 0);






    char*
    wxLoadUserResource(const wxString& resourceName,
                       const wxChar* resourceType = wxUserResourceStr,
                       int* pLen = 
# 838 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h" 3 4
                                  __null
# 838 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/utils.h"
                                      ,
                       WXHINSTANCE module = 0);
# 70 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h" 2
# 88 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/cursor.h"
class wxBusyCursorSuspender
{
public:
    wxBusyCursorSuspender()
    {
        if( wxIsBusy() )
        {
            wxSetCursor( wxBusyCursor::GetStoredCursor() );
        }
    }
    ~wxBusyCursorSuspender()
    {
        if( wxIsBusy() )
        {
            wxSetCursor( wxBusyCursor::GetBusyCursor() );
        }
    }
};
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 1
# 68 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
extern "C"
{
typedef int ( *CMPFUNC)(const void* pItem1, const void* pItem2);
}
# 837 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
typedef const void * _wxArraywxBaseArrayPtrVoid; class wxBaseArrayPtrVoid { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayPtrVoid(); wxBaseArrayPtrVoid(const wxBaseArrayPtrVoid& array); wxBaseArrayPtrVoid& operator=(const wxBaseArrayPtrVoid& src); ~wxBaseArrayPtrVoid(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayPtrVoid defval = _wxArraywxBaseArrayPtrVoid()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayPtrVoid base_type; protected: _wxArraywxBaseArrayPtrVoid& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
# 837 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
 ,
 838
# 837 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
 , __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 837 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 837 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayPtrVoid& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayPtrVoid lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayPtrVoid lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayPtrVoid lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayPtrVoid lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayPtrVoid value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayPtrVoid& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayPtrVoid *m_pItems; }
                                                    ;
typedef char _wxArraywxBaseArrayChar; class wxBaseArrayChar { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayChar(); wxBaseArrayChar(const wxBaseArrayChar& array); wxBaseArrayChar& operator=(const wxBaseArrayChar& src); ~wxBaseArrayChar(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayChar defval = _wxArraywxBaseArrayChar()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayChar base_type; protected: _wxArraywxBaseArrayChar& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 839, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 839 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 839 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayChar& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayChar lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayChar lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayChar lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayChar lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayChar lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayChar value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayChar& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayChar *m_pItems; };
typedef short _wxArraywxBaseArrayShort; class wxBaseArrayShort { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayShort(); wxBaseArrayShort(const wxBaseArrayShort& array); wxBaseArrayShort& operator=(const wxBaseArrayShort& src); ~wxBaseArrayShort(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayShort defval = _wxArraywxBaseArrayShort()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayShort base_type; protected: _wxArraywxBaseArrayShort& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 840, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 840 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 840 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayShort& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayShort lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayShort lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayShort lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayShort lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayShort lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayShort value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayShort& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayShort *m_pItems; };
typedef int _wxArraywxBaseArrayInt; class wxBaseArrayInt { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayInt(); wxBaseArrayInt(const wxBaseArrayInt& array); wxBaseArrayInt& operator=(const wxBaseArrayInt& src); ~wxBaseArrayInt(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayInt defval = _wxArraywxBaseArrayInt()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayInt base_type; protected: _wxArraywxBaseArrayInt& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 841, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 841 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 841 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayInt& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayInt lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayInt lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayInt lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayInt lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayInt lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayInt value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayInt& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayInt *m_pItems; };
typedef long _wxArraywxBaseArrayLong; class wxBaseArrayLong { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayLong(); wxBaseArrayLong(const wxBaseArrayLong& array); wxBaseArrayLong& operator=(const wxBaseArrayLong& src); ~wxBaseArrayLong(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayLong defval = _wxArraywxBaseArrayLong()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayLong base_type; protected: _wxArraywxBaseArrayLong& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 842, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 842 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 842 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayLong& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayLong lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayLong lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayLong lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayLong lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayLong lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayLong value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayLong& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayLong *m_pItems; };
typedef size_t _wxArraywxBaseArraySizeT; class wxBaseArraySizeT { typedef CMPFUNC SCMPFUNC; public: wxBaseArraySizeT(); wxBaseArraySizeT(const wxBaseArraySizeT& array); wxBaseArraySizeT& operator=(const wxBaseArraySizeT& src); ~wxBaseArraySizeT(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArraySizeT defval = _wxArraywxBaseArraySizeT()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArraySizeT base_type; protected: _wxArraywxBaseArraySizeT& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 843, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 843 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 843 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArraySizeT& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArraySizeT lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArraySizeT lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArraySizeT lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArraySizeT lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArraySizeT lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArraySizeT value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArraySizeT& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArraySizeT *m_pItems; };
typedef double _wxArraywxBaseArrayDouble; class wxBaseArrayDouble { typedef CMPFUNC SCMPFUNC; public: wxBaseArrayDouble(); wxBaseArrayDouble(const wxBaseArrayDouble& array); wxBaseArrayDouble& operator=(const wxBaseArrayDouble& src); ~wxBaseArrayDouble(); void Empty() { m_nCount = 0; } void Clear(); void Alloc(size_t n) { if ( n > m_nSize ) Realloc(n); } void Shrink(); size_t GetCount() const { return m_nCount; } void SetCount(size_t n, _wxArraywxBaseArrayDouble defval = _wxArraywxBaseArrayDouble()); bool IsEmpty() const { return m_nCount == 0; } size_t Count() const { return m_nCount; } typedef _wxArraywxBaseArrayDouble base_type; protected: _wxArraywxBaseArrayDouble& Item(size_t uiIndex) const { do { if ( wxTheAssertHandler && !(uiIndex < m_nCount) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 844, __FUNCTION__, "uiIndex < m_nCount", (const char*)
# 844 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 844 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_pItems[uiIndex]; } _wxArraywxBaseArrayDouble& operator[](size_t uiIndex) const { return Item(uiIndex); } int Index(_wxArraywxBaseArrayDouble lItem, bool bFromEnd = false) const; int Index(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; size_t IndexForInsert(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare) const; void Add(_wxArraywxBaseArrayDouble lItem, size_t nInsert = 1); size_t Add(_wxArraywxBaseArrayDouble lItem, CMPFUNC fnCompare); void Insert(_wxArraywxBaseArrayDouble lItem, size_t uiIndex, size_t nInsert = 1); void Remove(_wxArraywxBaseArrayDouble lItem); void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC fnCompare); typedef _wxArraywxBaseArrayDouble value_type; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef ptrdiff_t difference_type; typedef size_t size_type; void assign(const_iterator first, const_iterator last); void assign(size_type n, const_reference v); size_type capacity() const { return m_nSize; } iterator erase(iterator first, iterator last) { size_type idx = first - begin(); RemoveAt(idx, last - first); return begin() + idx; } iterator erase(iterator it) { return erase(it, it + 1); } void insert(iterator it, size_type n, const value_type& v) { Insert(v, it - begin(), n); } iterator insert(iterator it, const value_type& v = value_type()) { size_type idx = it - begin(); Insert(v, idx); return begin() + idx; } void insert(iterator it, const_iterator first, const_iterator last); void pop_back() { RemoveAt(size() - 1); } void push_back(const value_type& v) { Add(v); } void reserve(size_type n) { Alloc(n); } void resize(size_type count, value_type defval = value_type()) { if ( count < m_nCount ) m_nCount = count; else SetCount(count, defval); } iterator begin() { return m_pItems; } iterator end() { return m_pItems + m_nCount; } const_iterator begin() const { return m_pItems; } const_iterator end() const { return m_pItems + m_nCount; } void swap(wxBaseArrayDouble& other) { wxSwap(m_nSize, other.m_nSize); wxSwap(m_nCount, other.m_nCount); wxSwap(m_pItems, other.m_pItems); } public: void clear() { Clear(); } bool empty() const { return IsEmpty(); } size_type max_size() const { return 0x7fffffff; } size_type size() const { return GetCount(); } private: void Grow(size_t nIncrement = 0); bool Realloc(size_t nSize); size_t m_nSize, m_nCount; _wxArraywxBaseArrayDouble *m_pItems; };
# 1021 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
typedef short _wxArraywxArrayShort; struct wxAssert_wxArrayShort { unsigned int TypeTooBigToBeStoredInwxBaseArrayShort: sizeof(_wxArraywxArrayShort) <= sizeof(wxBaseArrayShort::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayShort)(_wxArraywxArrayShort *pItem1, _wxArraywxArrayShort *pItem2); class wxArrayShort : public wxBaseArrayShort { public: wxArrayShort() { } ~wxArrayShort() { } _wxArraywxArrayShort& operator[](size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Item(size_t uiIndex) const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](uiIndex)); } _wxArraywxArrayShort& Last() const { return (_wxArraywxArrayShort&)(wxBaseArrayShort::operator[](GetCount() - 1)); } int Index(_wxArraywxArrayShort lItem, bool bFromEnd = false) const { return wxBaseArrayShort::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayShort lItem, size_t nInsert = 1) { wxBaseArrayShort::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayShort lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayShort::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayShort::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayShort lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 1021, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayShort::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayShort fCmp) { wxBaseArrayShort::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayShort::iterator biterator; typedef wxBaseArrayShort::const_iterator bconst_iterator; typedef wxBaseArrayShort::value_type bvalue_type; typedef wxBaseArrayShort::const_reference bconst_reference; public: typedef _wxArraywxArrayShort value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayShort::difference_type difference_type; typedef wxBaseArrayShort::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1021 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1021 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayShort value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1021 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1021 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayShort(size_type n) { assign(n, value_type()); } wxArrayShort(size_type n, const_reference v) { assign(n, v); } wxArrayShort(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayShort::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayShort::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayShort::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayShort::begin(); } size_type capacity() const { return wxBaseArrayShort::capacity(); } iterator end() { return (iterator)wxBaseArrayShort::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayShort::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayShort::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayShort::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayShort::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayShort::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayShort::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayShort::pop_back(); } void push_back(const_reference v) { wxBaseArrayShort::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayShort::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayShort::resize(n, v); } void swap(wxArrayShort& other) { wxBaseArrayShort::swap(other); } };
typedef int _wxArraywxArrayInt; struct wxAssert_wxArrayInt { unsigned int TypeTooBigToBeStoredInwxBaseArrayInt: sizeof(_wxArraywxArrayInt) <= sizeof(wxBaseArrayInt::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayInt)(_wxArraywxArrayInt *pItem1, _wxArraywxArrayInt *pItem2); class wxArrayInt : public wxBaseArrayInt { public: wxArrayInt() { } ~wxArrayInt() { } _wxArraywxArrayInt& operator[](size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Item(size_t uiIndex) const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](uiIndex)); } _wxArraywxArrayInt& Last() const { return (_wxArraywxArrayInt&)(wxBaseArrayInt::operator[](GetCount() - 1)); } int Index(_wxArraywxArrayInt lItem, bool bFromEnd = false) const { return wxBaseArrayInt::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayInt lItem, size_t nInsert = 1) { wxBaseArrayInt::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayInt lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayInt::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayInt::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayInt lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 1022, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayInt::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayInt fCmp) { wxBaseArrayInt::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayInt::iterator biterator; typedef wxBaseArrayInt::const_iterator bconst_iterator; typedef wxBaseArrayInt::value_type bvalue_type; typedef wxBaseArrayInt::const_reference bconst_reference; public: typedef _wxArraywxArrayInt value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayInt::difference_type difference_type; typedef wxBaseArrayInt::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1022 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1022 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayInt value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1022 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1022 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayInt(size_type n) { assign(n, value_type()); } wxArrayInt(size_type n, const_reference v) { assign(n, v); } wxArrayInt(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayInt::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayInt::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayInt::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayInt::begin(); } size_type capacity() const { return wxBaseArrayInt::capacity(); } iterator end() { return (iterator)wxBaseArrayInt::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayInt::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayInt::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayInt::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayInt::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayInt::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayInt::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayInt::pop_back(); } void push_back(const_reference v) { wxBaseArrayInt::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayInt::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayInt::resize(n, v); } void swap(wxArrayInt& other) { wxBaseArrayInt::swap(other); } };
typedef double _wxArraywxArrayDouble; struct wxAssert_wxArrayDouble { unsigned int TypeTooBigToBeStoredInwxBaseArrayDouble: sizeof(_wxArraywxArrayDouble) <= sizeof(wxBaseArrayDouble::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayDouble)(_wxArraywxArrayDouble *pItem1, _wxArraywxArrayDouble *pItem2); class wxArrayDouble : public wxBaseArrayDouble { public: wxArrayDouble() { } ~wxArrayDouble() { } _wxArraywxArrayDouble& operator[](size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Item(size_t uiIndex) const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](uiIndex)); } _wxArraywxArrayDouble& Last() const { return (_wxArraywxArrayDouble&)(wxBaseArrayDouble::operator[](GetCount() - 1)); } int Index(_wxArraywxArrayDouble lItem, bool bFromEnd = false) const { return wxBaseArrayDouble::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayDouble lItem, size_t nInsert = 1) { wxBaseArrayDouble::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayDouble lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayDouble::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayDouble::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayDouble lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 1023, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayDouble::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayDouble fCmp) { wxBaseArrayDouble::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayDouble::iterator biterator; typedef wxBaseArrayDouble::const_iterator bconst_iterator; typedef wxBaseArrayDouble::value_type bvalue_type; typedef wxBaseArrayDouble::const_reference bconst_reference; public: typedef _wxArraywxArrayDouble value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayDouble::difference_type difference_type; typedef wxBaseArrayDouble::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1023 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1023 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayDouble value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1023 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1023 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayDouble(size_type n) { assign(n, value_type()); } wxArrayDouble(size_type n, const_reference v) { assign(n, v); } wxArrayDouble(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayDouble::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayDouble::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayDouble::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayDouble::begin(); } size_type capacity() const { return wxBaseArrayDouble::capacity(); } iterator end() { return (iterator)wxBaseArrayDouble::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayDouble::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayDouble::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayDouble::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayDouble::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayDouble::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayDouble::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayDouble::pop_back(); } void push_back(const_reference v) { wxBaseArrayDouble::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayDouble::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayDouble::resize(n, v); } void swap(wxArrayDouble& other) { wxBaseArrayDouble::swap(other); } };
typedef long _wxArraywxArrayLong; struct wxAssert_wxArrayLong { unsigned int TypeTooBigToBeStoredInwxBaseArrayLong: sizeof(_wxArraywxArrayLong) <= sizeof(wxBaseArrayLong::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayLong)(_wxArraywxArrayLong *pItem1, _wxArraywxArrayLong *pItem2); class wxArrayLong : public wxBaseArrayLong { public: wxArrayLong() { } ~wxArrayLong() { } _wxArraywxArrayLong& operator[](size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Item(size_t uiIndex) const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](uiIndex)); } _wxArraywxArrayLong& Last() const { return (_wxArraywxArrayLong&)(wxBaseArrayLong::operator[](GetCount() - 1)); } int Index(_wxArraywxArrayLong lItem, bool bFromEnd = false) const { return wxBaseArrayLong::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayLong lItem, size_t nInsert = 1) { wxBaseArrayLong::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayLong lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayLong::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayLong::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayLong lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 1024, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayLong::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayLong fCmp) { wxBaseArrayLong::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayLong::iterator biterator; typedef wxBaseArrayLong::const_iterator bconst_iterator; typedef wxBaseArrayLong::value_type bvalue_type; typedef wxBaseArrayLong::const_reference bconst_reference; public: typedef _wxArraywxArrayLong value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayLong::difference_type difference_type; typedef wxBaseArrayLong::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1024 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1024 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayLong value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1024 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1024 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayLong(size_type n) { assign(n, value_type()); } wxArrayLong(size_type n, const_reference v) { assign(n, v); } wxArrayLong(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayLong::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayLong::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayLong::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayLong::begin(); } size_type capacity() const { return wxBaseArrayLong::capacity(); } iterator end() { return (iterator)wxBaseArrayLong::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayLong::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayLong::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayLong::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayLong::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayLong::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayLong::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayLong::pop_back(); } void push_back(const_reference v) { wxBaseArrayLong::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayLong::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayLong::resize(n, v); } void swap(wxArrayLong& other) { wxBaseArrayLong::swap(other); } };
typedef void * _wxArraywxArrayPtrVoid; struct wxAssert_wxArrayPtrVoid { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxArrayPtrVoid) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxArrayPtrVoid)(_wxArraywxArrayPtrVoid *pItem1, _wxArraywxArrayPtrVoid *pItem2); class wxArrayPtrVoid : public wxBaseArrayPtrVoid { public: wxArrayPtrVoid() { } ~wxArrayPtrVoid() { } _wxArraywxArrayPtrVoid& operator[](size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Item(size_t uiIndex) const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxArrayPtrVoid& Last() const { return (_wxArraywxArrayPtrVoid&)(wxBaseArrayPtrVoid::operator[](GetCount() - 1)); } int Index(_wxArraywxArrayPtrVoid lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxArrayPtrVoid lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxArrayPtrVoid lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxArrayPtrVoid lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h", 1025, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxArrayPtrVoid fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxArrayPtrVoid value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1025 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1025 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxArrayPtrVoid value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1025 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h" 3 4
__null
# 1025 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/dynarray.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxArrayPtrVoid(size_type n) { assign(n, value_type()); } wxArrayPtrVoid(size_type n, const_reference v) { assign(n, v); } wxArrayPtrVoid(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } void swap(wxArrayPtrVoid& other) { wxBaseArrayPtrVoid::swap(other); } };
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h" 1
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
enum wxMutexError
{
    wxMUTEX_NO_ERROR = 0,
    wxMUTEX_INVALID,
    wxMUTEX_DEAD_LOCK,
    wxMUTEX_BUSY,
    wxMUTEX_UNLOCKED,
    wxMUTEX_TIMEOUT,
    wxMUTEX_MISC_ERROR
};

enum wxCondError
{
    wxCOND_NO_ERROR = 0,
    wxCOND_INVALID,
    wxCOND_TIMEOUT,
    wxCOND_MISC_ERROR
};

enum wxSemaError
{
    wxSEMA_NO_ERROR = 0,
    wxSEMA_INVALID,
    wxSEMA_BUSY,
    wxSEMA_TIMEOUT,
    wxSEMA_OVERFLOW,
    wxSEMA_MISC_ERROR
};

enum wxThreadError
{
    wxTHREAD_NO_ERROR = 0,
    wxTHREAD_NO_RESOURCE,
    wxTHREAD_RUNNING,
    wxTHREAD_NOT_RUNNING,
    wxTHREAD_KILLED,
    wxTHREAD_MISC_ERROR
};

enum wxThreadKind
{
    wxTHREAD_DETACHED,
    wxTHREAD_JOINABLE
};

enum wxThreadWait
{
    wxTHREAD_WAIT_BLOCK,
    wxTHREAD_WAIT_YIELD,





    wxTHREAD_WAIT_DEFAULT = wxTHREAD_WAIT_YIELD



};


enum
{
    WXTHREAD_MIN_PRIORITY = wxPRIORITY_MIN,
    WXTHREAD_DEFAULT_PRIORITY = wxPRIORITY_DEFAULT,
    WXTHREAD_MAX_PRIORITY = wxPRIORITY_MAX
};
# 112 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
enum wxMutexType
{

    wxMUTEX_DEFAULT,


    wxMUTEX_RECURSIVE
};


class wxThreadHelper;
class wxConditionInternal;
class wxMutexInternal;
class wxSemaphoreInternal;
class wxThreadInternal;
# 137 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
class wxMutex
{
public:




    wxMutex(wxMutexType mutexType = wxMUTEX_DEFAULT);


    ~wxMutex();


    bool IsOk() const;
# 160 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    wxMutexError Lock();



    wxMutexError LockTimeout(unsigned long ms);



    wxMutexError TryLock();


    wxMutexError Unlock();

protected:
    wxMutexInternal *m_internal;

    friend class wxConditionInternal;

    private: wxMutex(const wxMutex&); wxMutex& operator=(const wxMutex&);
};




class wxMutexLocker
{
public:

    wxMutexLocker(wxMutex& mutex)
        : m_isOk(false), m_mutex(mutex)
        { m_isOk = ( m_mutex.Lock() == wxMUTEX_NO_ERROR ); }


    bool IsOk() const
        { return m_isOk; }


    ~wxMutexLocker()
        { if ( IsOk() ) m_mutex.Unlock(); }

private:

    wxMutexLocker(const wxMutexLocker&);
    wxMutexLocker& operator=(const wxMutexLocker&);

    bool m_isOk;
    wxMutex& m_mutex;
};
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
enum wxCriticalSectionType
{

    wxCRITSEC_DEFAULT,


    wxCRITSEC_NON_RECURSIVE
};



class wxCriticalSection
{
public:

    wxCriticalSection( wxCriticalSectionType critSecType = wxCRITSEC_DEFAULT );
    ~wxCriticalSection();

    void Enter();


    bool TryEnter();


    void Leave();

private:
# 269 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    typedef char wxCritSectBuffer[40];



    union
    {
        unsigned long m_dummy1;
        void *m_dummy2;

        wxCritSectBuffer m_buffer;
    };


    private: wxCriticalSection(const wxCriticalSection&); wxCriticalSection& operator=(const wxCriticalSection&);
};
# 301 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
class wxCriticalSectionLocker
{
public:
    wxCriticalSectionLocker(wxCriticalSection& cs)
        : m_critsect(cs)
    {
        m_critsect.Enter();
    }

    ~wxCriticalSectionLocker()
    {
        m_critsect.Leave();
    }

private:
    wxCriticalSection& m_critsect;

    private: wxCriticalSectionLocker(const wxCriticalSectionLocker&); wxCriticalSectionLocker& operator=(const wxCriticalSectionLocker&);
};






class wxCondition
{
public:


    wxCondition(wxMutex& mutex);


    ~wxCondition();


    bool IsOk() const;







    wxCondError Wait();


    template<typename Functor>
    wxCondError Wait(const Functor& predicate)
    {
        while ( !predicate() )
        {
            wxCondError e = Wait();
            if ( e != wxCOND_NO_ERROR )
                return e;
        }
        return wxCOND_NO_ERROR;
    }
# 367 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    wxCondError WaitTimeout(unsigned long milliseconds);







    wxCondError Signal();







    wxCondError Broadcast();







private:
    wxConditionInternal *m_internal;

    private: wxCondition(const wxCondition&); wxCondition& operator=(const wxCondition&);
};
# 407 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
class wxSemaphore
{
public:


    wxSemaphore( int initialcount = 0, int maxcount = 0 );


    ~wxSemaphore();


    bool IsOk() const;




    wxSemaError Wait();



    wxSemaError TryWait();



    wxSemaError WaitTimeout(unsigned long milliseconds);


    wxSemaError Post();

private:
    wxSemaphoreInternal *m_internal;

    private: wxSemaphore(const wxSemaphore&); wxSemaphore& operator=(const wxSemaphore&);
};
# 459 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
   typedef unsigned long wxThreadIdType;


class wxThread
{
public:

    typedef void *ExitCode;







    static wxThread *This();






    static bool IsMain()
    {
        return !ms_idMainThread || GetCurrentId() == ms_idMainThread;
    }


    static wxThreadIdType GetMainId() { return ms_idMainThread; }


    static void Yield();




    static void Sleep(unsigned long milliseconds);





    static int GetCPUCount();




    static wxThreadIdType GetCurrentId();
# 515 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    static bool SetConcurrency(size_t level);



    wxThread(wxThreadKind kind = wxTHREAD_DETACHED);
# 529 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    wxThreadError Create(unsigned int stackSize = 0);




    wxThreadError Run();
# 546 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    wxThreadError Delete(ExitCode *rc = 
# 546 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h" 3 4
                                       __null
# 546 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
                                           ,
                         wxThreadWait waitMode = wxTHREAD_WAIT_DEFAULT);





    ExitCode Wait(wxThreadWait waitMode = wxTHREAD_WAIT_DEFAULT);
# 563 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    wxThreadError Kill();



    wxThreadError Pause();


    wxThreadError Resume();







    void SetPriority(unsigned int prio);


    unsigned int GetPriority() const;



    bool IsAlive() const;

    bool IsRunning() const;

    bool IsPaused() const;


    bool IsDetached() const { return m_isDetached; }



    wxThreadIdType GetId() const;

    wxThreadKind GetKind() const
        { return m_isDetached ? wxTHREAD_DETACHED : wxTHREAD_JOINABLE; }




    virtual bool TestDestroy();



    virtual ~wxThread();

protected:

    void Exit(ExitCode exitcode = 0);



    virtual void *Entry() = 0;


    void *CallEntry();







    virtual void OnDelete() {}



    virtual void OnKill() {}

private:

    wxThread(const wxThread&);
    wxThread& operator=(const wxThread&);




    virtual void OnExit() { }

    friend class wxThreadInternal;
    friend class wxThreadModule;



    static wxThreadIdType ms_idMainThread;


    wxThreadInternal *m_internal;


    wxCriticalSection m_critsect;


    bool m_isDetached;
};




class wxThreadHelperThread : public wxThread
{
public:


    wxThreadHelperThread(wxThreadHelper& owner, wxThreadKind kind)
        : wxThread(kind), m_owner(owner)
        { }

protected:

    virtual void *Entry();

private:

    wxThreadHelper& m_owner;


    wxThreadHelperThread(const wxThreadHelperThread&);
    wxThreadHelperThread& operator=(const wxThreadHelperThread&);
};







class wxThreadHelper
{
private:
    void KillThread()
    {




        wxCriticalSectionLocker locker(m_critSection);

        if ( m_thread )
        {
            m_thread->Kill();

            if ( m_kind == wxTHREAD_JOINABLE )
              delete m_thread;

            m_thread = 
# 709 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h" 3 4
                      __null
# 709 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
                          ;
        }
    }

public:

    wxThreadHelper(wxThreadKind kind = wxTHREAD_JOINABLE)
        : m_thread(
# 716 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h" 3 4
                  __null
# 716 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
                      ), m_kind(kind) { }


    virtual ~wxThreadHelper() { KillThread(); }


    __attribute__((deprecated)) wxThreadError Create(unsigned int stackSize = 0);




    wxThreadError CreateThread(wxThreadKind kind = wxTHREAD_JOINABLE,
                               unsigned int stackSize = 0)
    {
        KillThread();

        m_kind = kind;
        m_thread = new wxThreadHelperThread(*this, m_kind);

        return m_thread->Create(stackSize);
    }



    virtual void *Entry() = 0;


    wxThread *GetThread() const
    {
        wxCriticalSectionLocker locker((wxCriticalSection&)m_critSection);

        wxThread* thread = m_thread;

        return thread;
    }

protected:
    wxThread *m_thread;
    wxThreadKind m_kind;
    wxCriticalSection m_critSection;

    friend class wxThreadHelperThread;
};


inline wxThreadError wxThreadHelper::Create(unsigned int stackSize)
{ return CreateThread(m_kind, stackSize); }



inline void *wxThreadHelperThread::Entry()
{
    void * const result = m_owner.Entry();

    wxCriticalSectionLocker locker(m_owner.m_critSection);





    if ( m_owner.m_kind == wxTHREAD_DETACHED )
        m_owner.m_thread = 
# 777 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h" 3 4
                          __null
# 777 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
                              ;

    return result;
}






void wxMutexGuiEnter();
void wxMutexGuiLeave();
# 800 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
inline bool wxIsMainThread() { return wxThread::IsMain(); }
# 846 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
class wxMutexGuiLocker
{
public:
    wxMutexGuiLocker() { wxMutexGuiEnter(); }
   ~wxMutexGuiLocker() { wxMutexGuiLeave(); }
};
# 863 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/thread.h"
    extern void wxMutexGuiLeaveOrEnter();


    extern bool wxGuiOwnedByMainThread();


    extern void wxWakeUpMainThread();




    extern bool wxIsWaitingForThread();
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h"
class wxEventConnectionRef;



class wxTrackerNode
{
public:
    wxTrackerNode() : m_nxt(
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h" 3 4
                           __null
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h"
                               ) { }
    virtual ~wxTrackerNode() { }

    virtual void OnObjectDestroy() = 0;

    virtual wxEventConnectionRef *ToEventConnection() { return 
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h" 3 4
                                                              __null
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h"
                                                                  ; }

private:
    wxTrackerNode *m_nxt;

    friend class wxTrackable;
    friend class wxEvtHandler;
};


class wxTrackable
{
public:
    void AddNode(wxTrackerNode *prn)
    {
        prn->m_nxt = m_first;
        m_first = prn;
    }

    void RemoveNode(wxTrackerNode *prn)
    {
        for ( wxTrackerNode **pprn = &m_first; *pprn; pprn = &(*pprn)->m_nxt )
        {
            if ( *pprn == prn )
            {
                *pprn = prn->m_nxt;
                return;
            }
        }

        do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h", 57, __FUNCTION__, "Assert failure", "removing invalid tracker node"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
    }

    wxTrackerNode *GetFirst() const { return m_first; }

protected:



    wxTrackable() : m_first(
# 66 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h" 3 4
                           __null
# 66 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h"
                               ) { }



    wxTrackable(const wxTrackable& ) : m_first(
# 70 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h" 3 4
                                                             __null
# 70 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/tracker.h"
                                                                 ) { }
    wxTrackable& operator=(const wxTrackable& ) { return *this; }




    ~wxTrackable()
    {

        while ( m_first )
        {
            wxTrackerNode * const first = m_first;
            m_first = first->m_nxt;
            first->OnObjectDestroy();
        }
    }

    wxTrackerNode *m_first;
};
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/typeinfo.h" 1
# 63 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/typeinfo.h"
class wxTypeIdentifier
{
public:
    wxTypeIdentifier(const char* className)
    {
        m_className = className;
    }

    bool operator==(const wxTypeIdentifier& other)
    {
        return strcmp(m_className, other.m_className) == 0;
    }

    bool operator!=(const wxTypeIdentifier& other)
    {
        return strcmp(m_className, other.m_className) != 0;
    }
private:
    const char* m_className;
};
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 1
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
enum
{
    WX_ANY_VALUE_BUFFER_SIZE = 16
};

union wxAnyValueBuffer
{
    union Alignment
    {

        wxInt64 m_int64;

        long double m_longDouble;
        void ( *m_funcPtr )(void);
        void ( wxAnyValueBuffer::*m_mFuncPtr )(void);
    } m_alignment;

    void* m_ptr;
    wxByte m_buffer[WX_ANY_VALUE_BUFFER_SIZE];
};






class wxAnyValueType
{
   
public:



    wxAnyValueType()
    {
    }




    virtual ~wxAnyValueType()
    {
    }




    virtual bool IsSameType(const wxAnyValueType* otherType) const = 0;





    virtual void DeleteValue(wxAnyValueBuffer& buf) const = 0;
# 90 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    virtual void CopyBuffer(const wxAnyValueBuffer& src,
                            wxAnyValueBuffer& dst) const = 0;





    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const = 0;
# 113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    template <typename T>
    bool CheckType(T* reserved = 
# 114 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
                                __null
# 114 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
                                    ) const;




private:
};
# 131 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
class wxAnyValueTypeScopedPtr
{
public:
    wxAnyValueTypeScopedPtr(wxAnyValueType* ptr) : m_ptr(ptr) { }
    ~wxAnyValueTypeScopedPtr() { delete m_ptr; }
    wxAnyValueType* get() const { return m_ptr; }
private:
    wxAnyValueType* m_ptr;
};
# 199 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
namespace wxPrivate
{

template<typename T>
class wxAnyValueTypeOpsInplace
{
public:
    static void DeleteValue(wxAnyValueBuffer& buf)
    {
        T* value = reinterpret_cast<T*>(&buf.m_buffer[0]);
        value->~T();


        wxUnusedVar(value);
    }

    static void SetValue(const T& value,
                         wxAnyValueBuffer& buf)
    {

        void* const place = buf.m_buffer;
        ::new(place) T(value);
    }

    static const T& GetValue(const wxAnyValueBuffer& buf)
    {



        const T* value = reinterpret_cast<const T*>(&buf.m_buffer[0]);
        return *value;
    }
};


template<typename T>
class wxAnyValueTypeOpsGeneric
{
public:
    template<typename T2>
    class DataHolder
    {
    public:
        DataHolder(const T2& value)
        {
            m_value = value;
        }
        virtual ~DataHolder() { }

        T2 m_value;
    private:
        private: DataHolder(const DataHolder&); DataHolder& operator=(const DataHolder&);
    };

    static void DeleteValue(wxAnyValueBuffer& buf)
    {
        DataHolder<T>* holder = static_cast<DataHolder<T>*>(buf.m_ptr);
        delete holder;
    }

    static void SetValue(const T& value,
                         wxAnyValueBuffer& buf)
    {
        DataHolder<T>* holder = new DataHolder<T>(value);
        buf.m_ptr = holder;
    }

    static const T& GetValue(const wxAnyValueBuffer& buf)
    {
        DataHolder<T>* holder = static_cast<DataHolder<T>*>(buf.m_ptr);
        return holder->m_value;
    }
};

}
# 283 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
template<typename T>
class wxAnyValueTypeImplBase : public wxAnyValueType
{
    typedef typename wxIf< sizeof(T) <= WX_ANY_VALUE_BUFFER_SIZE,
                           wxPrivate::wxAnyValueTypeOpsInplace<T>,
                           wxPrivate::wxAnyValueTypeOpsGeneric<T> >::value
            Ops;

public:
    wxAnyValueTypeImplBase() : wxAnyValueType() { }
    virtual ~wxAnyValueTypeImplBase() { }

    virtual void DeleteValue(wxAnyValueBuffer& buf) const
    {
        Ops::DeleteValue(buf);
    }

    virtual void CopyBuffer(const wxAnyValueBuffer& src,
                            wxAnyValueBuffer& dst) const
    {
        Ops::SetValue(Ops::GetValue(src), dst);
    }





    static void SetValue(const T& value,
                         wxAnyValueBuffer& buf)
    {
        Ops::SetValue(value, buf);
    }





    static const T& GetValue(const wxAnyValueBuffer& buf)
    {
        return Ops::GetValue(buf);
    }






};






template<typename T>
class wxAnyValueTypeImpl : public wxAnyValueTypeImplBase<T>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImpl() : wxAnyValueTypeImplBase<T>() { }
    virtual ~wxAnyValueTypeImpl() { }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const
    {
        wxUnusedVar(src);
        wxUnusedVar(dstType);
        wxUnusedVar(dst);
        return false;
    }
};

template<typename T>
wxAnyValueTypeScopedPtr wxAnyValueTypeImpl<T>::sm_instance = new wxAnyValueTypeImpl<T>();
# 406 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    typedef long long wxAnyBaseIntType;
    typedef unsigned long long wxAnyBaseUintType;






class wxAnyValueTypeImplInt :
    public wxAnyValueTypeImplBase<wxAnyBaseIntType>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImplInt() :
        wxAnyValueTypeImplBase<wxAnyBaseIntType>() { }
    virtual ~wxAnyValueTypeImplInt() { }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const;
};


class wxAnyValueTypeImplUint :
    public wxAnyValueTypeImplBase<wxAnyBaseUintType>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImplUint() :
        wxAnyValueTypeImplBase<wxAnyBaseUintType>() { }
    virtual ~wxAnyValueTypeImplUint() { }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const;
};


template<> class wxAnyValueTypeImpl<signed long> : public wxAnyValueTypeImplInt { typedef wxAnyBaseIntType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplInt() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const signed long& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static signed long GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<signed long>(*sptr); }};
template<> class wxAnyValueTypeImpl<signed int> : public wxAnyValueTypeImplInt { typedef wxAnyBaseIntType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplInt() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const signed int& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static signed int GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<signed int>(*sptr); }};
template<> class wxAnyValueTypeImpl<signed short> : public wxAnyValueTypeImplInt { typedef wxAnyBaseIntType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplInt() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const signed short& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static signed short GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<signed short>(*sptr); }};
template<> class wxAnyValueTypeImpl<signed char> : public wxAnyValueTypeImplInt { typedef wxAnyBaseIntType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplInt() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const signed char& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static signed char GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<signed char>(*sptr); }};

template<> class wxAnyValueTypeImpl<long long> : public wxAnyValueTypeImplInt { typedef wxAnyBaseIntType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplInt() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const long long& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static long long GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<long long>(*sptr); }};


template<> class wxAnyValueTypeImpl<unsigned long> : public wxAnyValueTypeImplUint { typedef wxAnyBaseUintType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplUint() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const unsigned long& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static unsigned long GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<unsigned long>(*sptr); }};
template<> class wxAnyValueTypeImpl<unsigned int> : public wxAnyValueTypeImplUint { typedef wxAnyBaseUintType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplUint() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const unsigned int& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static unsigned int GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<unsigned int>(*sptr); }};
template<> class wxAnyValueTypeImpl<unsigned short> : public wxAnyValueTypeImplUint { typedef wxAnyBaseUintType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplUint() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const unsigned short& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static unsigned short GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<unsigned short>(*sptr); }};
template<> class wxAnyValueTypeImpl<unsigned char> : public wxAnyValueTypeImplUint { typedef wxAnyBaseUintType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplUint() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const unsigned char& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static unsigned char GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<unsigned char>(*sptr); }};

template<> class wxAnyValueTypeImpl<unsigned long long> : public wxAnyValueTypeImplUint { typedef wxAnyBaseUintType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplUint() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const unsigned long long& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static unsigned long long GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<unsigned long long>(*sptr); }};
# 502 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
extern bool wxAnyConvertString(const wxString& value,
                                                wxAnyValueType* dstType,
                                                wxAnyValueBuffer& dst);

class wxAnyValueTypeImplwxString : public wxAnyValueTypeImplBase<wxString> { friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); } public: wxAnyValueTypeImplwxString() : wxAnyValueTypeImplBase<wxString>() { } virtual ~wxAnyValueTypeImplwxString() { } virtual bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const { const wxString& value = GetValue(src); return wxAnyConvertString(value, dstType, dst); } }; template<> class wxAnyValueTypeImpl<wxString> : public wxAnyValueTypeImplwxString { public: wxAnyValueTypeImpl() : wxAnyValueTypeImplwxString() { } virtual ~wxAnyValueTypeImpl() { } };
class wxAnyValueTypeImplConstCharPtr : public wxAnyValueTypeImplBase<const char*> { friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); } public: wxAnyValueTypeImplConstCharPtr() : wxAnyValueTypeImplBase<const char*>() { } virtual ~wxAnyValueTypeImplConstCharPtr() { } virtual bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const { wxString value = GetValue(src); return wxAnyConvertString(value, dstType, dst); } }; template<> class wxAnyValueTypeImpl<const char*> : public wxAnyValueTypeImplConstCharPtr { public: wxAnyValueTypeImpl() : wxAnyValueTypeImplConstCharPtr() { } virtual ~wxAnyValueTypeImpl() { } };

class wxAnyValueTypeImplConstWchar_tPtr : public wxAnyValueTypeImplBase<const wchar_t*> { friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); } public: wxAnyValueTypeImplConstWchar_tPtr() : wxAnyValueTypeImplBase<const wchar_t*>() { } virtual ~wxAnyValueTypeImplConstWchar_tPtr() { } virtual bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const { wxString value = GetValue(src); return wxAnyConvertString(value, dstType, dst); } }; template<> class wxAnyValueTypeImpl<const wchar_t*> : public wxAnyValueTypeImplConstWchar_tPtr { public: wxAnyValueTypeImpl() : wxAnyValueTypeImplConstWchar_tPtr() { } virtual ~wxAnyValueTypeImpl() { } };





template<>
class wxAnyValueTypeImpl<bool> :
    public wxAnyValueTypeImplBase<bool>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImpl() :
        wxAnyValueTypeImplBase<bool>() { }
    virtual ~wxAnyValueTypeImpl() { }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const;
};




class wxAnyValueTypeImplDouble :
    public wxAnyValueTypeImplBase<double>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImplDouble() :
        wxAnyValueTypeImplBase<double>() { }
    virtual ~wxAnyValueTypeImplDouble() { }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const;
};


typedef double wxAnyBaseDoubleType;

template<> class wxAnyValueTypeImpl<float> : public wxAnyValueTypeImplDouble { typedef wxAnyBaseDoubleType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplDouble() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const float& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static float GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<float>(*sptr); }};
template<> class wxAnyValueTypeImpl<double> : public wxAnyValueTypeImplDouble { typedef wxAnyBaseDoubleType UseDataType; public: wxAnyValueTypeImpl() : wxAnyValueTypeImplDouble() { } virtual ~wxAnyValueTypeImpl() { } static void SetValue(const double& value, wxAnyValueBuffer& buf) { void* voidPtr = reinterpret_cast<void*>(&buf.m_buffer[0]); UseDataType* dptr = reinterpret_cast<UseDataType*>(voidPtr); *dptr = static_cast<UseDataType>(value); } static double GetValue(const wxAnyValueBuffer& buf) { const void* voidPtr = reinterpret_cast<const void*>(&buf.m_buffer[0]); const UseDataType* sptr = reinterpret_cast<const UseDataType*>(voidPtr); return static_cast<double>(*sptr); }};
# 589 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 1
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed/limits.h" 1 3 4
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h" 1
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
class wxAnyStrPtr
{
public:





    wxAnyStrPtr()
        : m_str(
# 38 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h" 3 4
               __null
# 38 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
                   )
    {
    }



    wxAnyStrPtr(const wxString& str, const wxString::const_iterator& iter)
        : m_str(&str),
          m_iter(iter)
    {
    }
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
    operator bool() const { return m_str != 
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h" 3 4
                                           __null
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
                                               ; }



    bool operator!() const { return !((bool)*this); }




    operator const char *() const
    {
        if ( !m_str )
            return 
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h" 3 4
                  __null
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
                      ;







        const char *p = m_str->c_str().AsChar();
        if ( *p )
        {







            p += strlen(wxString(m_str->begin(), m_iter).mb_str());
        }


        return p;
    }

    operator const wchar_t *() const
    {
        if ( !m_str )
            return 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h" 3 4
                  __null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
                      ;







        return m_str->c_str().AsWChar() + (m_iter - m_str->begin());
    }
# 129 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/anystr.h"
private:


    const wxString * const m_str;
    const wxString::const_iterator m_iter;

    private: wxAnyStrPtr& operator=(const wxAnyStrPtr&);
};
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 2

class wxDateTime;
class wxTimeSpan;
class wxDateSpan;

struct _SYSTEMTIME;
# 107 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
class wxDateTime;

extern const char wxDefaultDateTimeFormat[];
extern const char wxDefaultTimeSpanFormat[];
extern const wxDateTime wxDefaultDateTime;
# 132 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
class wxDateTime
{
public:
# 143 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    typedef unsigned short wxDateTime_t;





    enum TZ
    {

        Local,






        GMT_12, GMT_11, GMT_10, GMT_9, GMT_8, GMT_7,
        GMT_6, GMT_5, GMT_4, GMT_3, GMT_2, GMT_1,
        GMT0,
        GMT1, GMT2, GMT3, GMT4, GMT5, GMT6,
        GMT7, GMT8, GMT9, GMT10, GMT11, GMT12, GMT13,






        WET = GMT0,
        WEST = GMT1,
        CET = GMT1,
        CEST = GMT2,
        EET = GMT2,
        EEST = GMT3,
        MSK = GMT3,
        MSD = GMT4,


        AST = GMT_4,
        ADT = GMT_3,
        EST = GMT_5,
        EDT = GMT_4,
        CST = GMT_6,
        CDT = GMT_5,
        MST = GMT_7,
        MDT = GMT_6,
        PST = GMT_8,
        PDT = GMT_7,
        HST = GMT_10,
        AKST = GMT_9,
        AKDT = GMT_8,



        A_WST = GMT8,
        A_CST = GMT13 + 1,
        A_EST = GMT10,
        A_ESST = GMT11,


        NZST = GMT12,
        NZDT = GMT13,





        UTC = GMT0
    };





    enum Calendar
    {
        Gregorian,
        Julian


    };
# 235 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    enum Country
    {
        Country_Unknown,
        Country_Default,







        Country_WesternEurope_Start,
        Country_EEC = Country_WesternEurope_Start,
        France,
        Germany,
        UK,
        Country_WesternEurope_End = UK,

        Russia,
        USA
    };

    enum Month
    {
        Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec, Inv_Month
    };


    enum WeekDay
    {
        Sun, Mon, Tue, Wed, Thu, Fri, Sat, Inv_WeekDay
    };


    enum Year
    {
        Inv_Year = 
# 271 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 3 4
                  (-0x7fff - 1)
    
# 272 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
   };


    enum NameFlags
    {
        Name_Full = 0x01,
        Name_Abbr = 0x02
    };


    enum WeekFlags
    {
        Default_First,
        Monday_First,
        Sunday_First
    };






    class TimeZone
    {
    public:
        TimeZone(TZ tz);


        TimeZone(long offset = 0) { m_offset = offset; }

        static TimeZone Make(long offset)
        {
            TimeZone tz;
            tz.m_offset = offset;
            return tz;
        }

        long GetOffset() const { return m_offset; }

    private:

        long m_offset;
    };
# 323 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    struct Tm
    {
        wxDateTime_t msec, sec, min, hour,
                     mday,
                     yday;
        Month mon;
        int year;


        Tm();


        Tm(const struct tm& tm, const TimeZone& tz);


        bool IsValid() const;


        WeekDay GetWeekDay()
        {
            if ( wday == Inv_WeekDay )
                ComputeWeekDay();

            return (WeekDay)wday;
        }


        void AddMonths(int monDiff);


        void AddDays(int dayDiff);

    private:

        void ComputeWeekDay();


        TimeZone m_tz;




        wxDateTime_t wday;
    };





    static void SetCountry(Country country);

    static Country GetCountry();



    static bool IsWestEuropeanCountry(Country country = Country_Default);


    static int GetCurrentYear(Calendar cal = Gregorian);





    static int ConvertYearToBC(int year);


    static Month GetCurrentMonth(Calendar cal = Gregorian);


    static bool IsLeapYear(int year = Inv_Year, Calendar cal = Gregorian);


    static int GetCentury(int year);



    static wxDateTime_t GetNumberOfDays(int year, Calendar cal = Gregorian);



    static wxDateTime_t GetNumberOfDays(Month month,
                                        int year = Inv_Year,
                                        Calendar cal = Gregorian);




    static wxString GetMonthName(Month month,
                                 NameFlags flags = Name_Full);


    static wxString GetEnglishMonthName(Month month,
                                        NameFlags flags = Name_Full);



    static wxString GetWeekDayName(WeekDay weekday,
                                   NameFlags flags = Name_Full);


    static wxString GetEnglishWeekDayName(WeekDay weekday,
                                          NameFlags flags = Name_Full);


    static void GetAmPmStrings(wxString *am, wxString *pm);


    static bool IsDSTApplicable(int year = Inv_Year,
                                Country country = Country_Default);




    static wxDateTime GetBeginDST(int year = Inv_Year,
                                  Country country = Country_Default);



    static wxDateTime GetEndDST(int year = Inv_Year,
                                Country country = Country_Default);


    static inline wxDateTime Now();



    static wxDateTime UNow();



    static inline wxDateTime Today();







    wxDateTime() { m_time = wxLongLong(
# 462 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 3 4
                                      (-0x7fffffff - 1)
# 462 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
                                                 , 0); }




    inline wxDateTime(time_t timet);


    inline wxDateTime(const struct tm& tm);

    inline wxDateTime(const Tm& tm);


    inline wxDateTime(double jdn);


    inline wxDateTime(wxDateTime_t hour,
                      wxDateTime_t minute = 0,
                      wxDateTime_t second = 0,
                      wxDateTime_t millisec = 0);

    inline wxDateTime(wxDateTime_t day,
                      Month month,
                      int year = Inv_Year,
                      wxDateTime_t hour = 0,
                      wxDateTime_t minute = 0,
                      wxDateTime_t second = 0,
                      wxDateTime_t millisec = 0);

    wxDateTime(const struct _SYSTEMTIME& st)
    {
        SetFromMSWSysTime(st);
    }
# 507 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    inline wxDateTime& SetToCurrent();




    inline wxDateTime& Set(time_t timet);



    wxDateTime& Set(const struct tm& tm);


    inline wxDateTime& Set(const Tm& tm);


    wxDateTime& Set(double jdn);


    wxDateTime& Set(wxDateTime_t hour,
                    wxDateTime_t minute = 0,
                    wxDateTime_t second = 0,
                    wxDateTime_t millisec = 0);



    wxDateTime& Set(wxDateTime_t day,
                    Month month,
                    int year = Inv_Year,
                    wxDateTime_t hour = 0,
                    wxDateTime_t minute = 0,
                    wxDateTime_t second = 0,
                    wxDateTime_t millisec = 0);


    wxDateTime& ResetTime();



    wxDateTime GetDateOnly() const;





    wxDateTime& SetYear(int year);

    wxDateTime& SetMonth(Month month);

    wxDateTime& SetDay(wxDateTime_t day);

    wxDateTime& SetHour(wxDateTime_t hour);

    wxDateTime& SetMinute(wxDateTime_t minute);

    wxDateTime& SetSecond(wxDateTime_t second);

    wxDateTime& SetMillisecond(wxDateTime_t millisecond);


    wxDateTime& operator=(time_t timet) { return Set(timet); }


    wxDateTime& operator=(const struct tm& tm) { return Set(tm); }


    wxDateTime& operator=(const Tm& tm) { return Set(tm); }
# 582 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    wxDateTime& SetToWeekDayInSameWeek(WeekDay weekday,
                                       WeekFlags flags = Monday_First);
    inline wxDateTime GetWeekDayInSameWeek(WeekDay weekday,
                                           WeekFlags flags = Monday_First) const;


    wxDateTime& SetToNextWeekDay(WeekDay weekday);
    inline wxDateTime GetNextWeekDay(WeekDay weekday) const;


    wxDateTime& SetToPrevWeekDay(WeekDay weekday);
    inline wxDateTime GetPrevWeekDay(WeekDay weekday) const;





    bool SetToWeekDay(WeekDay weekday,
                      int n = 1,
                      Month month = Inv_Month,
                      int year = Inv_Year);
    inline wxDateTime GetWeekDay(WeekDay weekday,
                                 int n = 1,
                                 Month month = Inv_Month,
                                 int year = Inv_Year) const;


    inline bool SetToLastWeekDay(WeekDay weekday,
                                 Month month = Inv_Month,
                                 int year = Inv_Year);
    inline wxDateTime GetLastWeekDay(WeekDay weekday,
                                     Month month = Inv_Month,
                                     int year = Inv_Year);
# 633 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    static wxDateTime SetToWeekOfYear(int year,
                                      wxDateTime_t numWeek,
                                      WeekDay weekday = Mon);



    wxDateTime& SetToLastMonthDay(Month month = Inv_Month,
                                  int year = Inv_Year);
    inline wxDateTime GetLastMonthDay(Month month = Inv_Month,
                                      int year = Inv_Year) const;


    wxDateTime& SetToYearDay(wxDateTime_t yday);
    inline wxDateTime GetYearDay(wxDateTime_t yday) const;
# 672 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    double GetJulianDayNumber() const;
    double GetJDN() const { return GetJulianDayNumber(); }




    double GetModifiedJulianDayNumber() const { return GetJDN() - 2400000.5; }
    double GetMJD() const { return GetModifiedJulianDayNumber(); }


    double GetRataDie() const;
# 701 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    inline wxDateTime ToTimezone(const TimeZone& tz, bool noDST = false) const;
    wxDateTime& MakeTimezone(const TimeZone& tz, bool noDST = false);



    inline wxDateTime FromTimezone(const TimeZone& tz, bool noDST = false) const;
    wxDateTime& MakeFromTimezone(const TimeZone& tz, bool noDST = false);


    wxDateTime ToUTC(bool noDST = false) const { return ToTimezone(UTC, noDST); }
    wxDateTime& MakeUTC(bool noDST = false) { return MakeTimezone(UTC, noDST); }

    wxDateTime ToGMT(bool noDST = false) const { return ToUTC(noDST); }
    wxDateTime& MakeGMT(bool noDST = false) { return MakeUTC(noDST); }

    wxDateTime FromUTC(bool noDST = false) const
        { return FromTimezone(UTC, noDST); }
    wxDateTime& MakeFromUTC(bool noDST = false)
        { return MakeFromTimezone(UTC, noDST); }






    int IsDST(Country country = Country_Default) const;
# 737 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    inline bool IsValid() const { return m_time != wxDefaultDateTime.m_time; }






    Tm GetTm(const TimeZone& tz = Local) const;



    inline time_t GetTicks() const;


    int GetCentury(const TimeZone& tz = Local) const
            { return GetCentury(GetYear(tz)); }

    int GetYear(const TimeZone& tz = Local) const
            { return GetTm(tz).year; }

    Month GetMonth(const TimeZone& tz = Local) const
            { return (Month)GetTm(tz).mon; }

    wxDateTime_t GetDay(const TimeZone& tz = Local) const
            { return GetTm(tz).mday; }

    WeekDay GetWeekDay(const TimeZone& tz = Local) const
            { return GetTm(tz).GetWeekDay(); }

    wxDateTime_t GetHour(const TimeZone& tz = Local) const
            { return GetTm(tz).hour; }

    wxDateTime_t GetMinute(const TimeZone& tz = Local) const
            { return GetTm(tz).min; }

    wxDateTime_t GetSecond(const TimeZone& tz = Local) const
            { return GetTm(tz).sec; }

    wxDateTime_t GetMillisecond(const TimeZone& tz = Local) const
            { return GetTm(tz).msec; }


    wxDateTime_t GetDayOfYear(const TimeZone& tz = Local) const;


    wxDateTime_t GetWeekOfYear(WeekFlags flags = Monday_First,
                               const TimeZone& tz = Local) const;


    wxDateTime_t GetWeekOfMonth(WeekFlags flags = Monday_First,
                                const TimeZone& tz = Local) const;



    bool IsWorkDay(Country country = Country_Default) const;





    wxDateTime& SetFromDOS(unsigned long ddt);


    unsigned long GetAsDOS() const;





    wxDateTime& SetFromMSWSysTime(const struct _SYSTEMTIME& st);


    void GetAsMSWSysTime(struct _SYSTEMTIME* st) const;


    wxDateTime& SetFromMSWSysDate(const struct _SYSTEMTIME& st);
    void GetAsMSWSysDate(struct _SYSTEMTIME* st) const;






    inline bool IsEqualTo(const wxDateTime& datetime) const;


    inline bool IsEarlierThan(const wxDateTime& datetime) const;


    inline bool IsLaterThan(const wxDateTime& datetime) const;


    inline bool IsStrictlyBetween(const wxDateTime& t1,
                                  const wxDateTime& t2) const;


    inline bool IsBetween(const wxDateTime& t1, const wxDateTime& t2) const;


    inline bool IsSameDate(const wxDateTime& dt) const;


    inline bool IsSameTime(const wxDateTime& dt) const;


    inline bool IsEqualUpTo(const wxDateTime& dt, const wxTimeSpan& ts) const;

    inline bool operator<(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 846, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() < dt.GetValue();
    }

    inline bool operator<=(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 852, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() <= dt.GetValue();
    }

    inline bool operator>(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 858, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() > dt.GetValue();
    }

    inline bool operator>=(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 864, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() >= dt.GetValue();
    }

    inline bool operator==(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 870, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() == dt.GetValue();
    }

    inline bool operator!=(const wxDateTime& dt) const
    {
        do { if ( wxTheAssertHandler && !(IsValid() && dt.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 876, __FUNCTION__, "IsValid() && dt.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return GetValue() != dt.GetValue();
    }





    inline wxDateTime Add(const wxTimeSpan& diff) const;

    inline wxDateTime& Add(const wxTimeSpan& diff);

    inline wxDateTime& operator+=(const wxTimeSpan& diff);
    inline wxDateTime operator+(const wxTimeSpan& ts) const
    {
        wxDateTime dt(*this);
        dt.Add(ts);
        return dt;
    }


    inline wxDateTime Subtract(const wxTimeSpan& diff) const;

    inline wxDateTime& Subtract(const wxTimeSpan& diff);

    inline wxDateTime& operator-=(const wxTimeSpan& diff);
    inline wxDateTime operator-(const wxTimeSpan& ts) const
    {
        wxDateTime dt(*this);
        dt.Subtract(ts);
        return dt;
    }


    inline wxDateTime Add(const wxDateSpan& diff) const;

    wxDateTime& Add(const wxDateSpan& diff);

    inline wxDateTime& operator+=(const wxDateSpan& diff);
    inline wxDateTime operator+(const wxDateSpan& ds) const
    {
        wxDateTime dt(*this);
        dt.Add(ds);
        return dt;
    }


    inline wxDateTime Subtract(const wxDateSpan& diff) const;

    inline wxDateTime& Subtract(const wxDateSpan& diff);

    inline wxDateTime& operator-=(const wxDateSpan& diff);
    inline wxDateTime operator-(const wxDateSpan& ds) const
    {
        wxDateTime dt(*this);
        dt.Subtract(ds);
        return dt;
    }


    inline wxTimeSpan Subtract(const wxDateTime& dt) const;
    inline wxTimeSpan operator-(const wxDateTime& dt2) const;

    wxDateSpan DiffAsDateSpan(const wxDateTime& dt) const;
# 952 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    bool ParseRfc822Date(const wxString& date,
                         wxString::const_iterator *end);





    bool ParseFormat(const wxString& date,
                     const wxString& format,
                     const wxDateTime& dateDef,
                     wxString::const_iterator *end);

    bool ParseFormat(const wxString& date,
                     const wxString& format,
                     wxString::const_iterator *end)
    {
        return ParseFormat(date, format, wxDefaultDateTime, end);
    }

    bool ParseFormat(const wxString& date,
                     wxString::const_iterator *end)
    {
        return ParseFormat(date, wxDefaultDateTimeFormat, wxDefaultDateTime, end);
    }





    bool ParseISODate(const wxString& date)
    {
        wxString::const_iterator end;
        return ParseFormat(date, L"%Y-%m-%d", &end) && end == date.end();
    }

    bool ParseISOTime(const wxString& time)
    {
        wxString::const_iterator end;
        return ParseFormat(time, L"%H:%M:%S", &end) && end == time.end();
    }

    bool ParseISOCombined(const wxString& datetime, char sep = 'T')
    {
        wxString::const_iterator end;
        const wxString fmt = L"%Y-%m-%d" + wxString(sep) + L"%H:%M:%S";
        return ParseFormat(datetime, fmt, &end) && end == datetime.end();
    }



    bool ParseDateTime(const wxString& datetime,
                       wxString::const_iterator *end);



    bool ParseDate(const wxString& date,
                   wxString::const_iterator *end);


    bool ParseTime(const wxString& time,
                   wxString::const_iterator *end);






    wxString Format(const wxString& format = wxDefaultDateTimeFormat,
                    const TimeZone& tz = Local) const;

    wxString FormatDate() const { return Format(L"%x"); }

    wxString FormatTime() const { return Format(L"%X"); }


    wxString FormatISODate() const { return Format(L"%Y-%m-%d"); }


    wxString FormatISOTime() const { return Format(L"%H:%M:%S"); }



    wxString FormatISOCombined(char sep = 'T') const
        { return FormatISODate() + sep + FormatISOTime(); }
# 1046 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    wxAnyStrPtr ParseRfc822Date(const wxString& date)
    {
        wxString::const_iterator end;
        return ParseRfc822Date(date, &end) ? wxAnyStrPtr(date, end)
                                           : wxAnyStrPtr();
    }

    wxAnyStrPtr ParseFormat(const wxString& date,
                            const wxString& format = wxDefaultDateTimeFormat,
                            const wxDateTime& dateDef = wxDefaultDateTime)
    {
        wxString::const_iterator end;
        return ParseFormat(date, format, dateDef, &end) ? wxAnyStrPtr(date, end)
                                                        : wxAnyStrPtr();
    }

    wxAnyStrPtr ParseDateTime(const wxString& datetime)
    {
        wxString::const_iterator end;
        return ParseDateTime(datetime, &end) ? wxAnyStrPtr(datetime, end)
                                             : wxAnyStrPtr();
    }

    wxAnyStrPtr ParseDate(const wxString& date)
    {
        wxString::const_iterator end;
        return ParseDate(date, &end) ? wxAnyStrPtr(date, end)
                                     : wxAnyStrPtr();
    }

    wxAnyStrPtr ParseTime(const wxString& time)
    {
        wxString::const_iterator end;
        return ParseTime(time, &end) ? wxAnyStrPtr(time, end)
                                     : wxAnyStrPtr();
    }
# 1097 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    void ParseRfc822Date(const wxCStrData& date)
        { ParseRfc822Date(wxString(date)); }
    const char* ParseRfc822Date(const char* date);
    const wchar_t* ParseRfc822Date(const wchar_t* date);

    void ParseFormat(const wxCStrData& date,
                     const wxString& format = wxDefaultDateTimeFormat,
                     const wxDateTime& dateDef = wxDefaultDateTime)
        { ParseFormat(wxString(date), format, dateDef); }
    const char* ParseFormat(const char* date,
                            const wxString& format = wxDefaultDateTimeFormat,
                            const wxDateTime& dateDef = wxDefaultDateTime);
    const wchar_t* ParseFormat(const wchar_t* date,
                               const wxString& format = wxDefaultDateTimeFormat,
                               const wxDateTime& dateDef = wxDefaultDateTime);

    void ParseDateTime(const wxCStrData& datetime)
        { ParseDateTime(wxString(datetime)); }
    const char* ParseDateTime(const char* datetime);
    const wchar_t* ParseDateTime(const wchar_t* datetime);

    void ParseDate(const wxCStrData& date)
        { ParseDate(wxString(date)); }
    const char* ParseDate(const char* date);
    const wchar_t* ParseDate(const wchar_t* date);

    void ParseTime(const wxCStrData& time)
        { ParseTime(wxString(time)); }
    const char* ParseTime(const char* time);
    const wchar_t* ParseTime(const wchar_t* time);






    wxDateTime(const wxLongLong& time) { m_time = time; }


    inline wxLongLong GetValue() const;


    static time_t GetTimeNow() { return time(
# 1139 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 3 4
                                            __null
# 1139 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
                                                ); }


    static struct tm *GetTmNow()
    {
        static struct tm l_CurrentTime;
        return GetTmNow(&l_CurrentTime);
    }


    static struct tm *GetTmNow(struct tm *tmstruct);

private:



    static Country ms_country;




    static const long TIME_T_FACTOR;



    inline bool IsInStdRange() const;




    wxLongLong m_time;
};







class wxTimeSpan
{
public:




    static wxTimeSpan Milliseconds(wxLongLong ms) { return wxTimeSpan(0, 0, 0, ms); }
    static wxTimeSpan Millisecond() { return Milliseconds(1); }


    static wxTimeSpan Seconds(wxLongLong sec) { return wxTimeSpan(0, 0, sec); }
    static wxTimeSpan Second() { return Seconds(1); }


    static wxTimeSpan Minutes(long min) { return wxTimeSpan(0, min, 0 ); }
    static wxTimeSpan Minute() { return Minutes(1); }


    static wxTimeSpan Hours(long hours) { return wxTimeSpan(hours, 0, 0); }
    static wxTimeSpan Hour() { return Hours(1); }


    static wxTimeSpan Days(long days) { return Hours(24 * days); }
    static wxTimeSpan Day() { return Days(1); }


    static wxTimeSpan Weeks(long days) { return Days(7 * days); }
    static wxTimeSpan Week() { return Weeks(1); }


    wxTimeSpan() { }




    inline wxTimeSpan(long hours,
                      long minutes = 0,
                      wxLongLong seconds = 0,
                      wxLongLong milliseconds = 0);
# 1227 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    inline wxTimeSpan Add(const wxTimeSpan& diff) const;

    inline wxTimeSpan& Add(const wxTimeSpan& diff);

    wxTimeSpan& operator+=(const wxTimeSpan& diff) { return Add(diff); }
    inline wxTimeSpan operator+(const wxTimeSpan& ts) const
    {
        return wxTimeSpan(GetValue() + ts.GetValue());
    }


    inline wxTimeSpan Subtract(const wxTimeSpan& diff) const;

    inline wxTimeSpan& Subtract(const wxTimeSpan& diff);

    wxTimeSpan& operator-=(const wxTimeSpan& diff) { return Subtract(diff); }
    inline wxTimeSpan operator-(const wxTimeSpan& ts)
    {
        return wxTimeSpan(GetValue() - ts.GetValue());
    }


    inline wxTimeSpan Multiply(int n) const;

    inline wxTimeSpan& Multiply(int n);

    wxTimeSpan& operator*=(int n) { return Multiply(n); }
    inline wxTimeSpan operator*(int n) const
    {
        return wxTimeSpan(*this).Multiply(n);
    }


    wxTimeSpan Negate() const { return wxTimeSpan(-GetValue()); }

    wxTimeSpan& Neg() { m_diff = -GetValue(); return *this; }

    wxTimeSpan& operator-() { return Neg(); }



    inline wxTimeSpan Abs() const;
# 1277 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    bool IsNull() const { return m_diff == 0l; }

    bool operator!() const { return !IsNull(); }


    bool IsPositive() const { return m_diff > 0l; }


    bool IsNegative() const { return m_diff < 0l; }


    inline bool IsEqualTo(const wxTimeSpan& ts) const;



    inline bool IsLongerThan(const wxTimeSpan& ts) const;



    bool IsShorterThan(const wxTimeSpan& t) const;

    inline bool operator<(const wxTimeSpan &ts) const
    {
        return GetValue() < ts.GetValue();
    }

    inline bool operator<=(const wxTimeSpan &ts) const
    {
        return GetValue() <= ts.GetValue();
    }

    inline bool operator>(const wxTimeSpan &ts) const
    {
        return GetValue() > ts.GetValue();
    }

    inline bool operator>=(const wxTimeSpan &ts) const
    {
        return GetValue() >= ts.GetValue();
    }

    inline bool operator==(const wxTimeSpan &ts) const
    {
        return GetValue() == ts.GetValue();
    }

    inline bool operator!=(const wxTimeSpan &ts) const
    {
        return GetValue() != ts.GetValue();
    }





    inline int GetWeeks() const;

    inline int GetDays() const;

    inline int GetHours() const;

    inline int GetMinutes() const;

    inline wxLongLong GetSeconds() const;

    wxLongLong GetMilliseconds() const { return m_diff; }
# 1353 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    wxString Format(const wxString& format = wxDefaultTimeSpanFormat) const;





    wxTimeSpan(const wxLongLong& diff) { m_diff = diff; }


    wxLongLong GetValue() const { return m_diff; }

private:

    wxLongLong m_diff;
};
# 1404 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
class wxDateSpan
{
public:




    wxDateSpan(int years = 0, int months = 0, int weeks = 0, int days = 0)
    {
        m_years = years;
        m_months = months;
        m_weeks = weeks;
        m_days = days;
    }


    static wxDateSpan Days(int days) { return wxDateSpan(0, 0, 0, days); }
    static wxDateSpan Day() { return Days(1); }


    static wxDateSpan Weeks(int weeks) { return wxDateSpan(0, 0, weeks, 0); }
    static wxDateSpan Week() { return Weeks(1); }


    static wxDateSpan Months(int mon) { return wxDateSpan(0, mon, 0, 0); }
    static wxDateSpan Month() { return Months(1); }


    static wxDateSpan Years(int years) { return wxDateSpan(years, 0, 0, 0); }
    static wxDateSpan Year() { return Years(1); }
# 1443 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    wxDateSpan& SetYears(int n) { m_years = n; return *this; }

    wxDateSpan& SetMonths(int n) { m_months = n; return *this; }

    wxDateSpan& SetWeeks(int n) { m_weeks = n; return *this; }

    wxDateSpan& SetDays(int n) { m_days = n; return *this; }


    int GetYears() const { return m_years; }

    int GetMonths() const { return m_months; }

    int GetTotalMonths() const { return 12*m_years + m_months; }

    int GetWeeks() const { return m_weeks; }

    int GetDays() const { return m_days; }

    int GetTotalDays() const { return 7*m_weeks + m_days; }





    inline wxDateSpan Add(const wxDateSpan& other) const;

    inline wxDateSpan& Add(const wxDateSpan& other);

    inline wxDateSpan& operator+=(const wxDateSpan& other);
    inline wxDateSpan operator+(const wxDateSpan& ds) const
    {
        return wxDateSpan(GetYears() + ds.GetYears(),
                          GetMonths() + ds.GetMonths(),
                          GetWeeks() + ds.GetWeeks(),
                          GetDays() + ds.GetDays());
    }


    inline wxDateSpan Subtract(const wxDateSpan& other) const;

    inline wxDateSpan& Subtract(const wxDateSpan& other);

    inline wxDateSpan& operator-=(const wxDateSpan& other);
    inline wxDateSpan operator-(const wxDateSpan& ds) const
    {
        return wxDateSpan(GetYears() - ds.GetYears(),
                          GetMonths() - ds.GetMonths(),
                          GetWeeks() - ds.GetWeeks(),
                          GetDays() - ds.GetDays());
    }


    inline wxDateSpan Negate() const;

    inline wxDateSpan& Neg();

    wxDateSpan& operator-() { return Neg(); }


    inline wxDateSpan Multiply(int factor) const;

    inline wxDateSpan& Multiply(int factor);

    inline wxDateSpan& operator*=(int factor) { return Multiply(factor); }
    inline wxDateSpan operator*(int n) const
    {
        return wxDateSpan(*this).Multiply(n);
    }


    inline bool operator==(const wxDateSpan& ds) const
    {
        return GetYears() == ds.GetYears() &&
               GetMonths() == ds.GetMonths() &&
               GetTotalDays() == ds.GetTotalDays();
    }

    inline bool operator!=(const wxDateSpan& ds) const
    {
        return !(*this == ds);
    }

private:
    int m_years,
        m_months,
        m_weeks,
        m_days;
};





typedef wxDateTime _wxObjArraywxDateTimeArray; typedef int ( *CMPFUNC_wxObjArraywxDateTimeArray)(_wxObjArraywxDateTimeArray **pItem1, _wxObjArraywxDateTimeArray **pItem2); class wxDateTimeArray : protected wxArrayPtrVoid { typedef int ( *CMPFUNCwxArrayPtrVoid)(void **pItem1, void **pItem2); typedef wxArrayPtrVoid base_array; public: wxDateTimeArray() { } wxDateTimeArray(const wxDateTimeArray& src); wxDateTimeArray& operator=(const wxDateTimeArray& src); ~wxDateTimeArray(); void Alloc(size_t count) { wxArrayPtrVoid::reserve(count); } void reserve(size_t count) { wxArrayPtrVoid::reserve(count); } size_t GetCount() const { return base_array::size(); } size_t size() const { return base_array::size(); } bool IsEmpty() const { return base_array::empty(); } bool empty() const { return base_array::empty(); } size_t Count() const { return base_array::size(); } void Shrink() { wxArrayPtrVoid::Shrink(); } _wxObjArraywxDateTimeArray& operator[](size_t uiIndex) const { return *(_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxDateTimeArray& Item(size_t uiIndex) const { return *(_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); } _wxObjArraywxDateTimeArray& Last() const { return *(_wxObjArraywxDateTimeArray*)(wxArrayPtrVoid::operator[](size() - 1)); } int Index(const _wxObjArraywxDateTimeArray& lItem, bool bFromEnd = false) const; void Add(const _wxObjArraywxDateTimeArray& lItem, size_t nInsert = 1); void Add(const _wxObjArraywxDateTimeArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxDateTimeArray*)pItem); } void push_back(const _wxObjArraywxDateTimeArray* pItem) { wxArrayPtrVoid::push_back((_wxObjArraywxDateTimeArray*)pItem); } void push_back(const _wxObjArraywxDateTimeArray& lItem) { Add(lItem); } void Insert(const _wxObjArraywxDateTimeArray& lItem, size_t uiIndex, size_t nInsert = 1); void Insert(const _wxObjArraywxDateTimeArray* pItem, size_t uiIndex) { wxArrayPtrVoid::insert(begin() + uiIndex, (_wxObjArraywxDateTimeArray*)pItem); } void Empty() { DoEmpty(); wxArrayPtrVoid::clear(); } void Clear() { DoEmpty(); wxArrayPtrVoid::clear(); } _wxObjArraywxDateTimeArray* Detach(size_t uiIndex) { _wxObjArraywxDateTimeArray* p = (_wxObjArraywxDateTimeArray*)wxArrayPtrVoid::operator[](uiIndex); wxArrayPtrVoid::erase(begin() + uiIndex); return p; } void RemoveAt(size_t uiIndex, size_t nRemove = 1); void Sort(CMPFUNC_wxObjArraywxDateTimeArray fCmp) { wxArrayPtrVoid::Sort((CMPFUNCwxArrayPtrVoid)fCmp); } private: void DoEmpty(); void DoCopy(const wxDateTimeArray& src); };
# 1548 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
class wxDateTimeHolidayAuthority;
typedef wxDateTimeHolidayAuthority * _wxArraywxHolidayAuthoritiesArray; struct wxAssert_wxHolidayAuthoritiesArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxHolidayAuthoritiesArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxHolidayAuthoritiesArray)(_wxArraywxHolidayAuthoritiesArray *pItem1, _wxArraywxHolidayAuthoritiesArray *pItem2); class wxHolidayAuthoritiesArray : public wxBaseArrayPtrVoid { public: wxHolidayAuthoritiesArray() { } ~wxHolidayAuthoritiesArray() { } _wxArraywxHolidayAuthoritiesArray& operator[](size_t uiIndex) const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxHolidayAuthoritiesArray& Item(size_t uiIndex) const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxHolidayAuthoritiesArray& Last() const { return (_wxArraywxHolidayAuthoritiesArray&)(wxBaseArrayPtrVoid::operator[](GetCount() - 1)); } int Index(_wxArraywxHolidayAuthoritiesArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxHolidayAuthoritiesArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxHolidayAuthoritiesArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxHolidayAuthoritiesArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert(

 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
 ,

 1551
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
 , __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxHolidayAuthoritiesArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 3 4
__null
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxHolidayAuthoritiesArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h" 3 4
__null
# 1549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxHolidayAuthoritiesArray(size_type n) { assign(n, value_type()); } wxHolidayAuthoritiesArray(size_type n, const_reference v) { assign(n, v); } wxHolidayAuthoritiesArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } void swap(wxHolidayAuthoritiesArray& other) { wxBaseArrayPtrVoid::swap(other); } }

                                                     ;

class wxDateTimeHolidaysModule;
class wxDateTimeHolidayAuthority
{
friend class wxDateTimeHolidaysModule;
public:

    static bool IsHoliday(const wxDateTime& dt);



    static size_t GetHolidaysInRange(const wxDateTime& dtStart,
                                     const wxDateTime& dtEnd,
                                     wxDateTimeArray& holidays);


    static void ClearAllAuthorities();



    static void AddAuthority(wxDateTimeHolidayAuthority *auth);


    virtual ~wxDateTimeHolidayAuthority();

protected:

    virtual bool DoIsHoliday(const wxDateTime& dt) const = 0;
# 1589 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
    virtual size_t DoGetHolidaysInRange(const wxDateTime& dtStart,
                                        const wxDateTime& dtEnd,
                                        wxDateTimeArray& holidays) const = 0;

private:

    static wxHolidayAuthoritiesArray ms_authorities;
};


class wxDateTimeWorkDays : public wxDateTimeHolidayAuthority
{
protected:
    virtual bool DoIsHoliday(const wxDateTime& dt) const;
    virtual size_t DoGetHolidaysInRange(const wxDateTime& dtStart,
                                        const wxDateTime& dtEnd,
                                        wxDateTimeArray& holidays) const;
};
# 1631 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
inline bool wxDateTime::IsInStdRange() const
{


    return m_time >= 0l && (m_time / TIME_T_FACTOR) < 0x7fffffff;
}


inline wxDateTime wxDateTime::Now()
{
    struct tm tmstruct;
    return wxDateTime(*GetTmNow(&tmstruct));
}


inline wxDateTime wxDateTime::Today()
{
    wxDateTime dt(Now());
    dt.ResetTime();

    return dt;
}


inline wxDateTime& wxDateTime::Set(time_t timet)
{
    if ( timet == (time_t)-1 )
    {
        m_time = wxDefaultDateTime.m_time;
    }
    else
    {

        m_time = timet - 0;
        m_time *= TIME_T_FACTOR;
    }

    return *this;
}


inline wxDateTime& wxDateTime::SetToCurrent()
{
    *this = Now();
    return *this;
}


inline wxDateTime::wxDateTime(time_t timet)
{
    Set(timet);
}


inline wxDateTime::wxDateTime(const struct tm& tm)
{
    Set(tm);
}

inline wxDateTime::wxDateTime(const Tm& tm)
{
    Set(tm);
}

inline wxDateTime::wxDateTime(double jdn)
{
    Set(jdn);
}

inline wxDateTime& wxDateTime::Set(const Tm& tm)
{
    do { if ( wxTheAssertHandler && !(tm.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1702, __FUNCTION__, "tm.IsValid()", L"invalid broken down date/time"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return Set(tm.mday, (Month)tm.mon, tm.year,
               tm.hour, tm.min, tm.sec, tm.msec);
}

inline wxDateTime::wxDateTime(wxDateTime_t hour,
                              wxDateTime_t minute,
                              wxDateTime_t second,
                              wxDateTime_t millisec)
{
    Set(hour, minute, second, millisec);
}

inline wxDateTime::wxDateTime(wxDateTime_t day,
                              Month month,
                              int year,
                              wxDateTime_t hour,
                              wxDateTime_t minute,
                              wxDateTime_t second,
                              wxDateTime_t millisec)
{
    Set(day, month, year, hour, minute, second, millisec);
}





inline wxLongLong wxDateTime::GetValue() const
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1733, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return m_time;
}

inline time_t wxDateTime::GetTicks() const
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1740, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
    if ( !IsInStdRange() )
    {
        return (time_t)-1;
    }

    return (time_t)((m_time / (long)TIME_T_FACTOR).ToLong()) + 0;
}

inline bool wxDateTime::SetToLastWeekDay(WeekDay weekday,
                                         Month month,
                                         int year)
{
    return SetToWeekDay(weekday, -1, month, year);
}

inline wxDateTime
wxDateTime::GetWeekDayInSameWeek(WeekDay weekday,
                                 WeekFlags ) const
{
    return wxDateTime(*this).SetToWeekDayInSameWeek(weekday);
}

inline wxDateTime wxDateTime::GetNextWeekDay(WeekDay weekday) const
{
    return wxDateTime(*this).SetToNextWeekDay(weekday);
}

inline wxDateTime wxDateTime::GetPrevWeekDay(WeekDay weekday) const
{
    return wxDateTime(*this).SetToPrevWeekDay(weekday);
}

inline wxDateTime wxDateTime::GetWeekDay(WeekDay weekday,
                                         int n,
                                         Month month,
                                         int year) const
{
    wxDateTime dt(*this);

    return dt.SetToWeekDay(weekday, n, month, year) ? dt : wxDefaultDateTime;
}

inline wxDateTime wxDateTime::GetLastWeekDay(WeekDay weekday,
                                             Month month,
                                             int year)
{
    wxDateTime dt(*this);

    return dt.SetToLastWeekDay(weekday, month, year) ? dt : wxDefaultDateTime;
}

inline wxDateTime wxDateTime::GetLastMonthDay(Month month, int year) const
{
    return wxDateTime(*this).SetToLastMonthDay(month, year);
}

inline wxDateTime wxDateTime::GetYearDay(wxDateTime_t yday) const
{
    return wxDateTime(*this).SetToYearDay(yday);
}





inline bool wxDateTime::IsEqualTo(const wxDateTime& datetime) const
{
    do { if ( wxTheAssertHandler && !(IsValid() && datetime.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1808, __FUNCTION__, "IsValid() && datetime.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return m_time == datetime.m_time;
}

inline bool wxDateTime::IsEarlierThan(const wxDateTime& datetime) const
{
    do { if ( wxTheAssertHandler && !(IsValid() && datetime.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1815, __FUNCTION__, "IsValid() && datetime.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return m_time < datetime.m_time;
}

inline bool wxDateTime::IsLaterThan(const wxDateTime& datetime) const
{
    do { if ( wxTheAssertHandler && !(IsValid() && datetime.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1822, __FUNCTION__, "IsValid() && datetime.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return m_time > datetime.m_time;
}

inline bool wxDateTime::IsStrictlyBetween(const wxDateTime& t1,
                                          const wxDateTime& t2) const
{

    return IsLaterThan(t1) && IsEarlierThan(t2);
}

inline bool wxDateTime::IsBetween(const wxDateTime& t1,
                                  const wxDateTime& t2) const
{

    return IsEqualTo(t1) || IsEqualTo(t2) || IsStrictlyBetween(t1, t2);
}

inline bool wxDateTime::IsSameDate(const wxDateTime& dt) const
{
    Tm tm1 = GetTm(),
       tm2 = dt.GetTm();

    return tm1.year == tm2.year &&
           tm1.mon == tm2.mon &&
           tm1.mday == tm2.mday;
}

inline bool wxDateTime::IsSameTime(const wxDateTime& dt) const
{





    Tm tm1 = GetTm(),
       tm2 = dt.GetTm();

    return tm1.hour == tm2.hour &&
           tm1.min == tm2.min &&
           tm1.sec == tm2.sec &&
           tm1.msec == tm2.msec;
}

inline bool wxDateTime::IsEqualUpTo(const wxDateTime& dt,
                                    const wxTimeSpan& ts) const
{
    return IsBetween(dt.Subtract(ts), dt.Add(ts));
}





inline wxDateTime wxDateTime::Add(const wxTimeSpan& diff) const
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1879, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return wxDateTime(m_time + diff.GetValue());
}

inline wxDateTime& wxDateTime::Add(const wxTimeSpan& diff)
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1886, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    m_time += diff.GetValue();

    return *this;
}

inline wxDateTime& wxDateTime::operator+=(const wxTimeSpan& diff)
{
    return Add(diff);
}

inline wxDateTime wxDateTime::Subtract(const wxTimeSpan& diff) const
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1900, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return wxDateTime(m_time - diff.GetValue());
}

inline wxDateTime& wxDateTime::Subtract(const wxTimeSpan& diff)
{
    do { if ( wxTheAssertHandler && !(IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1907, __FUNCTION__, "IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    m_time -= diff.GetValue();

    return *this;
}

inline wxDateTime& wxDateTime::operator-=(const wxTimeSpan& diff)
{
    return Subtract(diff);
}

inline wxTimeSpan wxDateTime::Subtract(const wxDateTime& datetime) const
{
    do { if ( wxTheAssertHandler && !(IsValid() && datetime.IsValid()) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h", 1921, __FUNCTION__, "IsValid() && datetime.IsValid()", L"invalid wxDateTime"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );

    return wxTimeSpan(GetValue() - datetime.GetValue());
}

inline wxTimeSpan wxDateTime::operator-(const wxDateTime& dt2) const
{
    return this->Subtract(dt2);
}

inline wxDateTime wxDateTime::Add(const wxDateSpan& diff) const
{
    return wxDateTime(*this).Add(diff);
}

inline wxDateTime& wxDateTime::Subtract(const wxDateSpan& diff)
{
    return Add(diff.Negate());
}

inline wxDateTime wxDateTime::Subtract(const wxDateSpan& diff) const
{
    return wxDateTime(*this).Subtract(diff);
}

inline wxDateTime& wxDateTime::operator-=(const wxDateSpan& diff)
{
    return Subtract(diff);
}

inline wxDateTime& wxDateTime::operator+=(const wxDateSpan& diff)
{
    return Add(diff);
}





inline wxDateTime
wxDateTime::ToTimezone(const wxDateTime::TimeZone& tz, bool noDST) const
{
    return wxDateTime(*this).MakeTimezone(tz, noDST);
}

inline wxDateTime
wxDateTime::FromTimezone(const wxDateTime::TimeZone& tz, bool noDST) const
{
    return wxDateTime(*this).MakeFromTimezone(tz, noDST);
}





inline wxTimeSpan::wxTimeSpan(long hours,
                              long minutes,
                              wxLongLong seconds,
                              wxLongLong milliseconds)
{

    m_diff = hours;
    m_diff *= 60l;
    m_diff += minutes;
    m_diff *= 60l;
    m_diff += seconds;
    m_diff *= 1000l;
    m_diff += milliseconds;
}





inline wxLongLong wxTimeSpan::GetSeconds() const
{
    return m_diff / 1000l;
}

inline int wxTimeSpan::GetMinutes() const
{


    return static_cast<int>((GetSeconds() / 60l).GetLo());
}

inline int wxTimeSpan::GetHours() const
{
    return GetMinutes() / 60;
}

inline int wxTimeSpan::GetDays() const
{
    return GetHours() / 24;
}

inline int wxTimeSpan::GetWeeks() const
{
    return GetDays() / 7;
}





inline wxTimeSpan wxTimeSpan::Add(const wxTimeSpan& diff) const
{
    return wxTimeSpan(m_diff + diff.GetValue());
}

inline wxTimeSpan& wxTimeSpan::Add(const wxTimeSpan& diff)
{
    m_diff += diff.GetValue();

    return *this;
}

inline wxTimeSpan wxTimeSpan::Subtract(const wxTimeSpan& diff) const
{
    return wxTimeSpan(m_diff - diff.GetValue());
}

inline wxTimeSpan& wxTimeSpan::Subtract(const wxTimeSpan& diff)
{
    m_diff -= diff.GetValue();

    return *this;
}

inline wxTimeSpan& wxTimeSpan::Multiply(int n)
{
    m_diff *= (long)n;

    return *this;
}

inline wxTimeSpan wxTimeSpan::Multiply(int n) const
{
    return wxTimeSpan(m_diff * (long)n);
}

inline wxTimeSpan wxTimeSpan::Abs() const
{
    return wxTimeSpan(GetValue().Abs());
}

inline bool wxTimeSpan::IsEqualTo(const wxTimeSpan& ts) const
{
    return GetValue() == ts.GetValue();
}

inline bool wxTimeSpan::IsLongerThan(const wxTimeSpan& ts) const
{
    return GetValue().Abs() > ts.GetValue().Abs();
}

inline bool wxTimeSpan::IsShorterThan(const wxTimeSpan& ts) const
{
    return GetValue().Abs() < ts.GetValue().Abs();
}





inline wxDateSpan& wxDateSpan::operator+=(const wxDateSpan& other)
{
    m_years += other.m_years;
    m_months += other.m_months;
    m_weeks += other.m_weeks;
    m_days += other.m_days;

    return *this;
}

inline wxDateSpan& wxDateSpan::Add(const wxDateSpan& other)
{
    return *this += other;
}

inline wxDateSpan wxDateSpan::Add(const wxDateSpan& other) const
{
    wxDateSpan ds(*this);
    ds.Add(other);
    return ds;
}

inline wxDateSpan& wxDateSpan::Multiply(int factor)
{
    m_years *= factor;
    m_months *= factor;
    m_weeks *= factor;
    m_days *= factor;

    return *this;
}

inline wxDateSpan wxDateSpan::Multiply(int factor) const
{
    wxDateSpan ds(*this);
    ds.Multiply(factor);
    return ds;
}

inline wxDateSpan wxDateSpan::Negate() const
{
    return wxDateSpan(-m_years, -m_months, -m_weeks, -m_days);
}

inline wxDateSpan& wxDateSpan::Neg()
{
    m_years = -m_years;
    m_months = -m_months;
    m_weeks = -m_weeks;
    m_days = -m_days;

    return *this;
}

inline wxDateSpan& wxDateSpan::operator-=(const wxDateSpan& other)
{
    return *this += other.Negate();
}

inline wxDateSpan& wxDateSpan::Subtract(const wxDateSpan& other)
{
    return *this -= other;
}

inline wxDateSpan wxDateSpan::Subtract(const wxDateSpan& other) const
{
    wxDateSpan ds(*this);
    ds.Subtract(other);
    return ds;
}
# 2169 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
wxTimeSpan operator*(int n, const wxTimeSpan& ts);





wxDateSpan operator*(int n, const wxDateSpan& ds);
# 2187 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/datetime.h"
 void wxNextMonth(wxDateTime::Month& m);
 void wxPrevMonth(wxDateTime::Month& m);
 void wxNextWDay(wxDateTime::WeekDay& wd);
 void wxPrevWDay(wxDateTime::WeekDay& wd);
# 590 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 2
    template<> class wxAnyValueTypeImpl<wxDateTime> : public wxAnyValueTypeImplBase<wxDateTime> { friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); } public: wxAnyValueTypeImpl() : wxAnyValueTypeImplBase<wxDateTime>() { } virtual ~wxAnyValueTypeImpl() { } virtual bool ConvertValue(const wxAnyValueBuffer& src, wxAnyValueType* dstType, wxAnyValueBuffer& dst) const { wxUnusedVar(src); wxUnusedVar(dstType); wxUnusedVar(dst); return false; } };
# 602 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
class wxAnyToVariantRegistration;


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 1
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 1
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/iosfwrap.h" 2
# 30 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 2

class wxAny;
# 56 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
class wxVariantData : public wxObjectRefData
{
    friend class wxVariant;
public:
    wxVariantData() { }


    virtual bool Eq(wxVariantData& data) const = 0;


    virtual bool Write(std:: ostream& ) const { return false; }

    virtual bool Write(wxString& ) const { return false; }

    virtual bool Read(std:: istream& ) { return false; }

    virtual bool Read(wxString& ) { return false; }

    virtual wxString GetType() const = 0;

    virtual wxClassInfo* GetValueClassInfo() { return 
# 76 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
                                                     __null
# 76 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
                                                         ; }



    virtual wxVariantData* Clone() const { return 
# 80 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
                                                 __null
# 80 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
                                                     ; }



    virtual bool GetAsAny(wxAny* ) const { return false; }


protected:



    virtual ~wxVariantData() { }
};






class wxVariant;

typedef wxVariant _WX_LIST_ITEM_TYPE_wxVariantList; typedef int (*wxSortFuncFor_wxVariantList)(const wxVariant **, const wxVariant **); class wxwxVariantListNode : public wxNodeBase { public: wxwxVariantListNode(wxListBase *list = 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, wxwxVariantListNode *previous = 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, wxwxVariantListNode *next = 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, wxVariant *data = 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxVariantListNode *GetNext() const { return (wxwxVariantListNode *)wxNodeBase::GetNext(); } wxwxVariantListNode *GetPrevious() const { return (wxwxVariantListNode *)wxNodeBase::GetPrevious(); } wxVariant *GetData() const { return (wxVariant *)wxNodeBase::GetData(); } void SetData(wxVariant *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxVariantListNode(const wxwxVariantListNode&); wxwxVariantListNode& operator=(const wxwxVariantListNode&); }; class wxVariantList : public wxListBase { public: typedef wxwxVariantListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxVariantList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxVariantList(const wxVariantList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxVariantList(size_t count, wxVariant *elements[]) : wxListBase(count, (void **)elements) { } wxVariantList& operator=(const wxVariantList& list) { if (&list != this) Assign(list); return *this; } wxwxVariantListNode *GetFirst() const { return (wxwxVariantListNode *)wxListBase::GetFirst(); } wxwxVariantListNode *GetLast() const { return (wxwxVariantListNode *)wxListBase::GetLast(); } wxwxVariantListNode *Item(size_t index) const { return (wxwxVariantListNode *)wxListBase::Item(index); } wxVariant *operator[](size_t index) const { wxwxVariantListNode *node = Item(index); return node ? (wxVariant*)(node->GetData()) : 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
; } wxwxVariantListNode *Append(wxVariant *object) { return (wxwxVariantListNode *)wxListBase::Append(object); } wxwxVariantListNode *Insert(wxVariant *object) { return (wxwxVariantListNode *)Insert(static_cast<wxwxVariantListNode *>(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
), object); } wxwxVariantListNode *Insert(size_t pos, wxVariant *object) { return (wxwxVariantListNode *)wxListBase::Insert(pos, object); } wxwxVariantListNode *Insert(wxwxVariantListNode *prev, wxVariant *object) { return (wxwxVariantListNode *)wxListBase::Insert(prev, object); } wxwxVariantListNode *Append(long key, void *object) { return (wxwxVariantListNode *)wxListBase::Append(key, object); } wxwxVariantListNode *Append(const wxChar *key, void *object) { return (wxwxVariantListNode *)wxListBase::Append(key, object); } wxwxVariantListNode *DetachNode(wxwxVariantListNode *node) { return (wxwxVariantListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxVariantListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxVariant *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxVariantListNode *it) { DeleteNode(it); } wxwxVariantListNode *Find(const wxVariant *object) const { return (wxwxVariantListNode *)wxListBase::Find(object); } virtual wxwxVariantListNode *Find(const wxListKey& key) const { return (wxwxVariantListNode *)wxListBase::Find(key); } bool Member(const wxVariant *object) const { return Find(object) != 
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
; } int IndexOf(wxVariant *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxVariantList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxVariantListNode(this, (wxwxVariantListNode *)prev, (wxwxVariantListNode *)next, (wxVariant *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxVariant* value_type; typedef wxVariant* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxVariantList list; public: typedef wxwxVariantListNode Node; typedef iterator itor; typedef wxVariant* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
), m_init(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h", 101, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h", 101, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxVariantList list; public: typedef wxwxVariantListNode Node; typedef wxVariant* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
), m_init(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h", 101, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h", 101, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxVariantList list; public: typedef wxwxVariantListNode Node; typedef wxVariant* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
), m_init(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxVariantList list; public: typedef wxwxVariantListNode Node; typedef wxVariant* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
), m_init(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxVariantList(size_type n, const_reference v = value_type()) { assign(n, v); } wxVariantList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 3 4
__null
# 101 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxVariantList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxVariantList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxVariantList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };

class wxVariant: public wxObject
{
public:
    wxVariant();

    wxVariant(const wxVariant& variant);
    wxVariant(wxVariantData* data, const wxString& name = wxEmptyString);

    wxVariant(const wxAny& any);

    virtual ~wxVariant();


    void operator= (const wxVariant& variant);



    void operator= (wxVariantData* variantData);

    bool operator== (const wxVariant& variant) const;
    bool operator!= (const wxVariant& variant) const;


    inline void SetName(const wxString& name) { m_name = name; }
    inline const wxString& GetName() const { return m_name; }


    bool IsNull() const;



    wxVariantData* GetData() const
    {
        return (wxVariantData*) m_refData;
    }
    void SetData(wxVariantData* data) ;


    void Ref(const wxVariant& clone) { wxObject::Ref(clone); }


    bool Unshare();


    void MakeNull();


    void Clear();



    wxString GetType() const;

    bool IsType(const wxString& type) const;
    bool IsValueKindOf(const wxClassInfo* type) const;


    wxString MakeString() const;


    wxAny GetAny() const;



    wxVariant(double val, const wxString& name = wxEmptyString);
    bool operator== (double value) const;
    bool operator!= (double value) const;
    void operator= (double value) ;
    inline operator double () const { return GetDouble(); }
    inline double GetReal() const { return GetDouble(); }
    double GetDouble() const;


    wxVariant(long val, const wxString& name = wxEmptyString);
    wxVariant(int val, const wxString& name = wxEmptyString);
    wxVariant(short val, const wxString& name = wxEmptyString);
    bool operator== (long value) const;
    bool operator!= (long value) const;
    void operator= (long value) ;
    inline operator long () const { return GetLong(); }
    inline long GetInteger() const { return GetLong(); }
    long GetLong() const;


    wxVariant(bool val, const wxString& name = wxEmptyString);
    bool operator== (bool value) const;
    bool operator!= (bool value) const;
    void operator= (bool value) ;
    inline operator bool () const { return GetBool(); }
    bool GetBool() const ;



    wxVariant(const wxDateTime& val, const wxString& name = wxEmptyString);
    bool operator== (const wxDateTime& value) const;
    bool operator!= (const wxDateTime& value) const;
    void operator= (const wxDateTime& value) ;
    inline operator wxDateTime () const { return GetDateTime(); }
    wxDateTime GetDateTime() const;



    wxVariant(const wxString& val, const wxString& name = wxEmptyString);


    wxVariant(const char* val, const wxString& name = wxEmptyString);
    wxVariant(const wchar_t* val, const wxString& name = wxEmptyString);
    wxVariant(const wxCStrData& val, const wxString& name = wxEmptyString);
    wxVariant(const wxScopedCharBuffer& val, const wxString& name = wxEmptyString);
    wxVariant(const wxScopedWCharBuffer& val, const wxString& name = wxEmptyString);

    bool operator== (const wxString& value) const;
    bool operator!= (const wxString& value) const;
    wxVariant& operator=(const wxString& value);


    wxVariant& operator=(const char* value)
        { return *this = wxString(value); }
    wxVariant& operator=(const wchar_t* value)
        { return *this = wxString(value); }
    wxVariant& operator=(const wxCStrData& value)
        { return *this = value.AsString(); }
    template<typename T>
    wxVariant& operator=(const wxScopedCharTypeBuffer<T>& value)
        { return *this = value.data(); }

    inline operator wxString () const { return MakeString(); }
    wxString GetString() const;


    wxVariant(const std::string& val, const wxString& name = wxEmptyString);
    bool operator==(const std::string& value) const
        { return operator==(wxString(value)); }
    bool operator!=(const std::string& value) const
        { return operator!=(wxString(value)); }
    wxVariant& operator=(const std::string& value)
        { return operator=(wxString(value)); }
    operator std::string() const { return (operator wxString()).ToStdString(); }

    wxVariant(const wxStdWideString& val, const wxString& name = wxEmptyString);
    bool operator==(const wxStdWideString& value) const
        { return operator==(wxString(value)); }
    bool operator!=(const wxStdWideString& value) const
        { return operator!=(wxString(value)); }
    wxVariant& operator=(const wxStdWideString& value)
        { return operator=(wxString(value)); }
    operator wxStdWideString() const { return (operator wxString()).ToStdWstring(); }



    wxVariant(const wxUniChar& val, const wxString& name = wxEmptyString);
    wxVariant(const wxUniCharRef& val, const wxString& name = wxEmptyString);
    wxVariant(char val, const wxString& name = wxEmptyString);
    wxVariant(wchar_t val, const wxString& name = wxEmptyString);
    bool operator==(const wxUniChar& value) const;
    bool operator==(const wxUniCharRef& value) const { return *this == wxUniChar(value); }
    bool operator==(char value) const { return *this == wxUniChar(value); }
    bool operator==(wchar_t value) const { return *this == wxUniChar(value); }
    bool operator!=(const wxUniChar& value) const { return !(*this == value); }
    bool operator!=(const wxUniCharRef& value) const { return !(*this == value); }
    bool operator!=(char value) const { return !(*this == value); }
    bool operator!=(wchar_t value) const { return !(*this == value); }
    wxVariant& operator=(const wxUniChar& value);
    wxVariant& operator=(const wxUniCharRef& value) { return *this = wxUniChar(value); }
    wxVariant& operator=(char value) { return *this = wxUniChar(value); }
    wxVariant& operator=(wchar_t value) { return *this = wxUniChar(value); }
    operator wxUniChar() const { return GetChar(); }
    operator char() const { return GetChar(); }
    operator wchar_t() const { return GetChar(); }
    wxUniChar GetChar() const;


    wxVariant(const wxArrayString& val, const wxString& name = wxEmptyString);
    bool operator== (const wxArrayString& value) const;
    bool operator!= (const wxArrayString& value) const;
    void operator= (const wxArrayString& value);
    operator wxArrayString () const { return GetArrayString(); }
    wxArrayString GetArrayString() const;


    wxVariant(void* ptr, const wxString& name = wxEmptyString);
    bool operator== (void* value) const;
    bool operator!= (void* value) const;
    void operator= (void* value);
    operator void* () const { return GetVoidPtr(); }
    void* GetVoidPtr() const;


    wxVariant(wxObject* ptr, const wxString& name = wxEmptyString);
    bool operator== (wxObject* value) const;
    bool operator!= (wxObject* value) const;
    void operator= (wxObject* value);
    wxObject* GetWxObjectPtr() const;



    wxVariant(wxLongLong, const wxString& name = wxEmptyString);
    bool operator==(wxLongLong value) const;
    bool operator!=(wxLongLong value) const;
    void operator=(wxLongLong value);
    operator wxLongLong() const { return GetLongLong(); }
    wxLongLong GetLongLong() const;


    wxVariant(wxULongLong, const wxString& name = wxEmptyString);
    bool operator==(wxULongLong value) const;
    bool operator!=(wxULongLong value) const;
    void operator=(wxULongLong value);
    operator wxULongLong() const { return GetULongLong(); }
    wxULongLong GetULongLong() const;






    wxVariant(const wxVariantList& val, const wxString& name = wxEmptyString);
    bool operator== (const wxVariantList& value) const;
    bool operator!= (const wxVariantList& value) const;
    void operator= (const wxVariantList& value) ;

    wxVariant operator[] (size_t idx) const;
    wxVariant& operator[] (size_t idx) ;
    wxVariantList& GetList() const ;


    size_t GetCount() const;


    void NullList();


    void Append(const wxVariant& value);


    void Insert(const wxVariant& value);


    bool Member(const wxVariant& value) const;


    bool Delete(size_t item);


    void ClearList();

public:

    bool Convert(long* value) const;
    bool Convert(bool* value) const;
    bool Convert(double* value) const;
    bool Convert(wxString* value) const;
    bool Convert(wxUniChar* value) const;
    bool Convert(char* value) const;
    bool Convert(wchar_t* value) const;

    bool Convert(wxDateTime* value) const;


    bool Convert(wxLongLong* value) const;
    bool Convert(wxULongLong* value) const;

    bool Convert(long long* value) const
    {
        wxLongLong temp;
        if ( !Convert(&temp) )
            return false;
        *value = temp.GetValue();
        return true;
    }
    bool Convert(unsigned long long* value) const
    {
        wxULongLong temp;
        if ( !Convert(&temp) )
            return false;
        *value = temp.GetValue();
        return true;
    }




protected:
    virtual wxObjectRefData *CreateRefData() const;
    virtual wxObjectRefData *CloneRefData(const wxObjectRefData *data) const;

    wxString m_name;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 1
# 402 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h" 2



typedef wxVariantData* (*wxVariantDataFactory)(const wxAny& any);






class wxAnyToVariantRegistration
{
public:
    wxAnyToVariantRegistration(wxVariantDataFactory factory);
    virtual ~wxAnyToVariantRegistration();

    virtual wxAnyValueType* GetAssociatedType() = 0;
    wxVariantDataFactory GetFactory() const { return m_factory; }
private:
    wxVariantDataFactory m_factory;
};

template<typename T>
class wxAnyToVariantRegistrationImpl : public wxAnyToVariantRegistration
{
public:
    wxAnyToVariantRegistrationImpl(wxVariantDataFactory factory)
        : wxAnyToVariantRegistration(factory)
    {
    }

    virtual wxAnyValueType* GetAssociatedType()
    {
        return wxAnyValueTypeImpl<T>::GetInstance();
    }
private:
};
# 578 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/variant.h"
extern wxVariant wxNullVariant;
# 606 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 2






class wxAnyValueTypeImplVariantData :
    public wxAnyValueTypeImplBase<wxVariantData*>
{
    friend class wxAny; public: static bool IsSameClass(const wxAnyValueType* otherType) { return AreSameClasses(*sm_instance.get(), *otherType); } virtual bool IsSameType(const wxAnyValueType* otherType) const { return IsSameClass(otherType); } private: static bool AreSameClasses(const wxAnyValueType& a, const wxAnyValueType& b) { return wxTypeIdentifier(typeid(a).name()) == wxTypeIdentifier(typeid(b).name()); } static wxAnyValueTypeScopedPtr sm_instance; public: static wxAnyValueType* GetInstance() { return sm_instance.get(); }
public:
    wxAnyValueTypeImplVariantData() :
        wxAnyValueTypeImplBase<wxVariantData*>() { }
    virtual ~wxAnyValueTypeImplVariantData() { }

    virtual void DeleteValue(wxAnyValueBuffer& buf) const
    {
        wxVariantData* data = static_cast<wxVariantData*>(buf.m_ptr);
        if ( data )
            data->DecRef();
    }

    virtual void CopyBuffer(const wxAnyValueBuffer& src,
                            wxAnyValueBuffer& dst) const
    {
        wxVariantData* data = static_cast<wxVariantData*>(src.m_ptr);
        if ( data )
            data->IncRef();
        dst.m_ptr = data;
    }

    static void SetValue(wxVariantData* value,
                         wxAnyValueBuffer& buf)
    {
        value->IncRef();
        buf.m_ptr = value;
    }

    static wxVariantData* GetValue(const wxAnyValueBuffer& buf)
    {
        return static_cast<wxVariantData*>(buf.m_ptr);
    }

    virtual bool ConvertValue(const wxAnyValueBuffer& src,
                              wxAnyValueType* dstType,
                              wxAnyValueBuffer& dst) const
    {
        wxUnusedVar(src);
        wxUnusedVar(dstType);
        wxUnusedVar(dst);
        return false;
    }
};

template<>
class wxAnyValueTypeImpl<wxVariantData*> :
    public wxAnyValueTypeImplVariantData
{
public:
    wxAnyValueTypeImpl() : wxAnyValueTypeImplVariantData() { }
    virtual ~wxAnyValueTypeImpl() { }
};
# 683 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
extern wxAnyValueType* wxAnyNullValueType;
# 718 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
extern void
wxPreRegisterAnyToVariant(wxAnyToVariantRegistration* reg);


extern bool
wxConvertAnyToVariant(const wxAny& any, wxVariant* variant);
# 735 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
class wxAny
{
public:



    wxAny()
    {
        m_type = wxAnyNullValueType;
    }




    ~wxAny()
    {
        m_type->DeleteValue(m_buffer);
    }





    template<typename T>
    wxAny(const T& value)
    {
        m_type = wxAnyValueTypeImpl<T>::sm_instance.get();
        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
    }


    wxAny(const char* value)
    {
        m_type = wxAnyValueTypeImpl<const char*>::sm_instance.get();
        wxAnyValueTypeImpl<const char*>::SetValue(value, m_buffer);
    }
    wxAny(const wchar_t* value)
    {
        m_type = wxAnyValueTypeImpl<const wchar_t*>::sm_instance.get();
        wxAnyValueTypeImpl<const wchar_t*>::SetValue(value, m_buffer);
    }

    wxAny(const wxAny& any)
    {
        m_type = wxAnyNullValueType;
        AssignAny(any);
    }


    wxAny(const wxVariant& variant)
    {
        m_type = wxAnyNullValueType;
        AssignVariant(variant);
    }
# 804 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    template <typename T>
    bool CheckType(T* = 
# 805 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
                       __null
# 805 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
                           ) const
    {
        return m_type->CheckType<T>();
    }
# 819 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    const wxAnyValueType* GetType() const
    {
        return m_type;
    }





    bool HasSameType(const wxAny& other) const
    {
        return GetType()->IsSameType(other.GetType());
    }




    bool IsNull() const
    {
        return (m_type == wxAnyNullValueType);
    }




    void MakeNull()
    {
        m_type->DeleteValue(m_buffer);
        m_type = wxAnyNullValueType;
    }





    template<typename T>
    wxAny& operator=(const T &value)
    {
        m_type->DeleteValue(m_buffer);
        m_type = wxAnyValueTypeImpl<T>::sm_instance.get();
        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
        return *this;
    }

    wxAny& operator=(const wxAny &any)
    {
        if (this != &any)
            AssignAny(any);
        return *this;
    }


    wxAny& operator=(const wxVariant &variant)
    {
        AssignVariant(variant);
        return *this;
    }



    wxAny& operator=(const char* value)
    {
        Assign(value);
        return *this;
    }
    wxAny& operator=(const wchar_t* value)
    {
        Assign(value);
        return *this;
    }





    bool operator==(const wxString& value) const
    {
        wxString value2;
        if ( !GetAs(&value2) )
            return false;
        return value == value2;
    }

    bool operator==(const char* value) const
        { return (*this) == wxString(value); }
    bool operator==(const wchar_t* value) const
        { return (*this) == wxString(value); }




    bool operator==(signed char value) const { if ( wxAnyValueTypeImpl<signed char>::IsSameClass(m_type) ) return (value == static_cast<signed char> (wxAnyValueTypeImpl<signed char>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<unsigned char>::IsSameClass(m_type) ) return (value == static_cast<signed char> (wxAnyValueTypeImpl<unsigned char>::GetValue(m_buffer))); return false; } bool operator==(unsigned char value) const { if ( wxAnyValueTypeImpl<unsigned char>::IsSameClass(m_type) ) return (value == static_cast<unsigned char> (wxAnyValueTypeImpl<unsigned char>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<signed char>::IsSameClass(m_type) ) return (value == static_cast<unsigned char> (wxAnyValueTypeImpl<signed char>::GetValue(m_buffer))); return false; }
    bool operator==(signed short value) const { if ( wxAnyValueTypeImpl<signed short>::IsSameClass(m_type) ) return (value == static_cast<signed short> (wxAnyValueTypeImpl<signed short>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<unsigned short>::IsSameClass(m_type) ) return (value == static_cast<signed short> (wxAnyValueTypeImpl<unsigned short>::GetValue(m_buffer))); return false; } bool operator==(unsigned short value) const { if ( wxAnyValueTypeImpl<unsigned short>::IsSameClass(m_type) ) return (value == static_cast<unsigned short> (wxAnyValueTypeImpl<unsigned short>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<signed short>::IsSameClass(m_type) ) return (value == static_cast<unsigned short> (wxAnyValueTypeImpl<signed short>::GetValue(m_buffer))); return false; }
    bool operator==(signed int value) const { if ( wxAnyValueTypeImpl<signed int>::IsSameClass(m_type) ) return (value == static_cast<signed int> (wxAnyValueTypeImpl<signed int>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<unsigned int>::IsSameClass(m_type) ) return (value == static_cast<signed int> (wxAnyValueTypeImpl<unsigned int>::GetValue(m_buffer))); return false; } bool operator==(unsigned int value) const { if ( wxAnyValueTypeImpl<unsigned int>::IsSameClass(m_type) ) return (value == static_cast<unsigned int> (wxAnyValueTypeImpl<unsigned int>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<signed int>::IsSameClass(m_type) ) return (value == static_cast<unsigned int> (wxAnyValueTypeImpl<signed int>::GetValue(m_buffer))); return false; }
    bool operator==(signed long value) const { if ( wxAnyValueTypeImpl<signed long>::IsSameClass(m_type) ) return (value == static_cast<signed long> (wxAnyValueTypeImpl<signed long>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<unsigned long>::IsSameClass(m_type) ) return (value == static_cast<signed long> (wxAnyValueTypeImpl<unsigned long>::GetValue(m_buffer))); return false; } bool operator==(unsigned long value) const { if ( wxAnyValueTypeImpl<unsigned long>::IsSameClass(m_type) ) return (value == static_cast<unsigned long> (wxAnyValueTypeImpl<unsigned long>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<signed long>::IsSameClass(m_type) ) return (value == static_cast<unsigned long> (wxAnyValueTypeImpl<signed long>::GetValue(m_buffer))); return false; }

    bool operator==(long long value) const { if ( wxAnyValueTypeImpl<long long>::IsSameClass(m_type) ) return (value == static_cast<long long> (wxAnyValueTypeImpl<long long>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<unsigned long long>::IsSameClass(m_type) ) return (value == static_cast<long long> (wxAnyValueTypeImpl<unsigned long long>::GetValue(m_buffer))); return false; } bool operator==(unsigned long long value) const { if ( wxAnyValueTypeImpl<unsigned long long>::IsSameClass(m_type) ) return (value == static_cast<unsigned long long> (wxAnyValueTypeImpl<unsigned long long>::GetValue(m_buffer))); if ( wxAnyValueTypeImpl<long long>::IsSameClass(m_type) ) return (value == static_cast<unsigned long long> (wxAnyValueTypeImpl<long long>::GetValue(m_buffer))); return false; }


   
# 918 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
#pragma GCC diagnostic push
# 918 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
   
# 918 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 918 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
   

    bool operator==(float value) const
    {
        if ( !wxAnyValueTypeImpl<float>::IsSameClass(m_type) )
            return false;

        return value ==
            static_cast<float>
                (wxAnyValueTypeImpl<float>::GetValue(m_buffer));
    }

    bool operator==(double value) const
    {
        if ( !wxAnyValueTypeImpl<double>::IsSameClass(m_type) )
            return false;

        return value ==
            static_cast<double>
                (wxAnyValueTypeImpl<double>::GetValue(m_buffer));
    }

   
# 940 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
#pragma GCC diagnostic pop
# 940 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
   

    bool operator==(bool value) const
    {
        if ( !wxAnyValueTypeImpl<bool>::IsSameClass(m_type) )
            return false;

        return value == (wxAnyValueTypeImpl<bool>::GetValue(m_buffer));
    }







    template<typename T>
    bool operator!=(const T& value) const
        { return !((*this) == value); }
# 975 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    template<typename T>
    T As(T* = 
# 976 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
             __null
# 976 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
                 ) const
    {
        if ( !wxAnyValueTypeImpl<T>::IsSameClass(m_type) )
        {
            do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 980, __FUNCTION__, "Assert failure", "Incorrect or non-convertible data type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        }

        return static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(m_buffer));
    }




    wxString As(wxString*) const
    {
        wxString value;
        if ( !GetAs(&value) )
        {
            do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 994, __FUNCTION__, "Assert failure", "Incorrect or non-convertible data type"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        }
        return value;
    }
# 1011 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
    template<typename T>
    bool GetAs(T* value) const
    {
        if ( !wxAnyValueTypeImpl<T>::IsSameClass(m_type) )
        {
            wxAnyValueType* otherType =
                wxAnyValueTypeImpl<T>::sm_instance.get();
            wxAnyValueBuffer temp_buf;

            if ( !m_type->ConvertValue(m_buffer, otherType, temp_buf) )
                return false;

            *value =
                static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(temp_buf));
            otherType->DeleteValue(temp_buf);

            return true;
        }
        *value = static_cast<T>(wxAnyValueTypeImpl<T>::GetValue(m_buffer));
        return true;
    }



    bool GetAs(wxVariant* value) const
    {
        return wxConvertAnyToVariant(*this, value);
    }


private:

    void AssignAny(const wxAny& any)
    {

        m_type->DeleteValue(m_buffer);

        wxAnyValueType* newType = any.m_type;

        if ( !newType->IsSameType(m_type) )
            m_type = newType;

        newType->CopyBuffer(any.m_buffer, m_buffer);
    }


    void AssignVariant(const wxVariant& variant)
    {
        wxVariantData* data = variant.GetData();

        if ( data && data->GetAsAny(this) )
            return;

        m_type->DeleteValue(m_buffer);

        if ( variant.IsNull() )
        {

            m_type = wxAnyNullValueType;
        }
        else
        {

            m_type = wxAnyValueTypeImpl<wxVariantData*>::sm_instance.get();
            wxAnyValueTypeImpl<wxVariantData*>::SetValue(data, m_buffer);
        }
    }


    template<typename T>
    void Assign(const T &value)
    {
        m_type->DeleteValue(m_buffer);
        m_type = wxAnyValueTypeImpl<T>::sm_instance.get();
        wxAnyValueTypeImpl<T>::SetValue(value, m_buffer);
    }


    wxAnyValueBuffer m_buffer;
    wxAnyValueType* m_type;
};
# 1106 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
template<typename T>
inline bool wxAnyValueType::CheckType(T* reserved) const
{
    wxUnusedVar(reserved);
    return wxAnyValueTypeImpl<T>::IsSameClass(this);
}

typedef wxAny _WX_LIST_ITEM_TYPE_wxAnyList; typedef int (*wxSortFuncFor_wxAnyList)(const wxAny **, const wxAny **); class wxwxAnyListNode : public wxNodeBase { public: wxwxAnyListNode(wxListBase *list = 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, wxwxAnyListNode *previous = 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, wxwxAnyListNode *next = 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, wxAny *data = 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxwxAnyListNode *GetNext() const { return (wxwxAnyListNode *)wxNodeBase::GetNext(); } wxwxAnyListNode *GetPrevious() const { return (wxwxAnyListNode *)wxNodeBase::GetPrevious(); } wxAny *GetData() const { return (wxAny *)wxNodeBase::GetData(); } void SetData(wxAny *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxwxAnyListNode(const wxwxAnyListNode&); wxwxAnyListNode& operator=(const wxwxAnyListNode&); }; class wxAnyList : public wxListBase { public: typedef wxwxAnyListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxAnyList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxAnyList(const wxAnyList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxAnyList(size_t count, wxAny *elements[]) : wxListBase(count, (void **)elements) { } wxAnyList& operator=(const wxAnyList& list) { if (&list != this) Assign(list); return *this; } wxwxAnyListNode *GetFirst() const { return (wxwxAnyListNode *)wxListBase::GetFirst(); } wxwxAnyListNode *GetLast() const { return (wxwxAnyListNode *)wxListBase::GetLast(); } wxwxAnyListNode *Item(size_t index) const { return (wxwxAnyListNode *)wxListBase::Item(index); } wxAny *operator[](size_t index) const { wxwxAnyListNode *node = Item(index); return node ? (wxAny*)(node->GetData()) : 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
; } wxwxAnyListNode *Append(wxAny *object) { return (wxwxAnyListNode *)wxListBase::Append(object); } wxwxAnyListNode *Insert(wxAny *object) { return (wxwxAnyListNode *)Insert(static_cast<wxwxAnyListNode *>(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
), object); } wxwxAnyListNode *Insert(size_t pos, wxAny *object) { return (wxwxAnyListNode *)wxListBase::Insert(pos, object); } wxwxAnyListNode *Insert(wxwxAnyListNode *prev, wxAny *object) { return (wxwxAnyListNode *)wxListBase::Insert(prev, object); } wxwxAnyListNode *Append(long key, void *object) { return (wxwxAnyListNode *)wxListBase::Append(key, object); } wxwxAnyListNode *Append(const wxChar *key, void *object) { return (wxwxAnyListNode *)wxListBase::Append(key, object); } wxwxAnyListNode *DetachNode(wxwxAnyListNode *node) { return (wxwxAnyListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxwxAnyListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxAny *object) { return wxListBase::DeleteObject(object); } void Erase(wxwxAnyListNode *it) { DeleteNode(it); } wxwxAnyListNode *Find(const wxAny *object) const { return (wxwxAnyListNode *)wxListBase::Find(object); } virtual wxwxAnyListNode *Find(const wxListKey& key) const { return (wxwxAnyListNode *)wxListBase::Find(key); } bool Member(const wxAny *object) const { return Find(object) != 
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
; } int IndexOf(wxAny *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxAnyList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxwxAnyListNode(this, (wxwxAnyListNode *)prev, (wxwxAnyListNode *)next, (wxAny *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxAny* value_type; typedef wxAny* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxAnyList list; public: typedef wxwxAnyListNode Node; typedef iterator itor; typedef wxAny* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
), m_init(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 1113, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 1113, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxAnyList list; public: typedef wxwxAnyListNode Node; typedef wxAny* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
), m_init(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 1113, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h", 1113, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxAnyList list; public: typedef wxwxAnyListNode Node; typedef wxAny* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
), m_init(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxAnyList list; public: typedef wxwxAnyListNode Node; typedef wxAny* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
), m_init(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxAnyList(size_type n, const_reference v = value_type()) { assign(n, v); } wxAnyList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h" 3 4
__null
# 1113 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/any.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxAnyList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxAnyList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxAnyList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };
# 30 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/convertible.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/convertible.h"
template <class D, class B>
struct wxConvertibleTo_SizeHelper
{
    static char Match(B* pb);
    static int Match(...);
};



template <class D, class B>
struct wxConvertibleTo
{
    enum
    {
        value =
            sizeof(wxConvertibleTo_SizeHelper<D,B>::Match(static_cast<D*>(
# 31 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/convertible.h" 3 4
                                                                         __null
# 31 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/convertible.h"
                                                                             )))
            ==
            sizeof(char)
    };
};
# 33 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2





# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/removeref.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/meta/removeref.h"
template <typename T>
struct wxRemoveRef
{
    typedef T type;
};

template <typename T>
struct wxRemoveRef<T&>
{
    typedef T type;
};
# 39 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 2
# 47 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxList;
class wxEvent;
class wxEventFilter;

    class wxDC;
    class wxMenu;
    class wxWindow;
    class wxWindowBase;
# 74 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxEvtHandler;
class wxEventConnectionRef;





typedef int wxEventType;
# 97 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
extern wxEventType wxNewEventType();
# 146 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
typedef void (wxEvtHandler::*wxEventFunction)(wxEvent&);

template <typename T>
inline wxEventFunction wxEventFunctionCast(void (wxEvtHandler::*func)(T&))
{
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
   
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
#pragma GCC diagnostic push
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
   
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
#pragma GCC diagnostic ignored "-Wcast-function-type"
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
   

    return reinterpret_cast<wxEventFunction>(func);

   
# 163 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
#pragma GCC diagnostic pop
# 163 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
   
}
# 178 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
template <typename T>
class wxEventTypeTag
{
public:

    typedef T EventClass;

    wxEventTypeTag(wxEventType type) { m_type = type; }




    operator const wxEventType&() const { return m_type; }

private:
    wxEventType m_type;
};




typedef void (wxEvtHandler::*wxEventFunction)(wxEvent&);
# 208 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
typedef wxEventFunction wxObjectEventFunction;


class wxEventFunctor
{
public:
    virtual ~wxEventFunctor();


    virtual void operator()(wxEvtHandler *, wxEvent&) = 0;



    virtual bool IsMatching(const wxEventFunctor& functor) const = 0;



    virtual wxEvtHandler *GetEvtHandler() const
        { return 
# 226 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                __null
# 226 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                    ; }





    virtual wxEventFunction GetEvtMethod() const
        { return 
# 233 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                __null
# 233 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                    ; }

private:
   
};


class wxObjectEventFunctor : public wxEventFunctor
{
public:
    wxObjectEventFunctor(wxObjectEventFunction method, wxEvtHandler *handler)
        : m_handler( handler ), m_method( method )
        { }

    virtual void operator()(wxEvtHandler *handler, wxEvent& event);

    virtual bool IsMatching(const wxEventFunctor& functor) const
    {
        if ( wxTypeIdentifier(typeid(functor).name()) == wxTypeIdentifier(typeid(*this).name()) )
        {
            const wxObjectEventFunctor &other =
                static_cast< const wxObjectEventFunctor & >( functor );







            return ( m_method == other.m_method || other.m_method == 0 ) &&
                   ( m_handler == other.m_handler || other.m_handler == 
# 263 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                                       __null 
# 263 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                            );
        }
        else
            return false;
    }

    virtual wxEvtHandler *GetEvtHandler() const
        { return m_handler; }

    virtual wxEventFunction GetEvtMethod() const
        { return m_method; }

private:
    wxEvtHandler *m_handler;
    wxEventFunction m_method;


    wxObjectEventFunctor() { }

   
};


inline wxObjectEventFunctor *
wxNewEventFunctor(const wxEventType& ,
                  wxObjectEventFunction method,
                  wxEvtHandler *handler)
{
    return new wxObjectEventFunctor(method, handler);
}


inline wxObjectEventFunctor *
wxNewEventTableFunctor(const wxEventType& ,
                       wxObjectEventFunction method)
{
    return new wxObjectEventFunctor(method, 
# 299 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                           __null
# 299 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                               );
}

inline wxObjectEventFunctor
wxMakeEventFunctor(const wxEventType& ,
                        wxObjectEventFunction method,
                        wxEvtHandler *handler)
{
    return wxObjectEventFunctor(method, handler);
}



namespace wxPrivate
{



template <typename T> struct EventClassOf;



template <typename T>
struct EventClassOf< wxEventTypeTag<T> >
{
    typedef typename wxEventTypeTag<T>::EventClass type;
};



template <>
struct EventClassOf<wxEventType>
{
    typedef wxEvent type;
};




template <typename T, typename A, bool> struct HandlerImpl;


template <typename T, typename A>
struct HandlerImpl<T, A, true>
{
    static bool IsEvtHandler()
        { return true; }
    static T *ConvertFromEvtHandler(wxEvtHandler *p)
        { return static_cast<T *>(p); }
    static wxEvtHandler *ConvertToEvtHandler(T *p)
        { return p; }
    static wxEventFunction ConvertToEvtMethod(void (T::*f)(A&))
        { return wxEventFunctionCast(
                    static_cast<void (wxEvtHandler::*)(A&)>(f)); }
};


template <typename T, typename A>
struct HandlerImpl<T, A, false>
{
    static bool IsEvtHandler()
        { return false; }
    static T *ConvertFromEvtHandler(wxEvtHandler *)
        { return 
# 362 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                __null
# 362 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                    ; }
    static wxEvtHandler *ConvertToEvtHandler(T *)
        { return 
# 364 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                __null
# 364 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                    ; }
    static wxEventFunction ConvertToEvtMethod(void (T::*)(A&))
        { return 
# 366 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                __null
# 366 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                    ; }
};

}
# 380 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
template
  <typename EventTag, typename Class, typename EventArg, typename EventHandler>
class wxEventFunctorMethod
    : public wxEventFunctor,
      private wxPrivate::HandlerImpl
              <
                Class,
                EventArg,
                wxConvertibleTo<Class, wxEvtHandler>::value != 0
              >
{
private:
    static void CheckHandlerArgument(EventArg *) { }

public:

    typedef typename wxPrivate::EventClassOf<EventTag>::type EventClass;


    wxEventFunctorMethod(void (Class::*method)(EventArg&), EventHandler *handler)
        : m_handler( handler ), m_method( method )
    {
        do { if ( wxTheAssertHandler && !(handler || this->IsEvtHandler()) && (wxOnAssert(

                                                                   "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 402 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        ,

                                                                   404
# 402 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        , __FUNCTION__, "handler || this->IsEvtHandler()", "handlers defined in non-wxEvtHandler-derived classes " "must be connected with a valid sink object"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )

                                                                    ;




        CheckHandlerArgument(static_cast<EventClass *>(
# 409 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                      __null
# 409 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                          ));
    }

    virtual void operator()(wxEvtHandler *handler, wxEvent& event)
    {
        Class * realHandler = m_handler;
        if ( !realHandler )
        {
            realHandler = this->ConvertFromEvtHandler(handler);


            if ( realHandler ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h", 420, __FUNCTION__, "realHandler", "invalid event handler"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;
        }




        (realHandler->*m_method)(static_cast<EventArg&>(event));
    }

    virtual bool IsMatching(const wxEventFunctor& functor) const
    {
        if ( wxTypeIdentifier(typeid(functor).name()) != wxTypeIdentifier(typeid(*this).name()) )
            return false;

        typedef wxEventFunctorMethod<EventTag, Class, EventArg, EventHandler>
            ThisFunctor;


        const ThisFunctor& other = static_cast<const ThisFunctor &>(functor);

        return (m_method == other.m_method || other.m_method == 
# 440 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                               __null
# 440 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                   ) &&
               (m_handler == other.m_handler || other.m_handler == 
# 441 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                                  __null
# 441 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                      );
    }

    virtual wxEvtHandler *GetEvtHandler() const
        { return this->ConvertToEvtHandler(m_handler); }

    virtual wxEventFunction GetEvtMethod() const
        { return this->ConvertToEvtMethod(m_method); }

private:
    EventHandler *m_handler;
    void (Class::*m_method)(EventArg&);


    wxEventFunctorMethod() { }

    typedef wxEventFunctorMethod<EventTag, Class,
                                 EventArg, EventHandler> thisClass;
   
};



template <typename EventTag, typename EventArg>
class wxEventFunctorFunction : public wxEventFunctor
{
private:
    static void CheckHandlerArgument(EventArg *) { }

public:

    typedef typename wxPrivate::EventClassOf<EventTag>::type EventClass;

    wxEventFunctorFunction( void ( *handler )( EventArg & ))
        : m_handler( handler )
    {



        CheckHandlerArgument(static_cast<EventClass *>(
# 480 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                      __null
# 480 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                          ));
    }

    virtual void operator()(wxEvtHandler *, wxEvent& event)
    {







        m_handler(static_cast<EventArg&>(event));
    }

    virtual bool IsMatching(const wxEventFunctor &functor) const
    {
        if ( wxTypeIdentifier(typeid(functor).name()) != wxTypeIdentifier(typeid(*this).name()) )
            return false;

        typedef wxEventFunctorFunction<EventTag, EventArg> ThisFunctor;

        const ThisFunctor& other = static_cast<const ThisFunctor&>( functor );

        return m_handler == other.m_handler;
    }

private:
    void (*m_handler)(EventArg&);


    wxEventFunctorFunction() { }

    typedef wxEventFunctorFunction<EventTag, EventArg> thisClass;
   
};


template <typename EventTag, typename Functor>
class wxEventFunctorFunctor : public wxEventFunctor
{
public:
    typedef typename EventTag::EventClass EventArg;

    wxEventFunctorFunctor(const Functor& handler)
        : m_handler(handler), m_handlerAddr(&handler)
        { }

    virtual void operator()(wxEvtHandler *, wxEvent& event)
    {







        m_handler(static_cast<EventArg&>(event));
    }

    virtual bool IsMatching(const wxEventFunctor &functor) const
    {
        if ( wxTypeIdentifier(typeid(functor).name()) != wxTypeIdentifier(typeid(*this).name()) )
            return false;

        typedef wxEventFunctorFunctor<EventTag, Functor> FunctorThis;

        const FunctorThis& other = static_cast<const FunctorThis&>(functor);



        return m_handlerAddr == other.m_handlerAddr;
    }

private:


    Functor m_handler;


    const void *m_handlerAddr;


    wxEventFunctorFunctor() { }

    typedef wxEventFunctorFunctor<EventTag, Functor> thisClass;
   
};
# 576 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
template <typename EventTag, typename EventArg>
inline wxEventFunctorFunction<EventTag, EventArg> *
wxNewEventFunctor(const EventTag&, void (*func)(EventArg &))
{
    return new wxEventFunctorFunction<EventTag, EventArg>(func);
}

template <typename EventTag, typename EventArg>
inline wxEventFunctorFunction<EventTag, EventArg>
wxMakeEventFunctor(const EventTag&, void (*func)(EventArg &))
{
    return wxEventFunctorFunction<EventTag, EventArg>(func);
}


template <typename EventTag, typename Functor>
inline wxEventFunctorFunctor<EventTag, Functor> *
wxNewEventFunctor(const EventTag&, const Functor &func)
{
    return new wxEventFunctorFunctor<EventTag, Functor>(func);
}

template <typename EventTag, typename Functor>
inline wxEventFunctorFunctor<EventTag, Functor>
wxMakeEventFunctor(const EventTag&, const Functor &func)
{
    return wxEventFunctorFunctor<EventTag, Functor>(func);
}


template
  <typename EventTag, typename Class, typename EventArg, typename EventHandler>
inline wxEventFunctorMethod<EventTag, Class, EventArg, EventHandler> *
wxNewEventFunctor(const EventTag&,
                  void (Class::*method)(EventArg&),
                  EventHandler *handler)
{
    return new wxEventFunctorMethod<EventTag, Class, EventArg, EventHandler>(
                method, handler);
}

template
    <typename EventTag, typename Class, typename EventArg, typename EventHandler>
inline wxEventFunctorMethod<EventTag, Class, EventArg, EventHandler>
wxMakeEventFunctor(const EventTag&,
                   void (Class::*method)(EventArg&),
                   EventHandler *handler)
{
    return wxEventFunctorMethod<EventTag, Class, EventArg, EventHandler>(
                method, handler);
}




template <typename EventTag, typename Class, typename EventArg>
inline wxEventFunctorMethod<EventTag, Class, EventArg, Class> *
wxNewEventTableFunctor(const EventTag&, void (Class::*method)(EventArg&))
{
    return new wxEventFunctorMethod<EventTag, Class, EventArg, Class>(
                    method, 
# 636 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                           __null
# 636 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                               );
}







extern const wxEventType wxEVT_NULL;
extern const wxEventType wxEVT_FIRST;
extern const wxEventType wxEVT_USER_FIRST;


class wxIdleEvent;
class wxThreadEvent;
class wxAsyncMethodCallEvent;
class wxCommandEvent;
class wxMouseEvent;
class wxFocusEvent;
class wxChildFocusEvent;
class wxKeyEvent;
class wxNavigationKeyEvent;
class wxSetCursorEvent;
class wxScrollEvent;
class wxSpinEvent;
class wxScrollWinEvent;
class wxSizeEvent;
class wxMoveEvent;
class wxCloseEvent;
class wxActivateEvent;
class wxWindowCreateEvent;
class wxWindowDestroyEvent;
class wxShowEvent;
class wxIconizeEvent;
class wxMaximizeEvent;
class wxMouseCaptureChangedEvent;
class wxMouseCaptureLostEvent;
class wxPaintEvent;
class wxEraseEvent;
class wxNcPaintEvent;
class wxMenuEvent;
class wxContextMenuEvent;
class wxSysColourChangedEvent;
class wxDisplayChangedEvent;
class wxQueryNewPaletteEvent;
class wxPaletteChangedEvent;
class wxJoystickEvent;
class wxDropFilesEvent;
class wxInitDialogEvent;
class wxUpdateUIEvent;
class wxClipboardTextEvent;
class wxHelpEvent;



extern const wxEventTypeTag< wxCommandEvent > wxEVT_BUTTON;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_CHECKBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_CHOICE;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_LISTBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_LISTBOX_DCLICK;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_CHECKLISTBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_MENU;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_SLIDER;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_RADIOBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_RADIOBUTTON;


extern const wxEventTypeTag< wxCommandEvent > wxEVT_SCROLLBAR;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_VLBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMBOBOX;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TOOL_RCLICKED;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TOOL_DROPDOWN;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TOOL_ENTER;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMBOBOX_DROPDOWN;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMBOBOX_CLOSEUP;


extern const wxEventTypeTag< wxThreadEvent > wxEVT_THREAD;
extern const wxEventTypeTag< wxAsyncMethodCallEvent > wxEVT_ASYNC_METHOD_CALL;


extern const wxEventTypeTag< wxMouseEvent > wxEVT_LEFT_DOWN;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_LEFT_UP;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_MIDDLE_DOWN;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_MIDDLE_UP;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_RIGHT_DOWN;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_RIGHT_UP;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_MOTION;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_ENTER_WINDOW;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_LEAVE_WINDOW;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_LEFT_DCLICK;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_MIDDLE_DCLICK;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_RIGHT_DCLICK;
extern const wxEventTypeTag< wxFocusEvent > wxEVT_SET_FOCUS;
extern const wxEventTypeTag< wxFocusEvent > wxEVT_KILL_FOCUS;
extern const wxEventTypeTag< wxChildFocusEvent > wxEVT_CHILD_FOCUS;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_MOUSEWHEEL;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX1_DOWN;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX1_UP;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX1_DCLICK;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX2_DOWN;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX2_UP;
extern const wxEventTypeTag< wxMouseEvent > wxEVT_AUX2_DCLICK;


extern const wxEventTypeTag< wxKeyEvent > wxEVT_CHAR;
extern const wxEventTypeTag< wxKeyEvent > wxEVT_CHAR_HOOK;
extern const wxEventTypeTag< wxNavigationKeyEvent > wxEVT_NAVIGATION_KEY;
extern const wxEventTypeTag< wxKeyEvent > wxEVT_KEY_DOWN;
extern const wxEventTypeTag< wxKeyEvent > wxEVT_KEY_UP;

extern const wxEventTypeTag< wxKeyEvent > wxEVT_HOTKEY;



extern const wxEventTypeTag< wxKeyEvent > wxEVT_AFTER_CHAR;


extern const wxEventTypeTag< wxSetCursorEvent > wxEVT_SET_CURSOR;


extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_TOP;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_BOTTOM;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_LINEUP;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_LINEDOWN;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_PAGEUP;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_PAGEDOWN;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_THUMBTRACK;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_THUMBRELEASE;
extern const wxEventTypeTag< wxScrollEvent > wxEVT_SCROLL_CHANGED;
# 777 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
extern const wxEventTypeTag< wxSpinEvent > wxEVT_SPIN_UP;
extern const wxEventTypeTag< wxSpinEvent > wxEVT_SPIN_DOWN;
extern const wxEventTypeTag< wxSpinEvent > wxEVT_SPIN;




extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_TOP;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_BOTTOM;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_LINEUP;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_LINEDOWN;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_PAGEUP;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_PAGEDOWN;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_THUMBTRACK;
extern const wxEventTypeTag< wxScrollWinEvent > wxEVT_SCROLLWIN_THUMBRELEASE;


extern const wxEventTypeTag< wxSizeEvent > wxEVT_SIZE;
extern const wxEventTypeTag< wxMoveEvent > wxEVT_MOVE;
extern const wxEventTypeTag< wxCloseEvent > wxEVT_CLOSE_WINDOW;
extern const wxEventTypeTag< wxCloseEvent > wxEVT_END_SESSION;
extern const wxEventTypeTag< wxCloseEvent > wxEVT_QUERY_END_SESSION;
extern const wxEventTypeTag< wxActivateEvent > wxEVT_ACTIVATE_APP;
extern const wxEventTypeTag< wxActivateEvent > wxEVT_ACTIVATE;
extern const wxEventTypeTag< wxWindowCreateEvent > wxEVT_CREATE;
extern const wxEventTypeTag< wxWindowDestroyEvent > wxEVT_DESTROY;
extern const wxEventTypeTag< wxShowEvent > wxEVT_SHOW;
extern const wxEventTypeTag< wxIconizeEvent > wxEVT_ICONIZE;
extern const wxEventTypeTag< wxMaximizeEvent > wxEVT_MAXIMIZE;
extern const wxEventTypeTag< wxMouseCaptureChangedEvent > wxEVT_MOUSE_CAPTURE_CHANGED;
extern const wxEventTypeTag< wxMouseCaptureLostEvent > wxEVT_MOUSE_CAPTURE_LOST;
extern const wxEventTypeTag< wxPaintEvent > wxEVT_PAINT;
extern const wxEventTypeTag< wxEraseEvent > wxEVT_ERASE_BACKGROUND;
extern const wxEventTypeTag< wxNcPaintEvent > wxEVT_NC_PAINT;
extern const wxEventTypeTag< wxMenuEvent > wxEVT_MENU_OPEN;
extern const wxEventTypeTag< wxMenuEvent > wxEVT_MENU_CLOSE;
extern const wxEventTypeTag< wxMenuEvent > wxEVT_MENU_HIGHLIGHT;
extern const wxEventTypeTag< wxContextMenuEvent > wxEVT_CONTEXT_MENU;
extern const wxEventTypeTag< wxSysColourChangedEvent > wxEVT_SYS_COLOUR_CHANGED;
extern const wxEventTypeTag< wxDisplayChangedEvent > wxEVT_DISPLAY_CHANGED;
extern const wxEventTypeTag< wxQueryNewPaletteEvent > wxEVT_QUERY_NEW_PALETTE;
extern const wxEventTypeTag< wxPaletteChangedEvent > wxEVT_PALETTE_CHANGED;
extern const wxEventTypeTag< wxJoystickEvent > wxEVT_JOY_BUTTON_DOWN;
extern const wxEventTypeTag< wxJoystickEvent > wxEVT_JOY_BUTTON_UP;
extern const wxEventTypeTag< wxJoystickEvent > wxEVT_JOY_MOVE;
extern const wxEventTypeTag< wxJoystickEvent > wxEVT_JOY_ZMOVE;
extern const wxEventTypeTag< wxDropFilesEvent > wxEVT_DROP_FILES;
extern const wxEventTypeTag< wxInitDialogEvent > wxEVT_INIT_DIALOG;
extern const wxEventTypeTag< wxIdleEvent > wxEVT_IDLE;
extern const wxEventTypeTag< wxUpdateUIEvent > wxEVT_UPDATE_UI;
extern const wxEventTypeTag< wxSizeEvent > wxEVT_SIZING;
extern const wxEventTypeTag< wxMoveEvent > wxEVT_MOVING;
extern const wxEventTypeTag< wxMoveEvent > wxEVT_MOVE_START;
extern const wxEventTypeTag< wxMoveEvent > wxEVT_MOVE_END;
extern const wxEventTypeTag< wxActivateEvent > wxEVT_HIBERNATE;


extern const wxEventTypeTag< wxClipboardTextEvent > wxEVT_TEXT_COPY;
extern const wxEventTypeTag< wxClipboardTextEvent > wxEVT_TEXT_CUT;
extern const wxEventTypeTag< wxClipboardTextEvent > wxEVT_TEXT_PASTE;



extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_LEFT_CLICK;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_LEFT_DCLICK;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_RIGHT_CLICK;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_RIGHT_DCLICK;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_SET_FOCUS;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_KILL_FOCUS;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_COMMAND_ENTER;


extern const wxEventTypeTag< wxHelpEvent > wxEVT_HELP;
extern const wxEventTypeTag< wxHelpEvent > wxEVT_DETAILED_HELP;
# 863 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TEXT;
# 872 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum wxEventPropagation
{

    wxEVENT_PROPAGATE_NONE = 0,


    wxEVENT_PROPAGATE_MAX = 0x7fffffff
};



enum wxEventCategory
{





    wxEVT_CATEGORY_UI = 1,





    wxEVT_CATEGORY_USER_INPUT = 2,


    wxEVT_CATEGORY_SOCKET = 4,


    wxEVT_CATEGORY_TIMER = 8,




    wxEVT_CATEGORY_THREAD = 16,





    wxEVT_CATEGORY_UNKNOWN = 32,




    wxEVT_CATEGORY_CLIPBOARD = 64,






    wxEVT_CATEGORY_NATIVE_EVENTS = wxEVT_CATEGORY_UI|wxEVT_CATEGORY_USER_INPUT,


    wxEVT_CATEGORY_ALL =
        wxEVT_CATEGORY_UI|wxEVT_CATEGORY_USER_INPUT|wxEVT_CATEGORY_SOCKET|
        wxEVT_CATEGORY_TIMER|wxEVT_CATEGORY_THREAD|wxEVT_CATEGORY_UNKNOWN|
        wxEVT_CATEGORY_CLIPBOARD
};
# 946 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxEvent : public wxObject
{
public:
    wxEvent(int winid = 0, wxEventType commandType = wxEVT_NULL );

    void SetEventType(wxEventType typ) { m_eventType = typ; }
    wxEventType GetEventType() const { return m_eventType; }

    wxObject *GetEventObject() const { return m_eventObject; }
    void SetEventObject(wxObject *obj) { m_eventObject = obj; }

    long GetTimestamp() const { return m_timeStamp; }
    void SetTimestamp(long ts = 0) { m_timeStamp = ts; }

    int GetId() const { return m_id; }
    void SetId(int Id) { m_id = Id; }



    wxObject *GetEventUserData() const { return m_callbackUserData; }





    void Skip(bool skip = true) { m_skipped = skip; }
    bool GetSkipped() const { return m_skipped; }




    virtual wxEvent *Clone() const = 0;




    virtual wxEventCategory GetEventCategory() const
        { return wxEVT_CATEGORY_UI; }



    bool IsCommandEvent() const { return m_isCommandEvent; }


    bool ShouldPropagate() const
        { return m_propagationLevel != wxEVENT_PROPAGATE_NONE; }



    int StopPropagation()
    {
        int propagationLevel = m_propagationLevel;
        m_propagationLevel = wxEVENT_PROPAGATE_NONE;
        return propagationLevel;
    }



    void ResumePropagation(int propagationLevel)
    {
        m_propagationLevel = propagationLevel;
    }



    wxEvtHandler* GetPropagatedFrom() const { return m_propagatedFrom; }




    bool WasProcessed()
    {
        if ( m_wasProcessed )
            return true;

        m_wasProcessed = true;

        return false;
    }



    void SetWillBeProcessedAgain()
    {
        m_willBeProcessedAgain = true;
    }

    bool WillBeProcessedAgain()
    {
        if ( m_willBeProcessedAgain )
        {
            m_willBeProcessedAgain = false;
            return true;
        }

        return false;
    }




    bool ShouldProcessOnlyIn(wxEvtHandler *h) const
    {
        return h == m_handlerToProcessOnlyIn;
    }







    void DidntHonourProcessOnlyIn()
    {
        m_handlerToProcessOnlyIn = 
# 1060 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                  __null
# 1060 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                      ;
    }

protected:
    wxObject* m_eventObject;
    wxEventType m_eventType;
    long m_timeStamp;
    int m_id;

public:

    wxObject* m_callbackUserData;

private:

    wxEvtHandler *m_handlerToProcessOnlyIn;

protected:


    int m_propagationLevel;



    wxEvtHandler* m_propagatedFrom;

    bool m_skipped;
    bool m_isCommandEvent;





    bool m_wasProcessed;




    bool m_willBeProcessedAgain;

protected:
    wxEvent(const wxEvent&);
    wxEvent& operator=(const wxEvent&);

private:

    friend class wxPropagateOnce;


    friend class wxEventProcessInHandlerOnly;


    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};




class wxPropagationDisabler
{
public:
    wxPropagationDisabler(wxEvent& event) : m_event(event)
    {
        m_propagationLevelOld = m_event.StopPropagation();
    }

    ~wxPropagationDisabler()
    {
        m_event.ResumePropagation(m_propagationLevelOld);
    }

private:
    wxEvent& m_event;
    int m_propagationLevelOld;

    private: wxPropagationDisabler(const wxPropagationDisabler&); wxPropagationDisabler& operator=(const wxPropagationDisabler&);
};





class wxPropagateOnce
{
public:



    wxPropagateOnce(wxEvent& event, wxEvtHandler* handler = 
# 1148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                           __null
# 1148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                               )
        : m_event(event),
          m_propagatedFromOld(event.m_propagatedFrom)
    {
        do { if ( wxTheAssertHandler && !(m_event.m_propagationLevel > 0) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 1152 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        ,
 1153
# 1152 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        , __FUNCTION__, "m_event.m_propagationLevel > 0", L"shouldn't be used unless ShouldPropagate()!"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                            ;

        m_event.m_propagationLevel--;
        m_event.m_propagatedFrom = handler;
    }

    ~wxPropagateOnce()
    {
        m_event.m_propagatedFrom = m_propagatedFromOld;
        m_event.m_propagationLevel++;
    }

private:
    wxEvent& m_event;
    wxEvtHandler* const m_propagatedFromOld;

    private: wxPropagateOnce(const wxPropagateOnce&); wxPropagateOnce& operator=(const wxPropagateOnce&);
};



class wxEventProcessInHandlerOnly
{
public:
    wxEventProcessInHandlerOnly(wxEvent& event, wxEvtHandler *handler)
        : m_event(event),
          m_handlerToProcessOnlyInOld(event.m_handlerToProcessOnlyIn)
    {
        m_event.m_handlerToProcessOnlyIn = handler;
    }

    ~wxEventProcessInHandlerOnly()
    {
        m_event.m_handlerToProcessOnlyIn = m_handlerToProcessOnlyInOld;
    }

private:
    wxEvent& m_event;
    wxEvtHandler * const m_handlerToProcessOnlyInOld;

    private: wxEventProcessInHandlerOnly(const wxEventProcessInHandlerOnly&); wxEventProcessInHandlerOnly& operator=(const wxEventProcessInHandlerOnly&);
};


class wxEventBasicPayloadMixin
{
public:
    wxEventBasicPayloadMixin()
        : m_commandInt(0),
          m_extraLong(0)
    {
    }

    void SetString(const wxString& s) { m_cmdString = s; }
    const wxString& GetString() const { return m_cmdString; }

    void SetInt(int i) { m_commandInt = i; }
    int GetInt() const { return m_commandInt; }

    void SetExtraLong(long extraLong) { m_extraLong = extraLong; }
    long GetExtraLong() const { return m_extraLong; }

protected:


    wxString m_cmdString;
    int m_commandInt;
    long m_extraLong;

    private: wxEventBasicPayloadMixin& operator=(const wxEventBasicPayloadMixin&);
};

class wxEventAnyPayloadMixin : public wxEventBasicPayloadMixin
{
public:
    wxEventAnyPayloadMixin() : wxEventBasicPayloadMixin() {}


    template<typename T>
    void SetPayload(const T& payload)
    {
        m_payload = payload;
    }

    template<typename T>
    T GetPayload() const
    {
        return m_payload.As<T>();
    }

protected:
    wxAny m_payload;


    private: wxEventBasicPayloadMixin& operator=(const wxEventBasicPayloadMixin&);
};
# 1260 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum wxIdleMode
{

    wxIDLE_PROCESS_ALL,



    wxIDLE_PROCESS_SPECIFIED
};

class wxIdleEvent : public wxEvent
{
public:
    wxIdleEvent()
        : wxEvent(0, wxEVT_IDLE),
          m_requestMore(false)
        { }
    wxIdleEvent(const wxIdleEvent& event)
        : wxEvent(event),
          m_requestMore(event.m_requestMore)
    { }

    void RequestMore(bool needMore = true) { m_requestMore = needMore; }
    bool MoreRequested() const { return m_requestMore; }

    virtual wxEvent *Clone() const { return new wxIdleEvent(*this); }




    static void SetMode(wxIdleMode mode) { sm_idleMode = mode; }


    static wxIdleMode GetMode() { return sm_idleMode; }

protected:
    bool m_requestMore;
    static wxIdleMode sm_idleMode;

private:
    private: wxIdleEvent& operator=(const wxIdleEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxThreadEvent : public wxEvent,
                                       public wxEventAnyPayloadMixin
{
public:
    wxThreadEvent(wxEventType eventType = wxEVT_THREAD, int id = wxID_ANY)
        : wxEvent(id, eventType)
        { }

    wxThreadEvent(const wxThreadEvent& event)
        : wxEvent(event),
          wxEventAnyPayloadMixin(event)
    {


        SetString(GetString().Clone());
    }

    virtual wxEvent *Clone() const
    {
        return new wxThreadEvent(*this);
    }



    virtual wxEventCategory GetEventCategory() const
        { return wxEVT_CATEGORY_THREAD; }

private:
    private: wxThreadEvent& operator=(const wxThreadEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1347 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxAsyncMethodCallEvent : public wxEvent
{
public:
    wxAsyncMethodCallEvent(wxObject* object)
        : wxEvent(wxID_ANY, wxEVT_ASYNC_METHOD_CALL)
    {
        SetEventObject(object);
    }

    wxAsyncMethodCallEvent(const wxAsyncMethodCallEvent& other)
        : wxEvent(other)
    {
    }

    virtual void Execute() = 0;
};


template <typename T>
class wxAsyncMethodCallEvent0 : public wxAsyncMethodCallEvent
{
public:
    typedef T ObjectType;
    typedef void (ObjectType::*MethodType)();

    wxAsyncMethodCallEvent0(ObjectType* object,
                            MethodType method)
        : wxAsyncMethodCallEvent(object),
          m_object(object),
          m_method(method)
    {
    }

    wxAsyncMethodCallEvent0(const wxAsyncMethodCallEvent0& other)
        : wxAsyncMethodCallEvent(other),
          m_object(other.m_object),
          m_method(other.m_method)
    {
    }

    virtual wxEvent *Clone() const
    {
        return new wxAsyncMethodCallEvent0(*this);
    }

    virtual void Execute()
    {
        (m_object->*m_method)();
    }

private:
    ObjectType* const m_object;
    const MethodType m_method;
};


template <typename T, typename T1>
class wxAsyncMethodCallEvent1 : public wxAsyncMethodCallEvent
{
public:
    typedef T ObjectType;
    typedef void (ObjectType::*MethodType)(T1 x1);
    typedef typename wxRemoveRef<T1>::type ParamType1;

    wxAsyncMethodCallEvent1(ObjectType* object,
                            MethodType method,
                            const ParamType1& x1)
        : wxAsyncMethodCallEvent(object),
          m_object(object),
          m_method(method),
          m_param1(x1)
    {
    }

    wxAsyncMethodCallEvent1(const wxAsyncMethodCallEvent1& other)
        : wxAsyncMethodCallEvent(other),
          m_object(other.m_object),
          m_method(other.m_method),
          m_param1(other.m_param1)
    {
    }

    virtual wxEvent *Clone() const
    {
        return new wxAsyncMethodCallEvent1(*this);
    }

    virtual void Execute()
    {
        (m_object->*m_method)(m_param1);
    }

private:
    ObjectType* const m_object;
    const MethodType m_method;
    const ParamType1 m_param1;
};


template <typename T, typename T1, typename T2>
class wxAsyncMethodCallEvent2 : public wxAsyncMethodCallEvent
{
public:
    typedef T ObjectType;
    typedef void (ObjectType::*MethodType)(T1 x1, T2 x2);
    typedef typename wxRemoveRef<T1>::type ParamType1;
    typedef typename wxRemoveRef<T2>::type ParamType2;

    wxAsyncMethodCallEvent2(ObjectType* object,
                            MethodType method,
                            const ParamType1& x1,
                            const ParamType2& x2)
        : wxAsyncMethodCallEvent(object),
          m_object(object),
          m_method(method),
          m_param1(x1),
          m_param2(x2)
    {
    }

    wxAsyncMethodCallEvent2(const wxAsyncMethodCallEvent2& other)
        : wxAsyncMethodCallEvent(other),
          m_object(other.m_object),
          m_method(other.m_method),
          m_param1(other.m_param1),
          m_param2(other.m_param2)
    {
    }

    virtual wxEvent *Clone() const
    {
        return new wxAsyncMethodCallEvent2(*this);
    }

    virtual void Execute()
    {
        (m_object->*m_method)(m_param1, m_param2);
    }

private:
    ObjectType* const m_object;
    const MethodType m_method;
    const ParamType1 m_param1;
    const ParamType2 m_param2;
};


template <typename T>
class wxAsyncMethodCallEventFunctor : public wxAsyncMethodCallEvent
{
public:
    typedef T FunctorType;

    wxAsyncMethodCallEventFunctor(wxObject *object, const FunctorType& fn)
        : wxAsyncMethodCallEvent(object),
          m_fn(fn)
    {
    }

    wxAsyncMethodCallEventFunctor(const wxAsyncMethodCallEventFunctor& other)
        : wxAsyncMethodCallEvent(other),
          m_fn(other.m_fn)
    {
    }

    virtual wxEvent *Clone() const
    {
        return new wxAsyncMethodCallEventFunctor(*this);
    }

    virtual void Execute()
    {
        m_fn();
    }

private:
    FunctorType m_fn;
};
# 1551 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxCommandEvent : public wxEvent,
                                        public wxEventBasicPayloadMixin
{
public:
    wxCommandEvent(wxEventType commandType = wxEVT_NULL, int winid = 0);

    wxCommandEvent(const wxCommandEvent& event)
        : wxEvent(event),
          wxEventBasicPayloadMixin(event),
          m_clientData(event.m_clientData),
          m_clientObject(event.m_clientObject)
    {


        if ( m_cmdString.empty() )
            m_cmdString = event.GetString();
    }


    void SetClientData(void* clientData) { m_clientData = clientData; }
    void *GetClientData() const { return m_clientData; }


    void SetClientObject(wxClientData* clientObject) { m_clientObject = clientObject; }
    wxClientData *GetClientObject() const { return m_clientObject; }



    wxString GetString() const;


    int GetSelection() const { return m_commandInt; }


    bool IsChecked() const { return m_commandInt != 0; }


    bool IsSelection() const { return (m_extraLong != 0); }

    virtual wxEvent *Clone() const { return new wxCommandEvent(*this); }
    virtual wxEventCategory GetEventCategory() const { return wxEVT_CATEGORY_USER_INPUT; }

protected:
    void* m_clientData;
    wxClientData* m_clientObject;

private:
    private: wxCommandEvent& operator=(const wxCommandEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};



class wxNotifyEvent : public wxCommandEvent
{
public:
    wxNotifyEvent(wxEventType commandType = wxEVT_NULL, int winid = 0)
        : wxCommandEvent(commandType, winid)
        { m_bAllow = true; }

    wxNotifyEvent(const wxNotifyEvent& event)
        : wxCommandEvent(event)
        { m_bAllow = event.m_bAllow; }


    void Veto() { m_bAllow = false; }


    void Allow() { m_bAllow = true; }


    bool IsAllowed() const { return m_bAllow; }

    virtual wxEvent *Clone() const { return new wxNotifyEvent(*this); }

private:
    bool m_bAllow;

private:
    private: wxNotifyEvent& operator=(const wxNotifyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1647 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxScrollEvent : public wxCommandEvent
{
public:
    wxScrollEvent(wxEventType commandType = wxEVT_NULL,
                  int winid = 0, int pos = 0, int orient = 0);

    int GetOrientation() const { return (int) m_extraLong; }
    int GetPosition() const { return m_commandInt; }
    void SetOrientation(int orient) { m_extraLong = (long) orient; }
    void SetPosition(int pos) { m_commandInt = pos; }

    virtual wxEvent *Clone() const { return new wxScrollEvent(*this); }

private:
    private: wxScrollEvent& operator=(const wxScrollEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1677 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxScrollWinEvent : public wxEvent
{
public:
    wxScrollWinEvent(wxEventType commandType = wxEVT_NULL,
                     int pos = 0, int orient = 0);
    wxScrollWinEvent(const wxScrollWinEvent& event) : wxEvent(event)
        { m_commandInt = event.m_commandInt;
            m_extraLong = event.m_extraLong; }

    int GetOrientation() const { return (int) m_extraLong; }
    int GetPosition() const { return m_commandInt; }
    void SetOrientation(int orient) { m_extraLong = (long) orient; }
    void SetPosition(int pos) { m_commandInt = pos; }

    virtual wxEvent *Clone() const { return new wxScrollWinEvent(*this); }

protected:
    int m_commandInt;
    long m_extraLong;

private:
    private: wxScrollWinEvent& operator=(const wxScrollWinEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1720 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum wxMouseWheelAxis
{
    wxMOUSE_WHEEL_VERTICAL,
    wxMOUSE_WHEEL_HORIZONTAL
};

class wxMouseEvent : public wxEvent,
                                      public wxMouseState
{
public:
    wxMouseEvent(wxEventType mouseType = wxEVT_NULL);
    wxMouseEvent(const wxMouseEvent& event)
        : wxEvent(event),
          wxMouseState(event)
    {
        Assign(event);
    }


    bool IsButton() const { return Button(wxMOUSE_BTN_ANY); }


    bool ButtonDown(int but = wxMOUSE_BTN_ANY) const;


    bool ButtonDClick(int but = wxMOUSE_BTN_ANY) const;


    bool ButtonUp(int but = wxMOUSE_BTN_ANY) const;


    bool Button(int but) const;


    int GetButton() const;


    bool LeftDown() const { return (m_eventType == wxEVT_LEFT_DOWN); }
    bool MiddleDown() const { return (m_eventType == wxEVT_MIDDLE_DOWN); }
    bool RightDown() const { return (m_eventType == wxEVT_RIGHT_DOWN); }
    bool Aux1Down() const { return (m_eventType == wxEVT_AUX1_DOWN); }
    bool Aux2Down() const { return (m_eventType == wxEVT_AUX2_DOWN); }

    bool LeftUp() const { return (m_eventType == wxEVT_LEFT_UP); }
    bool MiddleUp() const { return (m_eventType == wxEVT_MIDDLE_UP); }
    bool RightUp() const { return (m_eventType == wxEVT_RIGHT_UP); }
    bool Aux1Up() const { return (m_eventType == wxEVT_AUX1_UP); }
    bool Aux2Up() const { return (m_eventType == wxEVT_AUX2_UP); }

    bool LeftDClick() const { return (m_eventType == wxEVT_LEFT_DCLICK); }
    bool MiddleDClick() const { return (m_eventType == wxEVT_MIDDLE_DCLICK); }
    bool RightDClick() const { return (m_eventType == wxEVT_RIGHT_DCLICK); }
    bool Aux1DClick() const { return (m_eventType == wxEVT_AUX1_DCLICK); }
    bool Aux2DClick() const { return (m_eventType == wxEVT_AUX2_DCLICK); }


    bool Dragging() const
    {
        return (m_eventType == wxEVT_MOTION) && ButtonIsDown(wxMOUSE_BTN_ANY);
    }


    bool Moving() const
    {
        return (m_eventType == wxEVT_MOTION) && !ButtonIsDown(wxMOUSE_BTN_ANY);
    }


    bool Entering() const { return (m_eventType == wxEVT_ENTER_WINDOW); }


    bool Leaving() const { return (m_eventType == wxEVT_LEAVE_WINDOW); }


    int GetClickCount() const { return m_clickCount; }


    wxPoint GetLogicalPosition(const wxDC& dc) const;
# 1806 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    int GetWheelRotation() const { return m_wheelRotation; }




    int GetWheelDelta() const { return m_wheelDelta; }




    wxMouseWheelAxis GetWheelAxis() const { return m_wheelAxis; }



    int GetLinesPerAction() const { return m_linesPerAction; }



    int GetColumnsPerAction() const { return m_columnsPerAction; }


    bool IsPageScroll() const { return ((unsigned int)m_linesPerAction == 
# 1827 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                                         (0x7fffffff * 2U + 1U)
# 1827 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                                 ); }

    virtual wxEvent *Clone() const { return new wxMouseEvent(*this); }
    virtual wxEventCategory GetEventCategory() const { return wxEVT_CATEGORY_USER_INPUT; }

    wxMouseEvent& operator=(const wxMouseEvent& event)
    {
        if (&event != this)
            Assign(event);
        return *this;
    }

public:
    int m_clickCount;

    wxMouseWheelAxis m_wheelAxis;
    int m_wheelRotation;
    int m_wheelDelta;
    int m_linesPerAction;
    int m_columnsPerAction;

protected:
    void Assign(const wxMouseEvent& evt);

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxSetCursorEvent : public wxEvent
{
public:
    wxSetCursorEvent(wxCoord x = 0, wxCoord y = 0)
        : wxEvent(0, wxEVT_SET_CURSOR),
          m_x(x), m_y(y), m_cursor()
        { }

    wxSetCursorEvent(const wxSetCursorEvent& event)
        : wxEvent(event),
          m_x(event.m_x),
          m_y(event.m_y),
          m_cursor(event.m_cursor)
        { }

    wxCoord GetX() const { return m_x; }
    wxCoord GetY() const { return m_y; }

    void SetCursor(const wxCursor& cursor) { m_cursor = cursor; }
    const wxCursor& GetCursor() const { return m_cursor; }
    bool HasCursor() const { return m_cursor.IsOk(); }

    virtual wxEvent *Clone() const { return new wxSetCursorEvent(*this); }

private:
    wxCoord m_x, m_y;
    wxCursor m_cursor;

private:
    private: wxSetCursorEvent& operator=(const wxSetCursorEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 1907 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum wxKeyCategoryFlags
{

    WXK_CATEGORY_ARROW = 1,


    WXK_CATEGORY_PAGING = 2,


    WXK_CATEGORY_JUMP = 4,


    WXK_CATEGORY_TAB = 8,


    WXK_CATEGORY_CUT = 16,


    WXK_CATEGORY_NAVIGATION = WXK_CATEGORY_ARROW |
                              WXK_CATEGORY_PAGING |
                              WXK_CATEGORY_JUMP
};

class wxKeyEvent : public wxEvent,
                                    public wxKeyboardState
{
public:
    wxKeyEvent(wxEventType keyType = wxEVT_NULL);




    wxKeyEvent(const wxKeyEvent& evt);
    wxKeyEvent(wxEventType eventType, const wxKeyEvent& evt);


    int GetKeyCode() const { return (int)m_keyCode; }


    bool IsKeyInCategory(int category) const;



    wxChar GetUnicodeKey() const { return m_uniChar; }



    wxUint32 GetRawKeyCode() const { return m_rawCode; }


    wxUint32 GetRawKeyFlags() const { return m_rawFlags; }


    void GetPosition(wxCoord *xpos, wxCoord *ypos) const
    {
        if (xpos)
            *xpos = GetX();
        if (ypos)
            *ypos = GetY();
    }


    void GetPosition(long *xpos, long *ypos) const
    {
        if (xpos)
            *xpos = GetX();
        if (ypos)
            *ypos = GetY();
    }

    wxPoint GetPosition() const
        { return wxPoint(GetX(), GetY()); }


    wxCoord GetX() const;


    wxCoord GetY() const;




    void DoAllowNextEvent() { m_allowNext = true; }


    bool IsNextEventAllowed() const { return m_allowNext; }


    virtual wxEvent *Clone() const { return new wxKeyEvent(*this); }
    virtual wxEventCategory GetEventCategory() const { return wxEVT_CATEGORY_USER_INPUT; }



    wxKeyEvent& operator=(const wxKeyEvent& evt)
    {
        if ( &evt != this )
        {
            wxEvent::operator=(evt);



            *static_cast<wxKeyboardState *>(this) = evt;

            DoAssignMembers(evt);
        }
        return *this;
    }

public:


    wxCoord m_x, m_y;

    long m_keyCode;




    wxChar m_uniChar;




    wxUint32 m_rawCode;
    wxUint32 m_rawFlags;

private:


    void InitPropagation()
    {
        if ( m_eventType == wxEVT_CHAR_HOOK )
            m_propagationLevel = wxEVENT_PROPAGATE_MAX;

        m_allowNext = false;
    }



    void DoAssignMembers(const wxKeyEvent& evt)
    {
        m_x = evt.m_x;
        m_y = evt.m_y;
        m_hasPosition = evt.m_hasPosition;

        m_keyCode = evt.m_keyCode;

        m_rawCode = evt.m_rawCode;
        m_rawFlags = evt.m_rawFlags;

        m_uniChar = evt.m_uniChar;

    }



    void InitPositionIfNecessary() const;




    bool m_allowNext;



    bool m_hasPosition;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxSizeEvent : public wxEvent
{
public:
    wxSizeEvent() : wxEvent(0, wxEVT_SIZE)
        { }
    wxSizeEvent(const wxSize& sz, int winid = 0)
        : wxEvent(winid, wxEVT_SIZE),
          m_size(sz)
        { }
    wxSizeEvent(const wxSizeEvent& event)
        : wxEvent(event),
          m_size(event.m_size), m_rect(event.m_rect)
        { }
    wxSizeEvent(const wxRect& rect, int id = 0)
        : m_size(rect.GetSize()), m_rect(rect)
        { m_eventType = wxEVT_SIZING; m_id = id; }

    wxSize GetSize() const { return m_size; }
    void SetSize(wxSize size) { m_size = size; }
    wxRect GetRect() const { return m_rect; }
    void SetRect(const wxRect& rect) { m_rect = rect; }

    virtual wxEvent *Clone() const { return new wxSizeEvent(*this); }

public:

    wxSize m_size;
    wxRect m_rect;

private:
    private: wxSizeEvent& operator=(const wxSizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxMoveEvent : public wxEvent
{
public:
    wxMoveEvent()
        : wxEvent(0, wxEVT_MOVE)
        { }
    wxMoveEvent(const wxPoint& pos, int winid = 0)
        : wxEvent(winid, wxEVT_MOVE),
          m_pos(pos)
        { }
    wxMoveEvent(const wxMoveEvent& event)
        : wxEvent(event),
          m_pos(event.m_pos)
    { }
    wxMoveEvent(const wxRect& rect, int id = 0)
        : m_pos(rect.GetPosition()), m_rect(rect)
        { m_eventType = wxEVT_MOVING; m_id = id; }

    wxPoint GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }
    wxRect GetRect() const { return m_rect; }
    void SetRect(const wxRect& rect) { m_rect = rect; }

    virtual wxEvent *Clone() const { return new wxMoveEvent(*this); }

protected:
    wxPoint m_pos;
    wxRect m_rect;

private:
    private: wxMoveEvent& operator=(const wxMoveEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2164 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    extern int g_isPainting;


class wxPaintEvent : public wxEvent
{
public:
    wxPaintEvent(int Id = 0)
        : wxEvent(Id, wxEVT_PAINT)
    {


        g_isPainting++;

    }




    wxPaintEvent(const wxPaintEvent& event)
            : wxEvent(event)
    {
        g_isPainting++;
    }

    virtual ~wxPaintEvent()
    {
        g_isPainting--;
    }


    virtual wxEvent *Clone() const { return new wxPaintEvent(*this); }

private:
    private: wxPaintEvent& operator=(const wxPaintEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxNcPaintEvent : public wxEvent
{
public:
    wxNcPaintEvent(int winid = 0)
        : wxEvent(winid, wxEVT_NC_PAINT)
        { }

    virtual wxEvent *Clone() const { return new wxNcPaintEvent(*this); }

private:
    private: wxNcPaintEvent& operator=(const wxNcPaintEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxEraseEvent : public wxEvent
{
public:
    wxEraseEvent(int Id = 0, wxDC *dc = 
# 2221 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                       __null
# 2221 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                           )
        : wxEvent(Id, wxEVT_ERASE_BACKGROUND),
          m_dc(dc)
        { }

    wxEraseEvent(const wxEraseEvent& event)
        : wxEvent(event),
          m_dc(event.m_dc)
        { }

    wxDC *GetDC() const { return m_dc; }

    virtual wxEvent *Clone() const { return new wxEraseEvent(*this); }

protected:
    wxDC *m_dc;

private:
    private: wxEraseEvent& operator=(const wxEraseEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxFocusEvent : public wxEvent
{
public:
    wxFocusEvent(wxEventType type = wxEVT_NULL, int winid = 0)
        : wxEvent(winid, type)
        { m_win = 
# 2253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                 __null
# 2253 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                     ; }

    wxFocusEvent(const wxFocusEvent& event)
        : wxEvent(event)
        { m_win = event.m_win; }




    wxWindow *GetWindow() const { return m_win; }
    void SetWindow(wxWindow *win) { m_win = win; }

    virtual wxEvent *Clone() const { return new wxFocusEvent(*this); }

private:
    wxWindow *m_win;

private:
    private: wxFocusEvent& operator=(const wxFocusEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};



class wxChildFocusEvent : public wxCommandEvent
{
public:
    wxChildFocusEvent(wxWindow *win = 
# 2279 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                     __null
# 2279 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                         );

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxChildFocusEvent(*this); }

private:
    private: wxChildFocusEvent& operator=(const wxChildFocusEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2296 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxActivateEvent : public wxEvent
{
public:


    enum Reason
    {
        Reason_Mouse,
        Reason_Unknown
    };

    wxActivateEvent(wxEventType type = wxEVT_NULL, bool active = true,
                    int Id = 0, Reason activationReason = Reason_Unknown)
        : wxEvent(Id, type),
        m_activationReason(activationReason)
    {
        m_active = active;
    }
    wxActivateEvent(const wxActivateEvent& event)
        : wxEvent(event)
    {
        m_active = event.m_active;
        m_activationReason = event.m_activationReason;
    }

    bool GetActive() const { return m_active; }
    Reason GetActivationReason() const { return m_activationReason;}

    virtual wxEvent *Clone() const { return new wxActivateEvent(*this); }

private:
    bool m_active;
    Reason m_activationReason;

private:
    private: wxActivateEvent& operator=(const wxActivateEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxInitDialogEvent : public wxEvent
{
public:
    wxInitDialogEvent(int Id = 0)
        : wxEvent(Id, wxEVT_INIT_DIALOG)
        { }

    virtual wxEvent *Clone() const { return new wxInitDialogEvent(*this); }

private:
    private: wxInitDialogEvent& operator=(const wxInitDialogEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2359 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxMenuEvent : public wxEvent
{
public:
    wxMenuEvent(wxEventType type = wxEVT_NULL, int winid = 0, wxMenu* menu = 
# 2362 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                                            __null
# 2362 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                                )
        : wxEvent(winid, type)
        { m_menuId = winid; m_menu = menu; }
    wxMenuEvent(const wxMenuEvent& event)
        : wxEvent(event)
    { m_menuId = event.m_menuId; m_menu = event.m_menu; }


    int GetMenuId() const { return m_menuId; }


    bool IsPopup() const { return m_menuId == wxID_ANY; }


    wxMenu* GetMenu() const { return m_menu; }

    virtual wxEvent *Clone() const { return new wxMenuEvent(*this); }

private:
    int m_menuId;
    wxMenu* m_menu;

    private: wxMenuEvent& operator=(const wxMenuEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2394 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxCloseEvent : public wxEvent
{
public:
    wxCloseEvent(wxEventType type = wxEVT_NULL, int winid = 0)
        : wxEvent(winid, type),
          m_loggingOff(true),
          m_veto(false),
          m_canVeto(true) {}

    wxCloseEvent(const wxCloseEvent& event)
        : wxEvent(event),
        m_loggingOff(event.m_loggingOff),
        m_veto(event.m_veto),
        m_canVeto(event.m_canVeto) {}

    void SetLoggingOff(bool logOff) { m_loggingOff = logOff; }
    bool GetLoggingOff() const
    {


        do { if ( wxTheAssertHandler && !(m_eventType != wxEVT_CLOSE_WINDOW) && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 2414 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        ,
 2415
# 2414 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        , __FUNCTION__, "m_eventType != wxEVT_CLOSE_WINDOW", L"this flag is for end session events only"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                       ;

        return m_loggingOff;
    }

    void Veto(bool veto = true)
    {

        if ( m_canVeto ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert(
 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 2423 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        ,
 2424
# 2423 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        , __FUNCTION__, "m_canVeto", L"call to Veto() ignored (can't veto this event)"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct
                                                                            ;

        m_veto = veto;
    }
    void SetCanVeto(bool canVeto) { m_canVeto = canVeto; }
    bool CanVeto() const { return m_canVeto; }
    bool GetVeto() const { return m_canVeto && m_veto; }

    virtual wxEvent *Clone() const { return new wxCloseEvent(*this); }

protected:
    bool m_loggingOff,
         m_veto,
         m_canVeto;

private:
    private: wxCloseEvent& operator=(const wxCloseEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxShowEvent : public wxEvent
{
public:
    wxShowEvent(int winid = 0, bool show = false)
        : wxEvent(winid, wxEVT_SHOW)
        { m_show = show; }
    wxShowEvent(const wxShowEvent& event)
        : wxEvent(event)
    { m_show = event.m_show; }

    void SetShow(bool show) { m_show = show; }


    bool IsShown() const { return m_show; }


    __attribute__((deprecated)) bool GetShow() const { return IsShown(); }


    virtual wxEvent *Clone() const { return new wxShowEvent(*this); }

protected:
    bool m_show;

private:
    private: wxShowEvent& operator=(const wxShowEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};





class wxIconizeEvent : public wxEvent
{
public:
    wxIconizeEvent(int winid = 0, bool iconized = true)
        : wxEvent(winid, wxEVT_ICONIZE)
        { m_iconized = iconized; }
    wxIconizeEvent(const wxIconizeEvent& event)
        : wxEvent(event)
    { m_iconized = event.m_iconized; }


    __attribute__((deprecated)) bool Iconized() const { return IsIconized(); }


    bool IsIconized() const { return m_iconized; }

    virtual wxEvent *Clone() const { return new wxIconizeEvent(*this); }

protected:
    bool m_iconized;

private:
    private: wxIconizeEvent& operator=(const wxIconizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxMaximizeEvent : public wxEvent
{
public:
    wxMaximizeEvent(int winid = 0)
        : wxEvent(winid, wxEVT_MAXIMIZE)
        { }

    virtual wxEvent *Clone() const { return new wxMaximizeEvent(*this); }

private:
    private: wxMaximizeEvent& operator=(const wxMaximizeEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2529 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum
{
    wxJOYSTICK1,
    wxJOYSTICK2
};


enum
{
    wxJOY_BUTTON_ANY = -1,
    wxJOY_BUTTON1 = 1,
    wxJOY_BUTTON2 = 2,
    wxJOY_BUTTON3 = 4,
    wxJOY_BUTTON4 = 8
};

class wxJoystickEvent : public wxEvent
{
protected:
    wxPoint m_pos;
    int m_zPosition;
    int m_buttonChange;
    int m_buttonState;
    int m_joyStick;

public:
    wxJoystickEvent(wxEventType type = wxEVT_NULL,
                    int state = 0,
                    int joystick = wxJOYSTICK1,
                    int change = 0)
        : wxEvent(0, type),
          m_pos(),
          m_zPosition(0),
          m_buttonChange(change),
          m_buttonState(state),
          m_joyStick(joystick)
    {
    }
    wxJoystickEvent(const wxJoystickEvent& event)
        : wxEvent(event),
          m_pos(event.m_pos),
          m_zPosition(event.m_zPosition),
          m_buttonChange(event.m_buttonChange),
          m_buttonState(event.m_buttonState),
          m_joyStick(event.m_joyStick)
    { }

    wxPoint GetPosition() const { return m_pos; }
    int GetZPosition() const { return m_zPosition; }
    int GetButtonState() const { return m_buttonState; }
    int GetButtonChange() const { return m_buttonChange; }
    int GetJoystick() const { return m_joyStick; }

    void SetJoystick(int stick) { m_joyStick = stick; }
    void SetButtonState(int state) { m_buttonState = state; }
    void SetButtonChange(int change) { m_buttonChange = change; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }
    void SetZPosition(int zPos) { m_zPosition = zPos; }


    bool IsButton() const { return ((GetEventType() == wxEVT_JOY_BUTTON_DOWN) ||
            (GetEventType() == wxEVT_JOY_BUTTON_UP)); }


    bool IsMove() const { return (GetEventType() == wxEVT_JOY_MOVE); }


    bool IsZMove() const { return (GetEventType() == wxEVT_JOY_ZMOVE); }


    bool ButtonDown(int but = wxJOY_BUTTON_ANY) const
    { return ((GetEventType() == wxEVT_JOY_BUTTON_DOWN) &&
            ((but == wxJOY_BUTTON_ANY) || (but == m_buttonChange))); }


    bool ButtonUp(int but = wxJOY_BUTTON_ANY) const
    { return ((GetEventType() == wxEVT_JOY_BUTTON_UP) &&
            ((but == wxJOY_BUTTON_ANY) || (but == m_buttonChange))); }


    bool ButtonIsDown(int but = wxJOY_BUTTON_ANY) const
    { return (((but == wxJOY_BUTTON_ANY) && (m_buttonState != 0)) ||
            ((m_buttonState & but) == but)); }

    virtual wxEvent *Clone() const { return new wxJoystickEvent(*this); }

private:
    private: wxJoystickEvent& operator=(const wxJoystickEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxDropFilesEvent : public wxEvent
{
public:
    int m_noFiles;
    wxPoint m_pos;
    wxString* m_files;

    wxDropFilesEvent(wxEventType type = wxEVT_NULL,
                     int noFiles = 0,
                     wxString *files = 
# 2633 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                      __null
# 2633 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                          )
        : wxEvent(0, type),
          m_noFiles(noFiles),
          m_pos(),
          m_files(files)
        { }


    wxDropFilesEvent(const wxDropFilesEvent& other)
        : wxEvent(other),
          m_noFiles(other.m_noFiles),
          m_pos(other.m_pos),
          m_files(
# 2645 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                 __null
# 2645 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                     )
    {
        m_files = new wxString[m_noFiles];
        for ( int n = 0; n < m_noFiles; n++ )
        {
            m_files[n] = other.m_files[n];
        }
    }

    virtual ~wxDropFilesEvent()
    {
        delete [] m_files;
    }

    wxPoint GetPosition() const { return m_pos; }
    int GetNumberOfFiles() const { return m_noFiles; }
    wxString *GetFiles() const { return m_files; }

    virtual wxEvent *Clone() const { return new wxDropFilesEvent(*this); }

private:
    private: wxDropFilesEvent& operator=(const wxDropFilesEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2678 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
enum wxUpdateUIMode
{

    wxUPDATE_UI_PROCESS_ALL,



    wxUPDATE_UI_PROCESS_SPECIFIED
};

class wxUpdateUIEvent : public wxCommandEvent
{
public:
    wxUpdateUIEvent(wxWindowID commandId = 0)
        : wxCommandEvent(wxEVT_UPDATE_UI, commandId)
    {
        m_checked =
        m_enabled =
        m_shown =
        m_setEnabled =
        m_setShown =
        m_setText =
        m_setChecked = false;
    }
    wxUpdateUIEvent(const wxUpdateUIEvent& event)
        : wxCommandEvent(event),
          m_checked(event.m_checked),
          m_enabled(event.m_enabled),
          m_shown(event.m_shown),
          m_setEnabled(event.m_setEnabled),
          m_setShown(event.m_setShown),
          m_setText(event.m_setText),
          m_setChecked(event.m_setChecked),
          m_text(event.m_text)
    { }

    bool GetChecked() const { return m_checked; }
    bool GetEnabled() const { return m_enabled; }
    bool GetShown() const { return m_shown; }
    wxString GetText() const { return m_text; }
    bool GetSetText() const { return m_setText; }
    bool GetSetChecked() const { return m_setChecked; }
    bool GetSetEnabled() const { return m_setEnabled; }
    bool GetSetShown() const { return m_setShown; }

    void Check(bool check) { m_checked = check; m_setChecked = true; }
    void Enable(bool enable) { m_enabled = enable; m_setEnabled = true; }
    void Show(bool show) { m_shown = show; m_setShown = true; }
    void SetText(const wxString& text) { m_text = text; m_setText = true; }



    static void SetUpdateInterval(long updateInterval) { sm_updateInterval = updateInterval; }


    static long GetUpdateInterval() { return sm_updateInterval; }


    static bool CanUpdate(wxWindowBase *win);



    static void ResetUpdateTime();




    static void SetMode(wxUpdateUIMode mode) { sm_updateMode = mode; }


    static wxUpdateUIMode GetMode() { return sm_updateMode; }

    virtual wxEvent *Clone() const { return new wxUpdateUIEvent(*this); }

protected:
    bool m_checked;
    bool m_enabled;
    bool m_shown;
    bool m_setEnabled;
    bool m_setShown;
    bool m_setText;
    bool m_setChecked;
    wxString m_text;

    static wxLongLong sm_lastUpdate;

    static long sm_updateInterval;
    static wxUpdateUIMode sm_updateMode;

private:
    private: wxUpdateUIEvent& operator=(const wxUpdateUIEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxSysColourChangedEvent : public wxEvent
{
public:
    wxSysColourChangedEvent()
        : wxEvent(0, wxEVT_SYS_COLOUR_CHANGED)
        { }

    virtual wxEvent *Clone() const { return new wxSysColourChangedEvent(*this); }

private:
    private: wxSysColourChangedEvent& operator=(const wxSysColourChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxMouseCaptureChangedEvent : public wxEvent
{
public:
    wxMouseCaptureChangedEvent(wxWindowID winid = 0, wxWindow* gainedCapture = 
# 2798 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                                              __null
# 2798 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                                                  )
        : wxEvent(winid, wxEVT_MOUSE_CAPTURE_CHANGED),
          m_gainedCapture(gainedCapture)
        { }

    wxMouseCaptureChangedEvent(const wxMouseCaptureChangedEvent& event)
        : wxEvent(event),
          m_gainedCapture(event.m_gainedCapture)
        { }

    virtual wxEvent *Clone() const { return new wxMouseCaptureChangedEvent(*this); }

    wxWindow* GetCapturedWindow() const { return m_gainedCapture; }

private:
    wxWindow* m_gainedCapture;

    private: wxMouseCaptureChangedEvent& operator=(const wxMouseCaptureChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2825 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxMouseCaptureLostEvent : public wxEvent
{
public:
    wxMouseCaptureLostEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_MOUSE_CAPTURE_LOST)
    {}

    wxMouseCaptureLostEvent(const wxMouseCaptureLostEvent& event)
        : wxEvent(event)
    {}

    virtual wxEvent *Clone() const { return new wxMouseCaptureLostEvent(*this); }

    private: wxMouseCaptureLostEvent& operator=(const wxMouseCaptureLostEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};




class wxDisplayChangedEvent : public wxEvent
{
private:
    private: wxDisplayChangedEvent& operator=(const wxDisplayChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:
    wxDisplayChangedEvent()
        : wxEvent(0, wxEVT_DISPLAY_CHANGED)
        { }

    virtual wxEvent *Clone() const { return new wxDisplayChangedEvent(*this); }
};





class wxPaletteChangedEvent : public wxEvent
{
public:
    wxPaletteChangedEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_PALETTE_CHANGED),
          m_changedWindow(
# 2866 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                         __null
# 2866 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                             )
        { }

    wxPaletteChangedEvent(const wxPaletteChangedEvent& event)
        : wxEvent(event),
          m_changedWindow(event.m_changedWindow)
        { }

    void SetChangedWindow(wxWindow* win) { m_changedWindow = win; }
    wxWindow* GetChangedWindow() const { return m_changedWindow; }

    virtual wxEvent *Clone() const { return new wxPaletteChangedEvent(*this); }

protected:
    wxWindow* m_changedWindow;

private:
    private: wxPaletteChangedEvent& operator=(const wxPaletteChangedEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxQueryNewPaletteEvent : public wxEvent
{
public:
    wxQueryNewPaletteEvent(wxWindowID winid = 0)
        : wxEvent(winid, wxEVT_QUERY_NEW_PALETTE),
          m_paletteRealized(false)
        { }
    wxQueryNewPaletteEvent(const wxQueryNewPaletteEvent& event)
        : wxEvent(event),
        m_paletteRealized(event.m_paletteRealized)
    { }


    void SetPaletteRealized(bool realized) { m_paletteRealized = realized; }
    bool GetPaletteRealized() const { return m_paletteRealized; }

    virtual wxEvent *Clone() const { return new wxQueryNewPaletteEvent(*this); }

protected:
    bool m_paletteRealized;

private:
    private: wxQueryNewPaletteEvent& operator=(const wxQueryNewPaletteEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};






class wxNavigationKeyEvent : public wxEvent
{
public:
    wxNavigationKeyEvent()
        : wxEvent(0, wxEVT_NAVIGATION_KEY),
          m_flags(IsForward | FromTab),
          m_focus(
# 2927 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                 __null
# 2927 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                     )
        {
            m_propagationLevel = wxEVENT_PROPAGATE_NONE;
        }

    wxNavigationKeyEvent(const wxNavigationKeyEvent& event)
        : wxEvent(event),
          m_flags(event.m_flags),
          m_focus(event.m_focus)
        { }


    bool GetDirection() const
        { return (m_flags & IsForward) != 0; }
    void SetDirection(bool bForward)
        { if ( bForward ) m_flags |= IsForward; else m_flags &= ~IsForward; }



    bool IsWindowChange() const
        { return (m_flags & WinChange) != 0; }
    void SetWindowChange(bool bIs)
        { if ( bIs ) m_flags |= WinChange; else m_flags &= ~WinChange; }



    bool IsFromTab() const
        { return (m_flags & FromTab) != 0; }
    void SetFromTab(bool bIs)
        { if ( bIs ) m_flags |= FromTab; else m_flags &= ~FromTab; }



    wxWindow* GetCurrentFocus() const { return m_focus; }
    void SetCurrentFocus(wxWindow *win) { m_focus = win; }


    void SetFlags(long flags) { m_flags = flags; }

    virtual wxEvent *Clone() const { return new wxNavigationKeyEvent(*this); }

    enum wxNavigationKeyEventFlags
    {
        IsBackward = 0x0000,
        IsForward = 0x0001,
        WinChange = 0x0002,
        FromTab = 0x0004
    };

    long m_flags;
    wxWindow *m_focus;

private:
    private: wxNavigationKeyEvent& operator=(const wxNavigationKeyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 2993 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxWindowCreateEvent : public wxCommandEvent
{
public:
    wxWindowCreateEvent(wxWindow *win = 
# 2996 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                       __null
# 2996 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                           );

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxWindowCreateEvent(*this); }

private:
    private: wxWindowCreateEvent& operator=(const wxWindowCreateEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxWindowDestroyEvent : public wxCommandEvent
{
public:
    wxWindowDestroyEvent(wxWindow *win = 
# 3009 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                        __null
# 3009 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                            );

    wxWindow *GetWindow() const { return (wxWindow *)GetEventObject(); }

    virtual wxEvent *Clone() const { return new wxWindowDestroyEvent(*this); }

private:
    private: wxWindowDestroyEvent& operator=(const wxWindowDestroyEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};







class wxHelpEvent : public wxCommandEvent
{
public:

    enum Origin
    {
        Origin_Unknown,
        Origin_Keyboard,
        Origin_HelpButton
    };

    wxHelpEvent(wxEventType type = wxEVT_NULL,
                wxWindowID winid = 0,
                const wxPoint& pt = wxDefaultPosition,
                Origin origin = Origin_Unknown)
        : wxCommandEvent(type, winid),
          m_pos(pt),
          m_origin(GuessOrigin(origin))
    { }
    wxHelpEvent(const wxHelpEvent& event)
        : wxCommandEvent(event),
          m_pos(event.m_pos),
          m_target(event.m_target),
          m_link(event.m_link),
          m_origin(event.m_origin)
    { }


    const wxPoint& GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }


    const wxString& GetLink() const { return m_link; }
    void SetLink(const wxString& link) { m_link = link; }


    const wxString& GetTarget() const { return m_target; }
    void SetTarget(const wxString& target) { m_target = target; }

    virtual wxEvent *Clone() const { return new wxHelpEvent(*this); }


    Origin GetOrigin() const { return m_origin; }
    void SetOrigin(Origin origin) { m_origin = origin; }

protected:
    wxPoint m_pos;
    wxString m_target;
    wxString m_link;
    Origin m_origin;



    static Origin GuessOrigin(Origin origin);

private:
    private: wxHelpEvent& operator=(const wxHelpEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 3095 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxClipboardTextEvent : public wxCommandEvent
{
public:
    wxClipboardTextEvent(wxEventType type = wxEVT_NULL,
                     wxWindowID winid = 0)
        : wxCommandEvent(type, winid)
    { }
    wxClipboardTextEvent(const wxClipboardTextEvent& event)
        : wxCommandEvent(event)
    { }

    virtual wxEvent *Clone() const { return new wxClipboardTextEvent(*this); }

private:
    private: wxClipboardTextEvent& operator=(const wxClipboardTextEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 3120 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxContextMenuEvent : public wxCommandEvent
{
public:
    wxContextMenuEvent(wxEventType type = wxEVT_NULL,
                       wxWindowID winid = 0,
                       const wxPoint& pt = wxDefaultPosition)
        : wxCommandEvent(type, winid),
          m_pos(pt)
    { }
    wxContextMenuEvent(const wxContextMenuEvent& event)
        : wxCommandEvent(event),
        m_pos(event.m_pos)
    { }


    const wxPoint& GetPosition() const { return m_pos; }
    void SetPosition(const wxPoint& pos) { m_pos = pos; }

    virtual wxEvent *Clone() const { return new wxContextMenuEvent(*this); }

protected:
    wxPoint m_pos;

private:
    private: wxContextMenuEvent& operator=(const wxContextMenuEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 3168 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
struct wxEventTableEntryBase
{
    wxEventTableEntryBase(int winid, int idLast,
                          wxEventFunctor* fn, wxObject *data)
        : m_id(winid),
          m_lastId(idLast),
          m_fn(fn),
          m_callbackUserData(data)
    {
        do { if ( wxTheAssertHandler && !(idLast == wxID_ANY || winid <= idLast) && (wxOnAssert(
                                                                     "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
# 3177 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        ,
                                                                     3178
# 3177 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
        , __FUNCTION__, "idLast == wxID_ANY || winid <= idLast", "invalid IDs range: lower bound > upper bound"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 )
                                                                      ;
    }

    wxEventTableEntryBase( const wxEventTableEntryBase &entry )
        : m_id( entry.m_id ),
          m_lastId( entry.m_lastId ),
          m_fn( entry.m_fn ),
          m_callbackUserData( entry.m_callbackUserData )
    {






        const_cast<wxEventTableEntryBase&>( entry ).m_fn = 
# 3193 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                          __null
# 3193 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                              ;
    }

    ~wxEventTableEntryBase()
    {
        delete m_fn;
    }



    int m_id,
        m_lastId;


    wxEventFunctor* m_fn;


    wxObject* m_callbackUserData;

private:
    private: wxEventTableEntryBase& operator=(const wxEventTableEntryBase&);
};


struct wxEventTableEntry : public wxEventTableEntryBase
{
    wxEventTableEntry(const int& evType, int winid, int idLast,
                      wxEventFunctor* fn, wxObject *data)
        : wxEventTableEntryBase(winid, idLast, fn, data),
        m_eventType(evType)
    { }







    const int& m_eventType;

private:
    private: wxEventTableEntry& operator=(const wxEventTableEntry&);
};


struct wxDynamicEventTableEntry : public wxEventTableEntryBase
{
    wxDynamicEventTableEntry(int evType, int winid, int idLast,
                             wxEventFunctor* fn, wxObject *data)
        : wxEventTableEntryBase(winid, idLast, fn, data),
          m_eventType(evType)
    { }




    int m_eventType;

private:
    private: wxDynamicEventTableEntry& operator=(const wxDynamicEventTableEntry&);
};





struct wxEventTable
{
    const wxEventTable *baseTable;
    const wxEventTableEntry *entries;
};





typedef const wxEventTableEntry* _wxArraywxEventTableEntryPointerArray; struct wxAssert_wxEventTableEntryPointerArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxEventTableEntryPointerArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxEventTableEntryPointerArray)(_wxArraywxEventTableEntryPointerArray *pItem1, _wxArraywxEventTableEntryPointerArray *pItem2); class wxEventTableEntryPointerArray : public wxBaseArrayPtrVoid { public: wxEventTableEntryPointerArray() { } ~wxEventTableEntryPointerArray() { } _wxArraywxEventTableEntryPointerArray& operator[](size_t uiIndex) const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEventTableEntryPointerArray& Item(size_t uiIndex) const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEventTableEntryPointerArray& Last() const { return (_wxArraywxEventTableEntryPointerArray&)(wxBaseArrayPtrVoid::operator[](GetCount() - 1)); } int Index(_wxArraywxEventTableEntryPointerArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxEventTableEntryPointerArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxEventTableEntryPointerArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxEventTableEntryPointerArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h", 3269, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxEventTableEntryPointerArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxEventTableEntryPointerArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxEventTableEntryPointerArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 3269 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
__null
# 3269 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxEventTableEntryPointerArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 3269 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
__null
# 3269 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxEventTableEntryPointerArray(size_type n) { assign(n, value_type()); } wxEventTableEntryPointerArray(size_type n, const_reference v) { assign(n, v); } wxEventTableEntryPointerArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } void swap(wxEventTableEntryPointerArray& other) { wxBaseArrayPtrVoid::swap(other); } };

class wxEventHashTable
{
private:

    struct EventTypeTable
    {
        wxEventType eventType;
        wxEventTableEntryPointerArray eventEntryTable;
    };
    typedef EventTypeTable* EventTypeTablePointer;

public:




    wxEventHashTable(const wxEventTable &table);

    ~wxEventHashTable();



    bool HandleEvent(wxEvent& event, wxEvtHandler *self);


    void Clear();







protected:

    void InitHashTable();

    void AddEntry(const wxEventTableEntry &entry);

    void AllocEventTypeTable(size_t size);


    void GrowEventTypeTable();

protected:
    const wxEventTable &m_table;
    bool m_rebuildHash;

    size_t m_size;
    EventTypeTablePointer *m_eventTypeTable;

    static wxEventHashTable* sm_first;
    wxEventHashTable* m_previous;
    wxEventHashTable* m_next;

    private: wxEventHashTable(const wxEventHashTable&); wxEventHashTable& operator=(const wxEventHashTable&);
};





class wxEvtHandler : public wxObject
                                    , public wxTrackable
{
public:
    wxEvtHandler();
    virtual ~wxEvtHandler();





    wxEvtHandler *GetNextHandler() const { return m_nextHandler; }
    wxEvtHandler *GetPreviousHandler() const { return m_previousHandler; }
    virtual void SetNextHandler(wxEvtHandler *handler) { m_nextHandler = handler; }
    virtual void SetPreviousHandler(wxEvtHandler *handler) { m_previousHandler = handler; }

    void SetEvtHandlerEnabled(bool enabled) { m_enabled = enabled; }
    bool GetEvtHandlerEnabled() const { return m_enabled; }

    void Unlink();
    bool IsUnlinked() const;
# 3364 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    static void AddFilter(wxEventFilter* filter);


    static void RemoveFilter(wxEventFilter* filter);
# 3376 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    virtual bool ProcessEvent(wxEvent& event);





    bool SafelyProcessEvent(wxEvent& event);
# 3397 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    bool ProcessEventLocally(wxEvent& event);






    virtual void QueueEvent(wxEvent *event);



    virtual void AddPendingEvent(const wxEvent& event)
    {






        QueueEvent(event.Clone());
    }

    void ProcessPendingEvents();


    void DeletePendingEvents();


    bool ProcessThreadEvent(const wxEvent& event);
# 3438 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    template <typename T>
    void CallAfter(void (T::*method)())
    {
        QueueEvent(
            new wxAsyncMethodCallEvent0<T>(static_cast<T*>(this), method)
        );
    }





    template <typename T, typename T1, typename P1>
    void CallAfter(void (T::*method)(T1 x1), P1 x1)
    {
        QueueEvent(
            new wxAsyncMethodCallEvent1<T, T1>(
                static_cast<T*>(this), method, x1)
        );
    }

    template <typename T, typename T1, typename T2, typename P1, typename P2>
    void CallAfter(void (T::*method)(T1 x1, T2 x2), P1 x1, P2 x2)
    {
        QueueEvent(
            new wxAsyncMethodCallEvent2<T, T1, T2>(
                static_cast<T*>(this), method, x1, x2)
        );
    }

    template <typename T>
    void CallAfter(const T& fn)
    {
        QueueEvent(new wxAsyncMethodCallEventFunctor<T>(this, fn));
    }
# 3490 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    void Connect(int winid,
                 int lastId,
                 wxEventType eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = 
# 3494 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                     __null
# 3494 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                         ,
                 wxEvtHandler *eventSink = 
# 3495 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                          __null
# 3495 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                              )
    {
        DoBind(winid, lastId, eventType,
                  wxNewEventFunctor(eventType, func, eventSink),
                  userData);
    }


    void Connect(int winid,
                 wxEventType eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = 
# 3506 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                     __null
# 3506 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                         ,
                 wxEvtHandler *eventSink = 
# 3507 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                          __null
# 3507 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                              )
        { Connect(winid, wxID_ANY, eventType, func, userData, eventSink); }


    void Connect(wxEventType eventType,
                 wxObjectEventFunction func,
                 wxObject *userData = 
# 3513 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                     __null
# 3513 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                         ,
                 wxEvtHandler *eventSink = 
# 3514 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                          __null
# 3514 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                              )
        { Connect(wxID_ANY, wxID_ANY, eventType, func, userData, eventSink); }

    bool Disconnect(int winid,
                    int lastId,
                    wxEventType eventType,
                    wxObjectEventFunction func = 
# 3520 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                __null
# 3520 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                    ,
                    wxObject *userData = 
# 3521 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                        __null
# 3521 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                            ,
                    wxEvtHandler *eventSink = 
# 3522 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                             __null
# 3522 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                 )
    {
        return DoUnbind(winid, lastId, eventType,
                            wxMakeEventFunctor(eventType, func, eventSink),
                            userData );
    }

    bool Disconnect(int winid = wxID_ANY,
                    wxEventType eventType = wxEVT_NULL,
                    wxObjectEventFunction func = 
# 3531 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                __null
# 3531 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                    ,
                    wxObject *userData = 
# 3532 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                        __null
# 3532 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                            ,
                    wxEvtHandler *eventSink = 
# 3533 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                             __null
# 3533 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                 )
        { return Disconnect(winid, wxID_ANY, eventType, func, userData, eventSink); }

    bool Disconnect(wxEventType eventType,
                    wxObjectEventFunction func,
                    wxObject *userData = 
# 3538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                        __null
# 3538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                            ,
                    wxEvtHandler *eventSink = 
# 3539 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                             __null
# 3539 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                 )
        { return Disconnect(wxID_ANY, eventType, func, userData, eventSink); }



    template <typename EventTag, typename EventArg>
    void Bind(const EventTag& eventType,
              void (*function)(EventArg &),
              int winid = wxID_ANY,
              int lastId = wxID_ANY,
              wxObject *userData = 
# 3549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                  __null
# 3549 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                      )
    {
        DoBind(winid, lastId, eventType,
                  wxNewEventFunctor(eventType, function),
                  userData);
    }


    template <typename EventTag, typename EventArg>
    bool Unbind(const EventTag& eventType,
                void (*function)(EventArg &),
                int winid = wxID_ANY,
                int lastId = wxID_ANY,
                wxObject *userData = 
# 3562 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                    __null
# 3562 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                        )
    {
        return DoUnbind(winid, lastId, eventType,
                            wxMakeEventFunctor(eventType, function),
                            userData);
    }


    template <typename EventTag, typename Functor>
    void Bind(const EventTag& eventType,
              const Functor &functor,
              int winid = wxID_ANY,
              int lastId = wxID_ANY,
              wxObject *userData = 
# 3575 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                  __null
# 3575 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                      )
    {
        DoBind(winid, lastId, eventType,
                  wxNewEventFunctor(eventType, functor),
                  userData);
    }


    template <typename EventTag, typename Functor>
    bool Unbind(const EventTag& eventType,
                const Functor &functor,
                int winid = wxID_ANY,
                int lastId = wxID_ANY,
                wxObject *userData = 
# 3588 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                    __null
# 3588 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                        )
    {
        return DoUnbind(winid, lastId, eventType,
                            wxMakeEventFunctor(eventType, functor),
                            userData);
    }





    template <typename EventTag, typename Class, typename EventArg, typename EventHandler>
    void Bind(const EventTag &eventType,
              void (Class::*method)(EventArg &),
              EventHandler *handler,
              int winid = wxID_ANY,
              int lastId = wxID_ANY,
              wxObject *userData = 
# 3605 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                  __null
# 3605 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                      )
    {
        DoBind(winid, lastId, eventType,
                  wxNewEventFunctor(eventType, method, handler),
                  userData);
    }

    template <typename EventTag, typename Class, typename EventArg, typename EventHandler>
    bool Unbind(const EventTag &eventType,
                void (Class::*method)(EventArg&),
                EventHandler *handler,
                int winid = wxID_ANY,
                int lastId = wxID_ANY,
                wxObject *userData = 
# 3618 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                    __null 
# 3618 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                         )
    {
        return DoUnbind(winid, lastId, eventType,
                            wxMakeEventFunctor(eventType, method, handler),
                            userData);
    }


    wxList* GetDynamicEventTable() const { return m_dynamicEvents ; }


    void SetClientObject( wxClientData *data ) { DoSetClientObject(data); }
    wxClientData *GetClientObject() const { return DoGetClientObject(); }

    void SetClientData( void *data ) { DoSetClientData(data); }
    void *GetClientData() const { return DoGetClientData(); }
# 3645 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
    static bool ProcessEventIfMatchesId(const wxEventTableEntryBase& tableEntry,
                                        wxEvtHandler *handler,
                                        wxEvent& event);

    virtual bool SearchEventTable(wxEventTable& table, wxEvent& event);
    bool SearchDynamicEventTable( wxEvent& event );


    void ClearEventHashTable() { GetEventHashTable().Clear(); }
    void OnSinkDestroyed( wxEvtHandler *sink );


private:
    void DoBind(int winid,
                   int lastId,
                   wxEventType eventType,
                   wxEventFunctor *func,
                   wxObject* userData = 
# 3662 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                       __null
# 3662 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                           );

    bool DoUnbind(int winid,
                      int lastId,
                      wxEventType eventType,
                      const wxEventFunctor& func,
                      wxObject *userData = 
# 3668 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                          __null
# 3668 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                              );

    static const wxEventTableEntry sm_eventTableEntries[];

protected:






    virtual bool TryBefore(wxEvent& event);






    bool TryHereOnly(wxEvent& event);



    bool TryBeforeAndHere(wxEvent& event)
    {
        return TryBefore(event) || TryHereOnly(event);
    }





    virtual bool TryAfter(wxEvent& event);



    __attribute__((deprecated)) virtual bool TryValidator(wxEvent& ) { return false; }


    __attribute__((deprecated)) virtual bool TryParent(wxEvent& event) { return DoTryApp(event); }




    static const wxEventTable sm_eventTable;
    virtual const wxEventTable *GetEventTable() const;

    static wxEventHashTable sm_eventHashTable;
    virtual wxEventHashTable& GetEventHashTable() const;

    wxEvtHandler* m_nextHandler;
    wxEvtHandler* m_previousHandler;
    wxList* m_dynamicEvents;
    wxList* m_pendingEvents;



    wxCriticalSection m_pendingEventsLock;



    bool m_enabled;







    union
    {
        wxClientData *m_clientObject;
        void *m_clientData;
    };


    wxClientDataType m_clientDataType;


    virtual void DoSetClientObject( wxClientData *data );
    virtual wxClientData *DoGetClientObject() const;

    virtual void DoSetClientData( void *data );
    virtual void *DoGetClientData() const;


    wxEventConnectionRef *FindRefInTrackerList(wxEvtHandler *handler);

private:

    bool DoTryApp(wxEvent& event);


    bool DoTryChain(wxEvent& event);


    static wxEventFilter* ms_filterList;

    private: wxEvtHandler(const wxEvtHandler&); wxEvtHandler& operator=(const wxEvtHandler&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

typedef wxEvtHandler * _wxArraywxEvtHandlerArray; struct wxAssert_wxEvtHandlerArray { unsigned int TypeTooBigToBeStoredInwxBaseArrayPtrVoid: sizeof(_wxArraywxEvtHandlerArray) <= sizeof(wxBaseArrayPtrVoid::base_type); }; typedef int ( *CMPFUNC_wxArraywxEvtHandlerArray)(_wxArraywxEvtHandlerArray *pItem1, _wxArraywxEvtHandlerArray *pItem2); class wxEvtHandlerArray : public wxBaseArrayPtrVoid { public: wxEvtHandlerArray() { } ~wxEvtHandlerArray() { } _wxArraywxEvtHandlerArray& operator[](size_t uiIndex) const { return (_wxArraywxEvtHandlerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEvtHandlerArray& Item(size_t uiIndex) const { return (_wxArraywxEvtHandlerArray&)(wxBaseArrayPtrVoid::operator[](uiIndex)); } _wxArraywxEvtHandlerArray& Last() const { return (_wxArraywxEvtHandlerArray&)(wxBaseArrayPtrVoid::operator[](GetCount() - 1)); } int Index(_wxArraywxEvtHandlerArray lItem, bool bFromEnd = false) const { return wxBaseArrayPtrVoid::Index((base_type)lItem, bFromEnd); } void Add(_wxArraywxEvtHandlerArray lItem, size_t nInsert = 1) { wxBaseArrayPtrVoid::Add((base_type)lItem, nInsert); } void Insert(_wxArraywxEvtHandlerArray lItem, size_t uiIndex, size_t nInsert = 1) { wxBaseArrayPtrVoid::Insert((base_type)lItem, uiIndex, nInsert) ; } void RemoveAt(size_t uiIndex, size_t nRemove = 1) { wxBaseArrayPtrVoid::RemoveAt(uiIndex, nRemove); } void Remove(_wxArraywxEvtHandlerArray lItem) { int iIndex = Index(lItem); if ( iIndex != (-1) ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h", 3768, __FUNCTION__, "iIndex != (-1)", "removing inexistent element in wxArray::Remove"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct; wxBaseArrayPtrVoid::RemoveAt((size_t)iIndex); } void Sort(CMPFUNC_wxArraywxEvtHandlerArray fCmp) { wxBaseArrayPtrVoid::Sort((CMPFUNC)fCmp); } private: typedef wxBaseArrayPtrVoid::iterator biterator; typedef wxBaseArrayPtrVoid::const_iterator bconst_iterator; typedef wxBaseArrayPtrVoid::value_type bvalue_type; typedef wxBaseArrayPtrVoid::const_reference bconst_reference; public: typedef _wxArraywxEvtHandlerArray value_type; typedef value_type* pointer; typedef const value_type* const_pointer; typedef value_type* iterator; typedef const value_type* const_iterator; typedef value_type& reference; typedef const value_type& const_reference; typedef wxBaseArrayPtrVoid::difference_type difference_type; typedef wxBaseArrayPtrVoid::size_type size_type; class reverse_iterator { typedef _wxArraywxEvtHandlerArray value_type; typedef value_type& reference; typedef value_type* pointer; typedef reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; reverse_iterator() : m_ptr(
# 3768 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
__null
# 3768 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
) { } reverse_iterator(pointer ptr) : m_ptr(ptr) { } reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { reverse_iterator tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; class const_reverse_iterator { typedef _wxArraywxEvtHandlerArray value_type; typedef const value_type& reference; typedef const value_type* pointer; typedef const_reverse_iterator itor; friend inline itor operator+(int o, const itor& it) { return it.m_ptr - o; } friend inline itor operator+(const itor& it, int o) { return it.m_ptr - o; } friend inline itor operator-(const itor& it, int o) { return it.m_ptr + o; } friend inline difference_type operator-(const itor& i1, const itor& i2) { return i1.m_ptr - i2.m_ptr; } public: pointer m_ptr; const_reverse_iterator() : m_ptr(
# 3768 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
__null
# 3768 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
) { } const_reverse_iterator(pointer ptr) : m_ptr(ptr) { } const_reverse_iterator(const itor& it) : m_ptr(it.m_ptr) { } const_reverse_iterator(const reverse_iterator& it) : m_ptr(it.m_ptr) { } reference operator*() const { return *m_ptr; } itor& operator++() { --m_ptr; return *this; } const itor operator++(int) { itor tmp = *this; --m_ptr; return tmp; } itor& operator--() { ++m_ptr; return *this; } const itor operator--(int) { itor tmp = *this; ++m_ptr; return tmp; } bool operator ==(const itor& it) const { return m_ptr == it.m_ptr; } bool operator !=(const itor& it) const { return m_ptr != it.m_ptr; } }; wxEvtHandlerArray(size_type n) { assign(n, value_type()); } wxEvtHandlerArray(size_type n, const_reference v) { assign(n, v); } wxEvtHandlerArray(const_iterator first, const_iterator last) { assign(first, last); } void assign(const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::assign((bconst_iterator)first, (bconst_iterator)last); } void assign(size_type n, const_reference v) { wxBaseArrayPtrVoid::assign(n, (bconst_reference)v); } reference back() { return *(end() - 1); } const_reference back() const { return *(end() - 1); } iterator begin() { return (iterator)wxBaseArrayPtrVoid::begin(); } const_iterator begin() const { return (const_iterator)wxBaseArrayPtrVoid::begin(); } size_type capacity() const { return wxBaseArrayPtrVoid::capacity(); } iterator end() { return (iterator)wxBaseArrayPtrVoid::end(); } const_iterator end() const { return (const_iterator)wxBaseArrayPtrVoid::end(); } iterator erase(iterator first, iterator last) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)first, (biterator)last); } iterator erase(iterator it) { return (iterator)wxBaseArrayPtrVoid::erase((biterator)it); } reference front() { return *begin(); } const_reference front() const { return *begin(); } void insert(iterator it, size_type n, const_reference v) { wxBaseArrayPtrVoid::insert((biterator)it, n, (bconst_reference)v); } iterator insert(iterator it, const_reference v = value_type()) { return (iterator)wxBaseArrayPtrVoid::insert((biterator)it, (bconst_reference)v); } void insert(iterator it, const_iterator first, const_iterator last) { wxBaseArrayPtrVoid::insert((biterator)it, (bconst_iterator)first, (bconst_iterator)last); } void pop_back() { wxBaseArrayPtrVoid::pop_back(); } void push_back(const_reference v) { wxBaseArrayPtrVoid::push_back((bconst_reference)v); } reverse_iterator rbegin() { return reverse_iterator(end() - 1); } const_reverse_iterator rbegin() const; reverse_iterator rend() { return reverse_iterator(begin() - 1); } const_reverse_iterator rend() const; void reserve(size_type n) { wxBaseArrayPtrVoid::reserve(n); } void resize(size_type n, value_type v = value_type()) { wxBaseArrayPtrVoid::resize(n, v); } void swap(wxEvtHandlerArray& other) { wxBaseArrayPtrVoid::swap(other); } };





inline void wxObjectEventFunctor::operator()(wxEvtHandler *handler, wxEvent& event)
{
    wxEvtHandler * const realHandler = m_handler ? m_handler : handler;

    (realHandler->*m_method)(event);
}
# 3788 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxEventConnectionRef : public wxTrackerNode
{
public:
    wxEventConnectionRef() : m_src(
# 3791 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                  __null
# 3791 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                      ), m_sink(
# 3791 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h" 3 4
                                                __null
# 3791 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
                                                    ), m_refCount(0) { }
    wxEventConnectionRef(wxEvtHandler *src, wxEvtHandler *sink)
        : m_src(src), m_sink(sink), m_refCount(1)
    {
        m_sink->AddNode(this);
    }


    virtual void OnObjectDestroy( )
    {
        if ( m_src )
            m_src->OnSinkDestroyed( m_sink );
        delete this;
    }

    virtual wxEventConnectionRef *ToEventConnection() { return this; }

    void IncRef() { m_refCount++; }
    void DecRef()
    {
        if ( !--m_refCount )
        {

            if ( m_sink )
                m_sink->RemoveNode(this);
            delete this;
        }
    }

private:
    wxEvtHandler *m_src,
                 *m_sink;
    int m_refCount;

    friend class wxEvtHandler;

    private: wxEventConnectionRef& operator=(const wxEventConnectionRef&);
};





inline void wxPostEvent(wxEvtHandler *dest, const wxEvent& event)
{
    if ( dest ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h", 3836, __FUNCTION__, "dest", "need an object to post event to"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

    dest->AddPendingEvent(event);
}




inline void wxQueueEvent(wxEvtHandler *dest, wxEvent *event)
{
    if ( dest ) {} else { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h", 3846, __FUNCTION__, "dest", "need an object to queue event for"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return; } struct wxDummyCheckStruct;

    dest->QueueEvent(event);
}

typedef void (wxEvtHandler::*wxEventFunction)(wxEvent&);
typedef void (wxEvtHandler::*wxIdleEventFunction)(wxIdleEvent&);
typedef void (wxEvtHandler::*wxThreadEventFunction)(wxThreadEvent&);
# 3868 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
class wxEventBlocker : public wxEvtHandler
{
public:
    wxEventBlocker(wxWindow *win, wxEventType type = ((wxEventType)-1));
    virtual ~wxEventBlocker();

    void Block(wxEventType type)
    {
        m_eventsToBlock.push_back(type);
    }

    virtual bool ProcessEvent(wxEvent& event);

protected:
    wxArrayInt m_eventsToBlock;
    wxWindow *m_window;

    private: wxEventBlocker(const wxEventBlocker&); wxEventBlocker& operator=(const wxEventBlocker&);
};

typedef void (wxEvtHandler::*wxCommandEventFunction)(wxCommandEvent&);
typedef void (wxEvtHandler::*wxScrollEventFunction)(wxScrollEvent&);
typedef void (wxEvtHandler::*wxScrollWinEventFunction)(wxScrollWinEvent&);
typedef void (wxEvtHandler::*wxSizeEventFunction)(wxSizeEvent&);
typedef void (wxEvtHandler::*wxMoveEventFunction)(wxMoveEvent&);
typedef void (wxEvtHandler::*wxPaintEventFunction)(wxPaintEvent&);
typedef void (wxEvtHandler::*wxNcPaintEventFunction)(wxNcPaintEvent&);
typedef void (wxEvtHandler::*wxEraseEventFunction)(wxEraseEvent&);
typedef void (wxEvtHandler::*wxMouseEventFunction)(wxMouseEvent&);
typedef void (wxEvtHandler::*wxCharEventFunction)(wxKeyEvent&);
typedef void (wxEvtHandler::*wxFocusEventFunction)(wxFocusEvent&);
typedef void (wxEvtHandler::*wxChildFocusEventFunction)(wxChildFocusEvent&);
typedef void (wxEvtHandler::*wxActivateEventFunction)(wxActivateEvent&);
typedef void (wxEvtHandler::*wxMenuEventFunction)(wxMenuEvent&);
typedef void (wxEvtHandler::*wxJoystickEventFunction)(wxJoystickEvent&);
typedef void (wxEvtHandler::*wxDropFilesEventFunction)(wxDropFilesEvent&);
typedef void (wxEvtHandler::*wxInitDialogEventFunction)(wxInitDialogEvent&);
typedef void (wxEvtHandler::*wxSysColourChangedEventFunction)(wxSysColourChangedEvent&);
typedef void (wxEvtHandler::*wxDisplayChangedEventFunction)(wxDisplayChangedEvent&);
typedef void (wxEvtHandler::*wxUpdateUIEventFunction)(wxUpdateUIEvent&);
typedef void (wxEvtHandler::*wxCloseEventFunction)(wxCloseEvent&);
typedef void (wxEvtHandler::*wxShowEventFunction)(wxShowEvent&);
typedef void (wxEvtHandler::*wxIconizeEventFunction)(wxIconizeEvent&);
typedef void (wxEvtHandler::*wxMaximizeEventFunction)(wxMaximizeEvent&);
typedef void (wxEvtHandler::*wxNavigationKeyEventFunction)(wxNavigationKeyEvent&);
typedef void (wxEvtHandler::*wxPaletteChangedEventFunction)(wxPaletteChangedEvent&);
typedef void (wxEvtHandler::*wxQueryNewPaletteEventFunction)(wxQueryNewPaletteEvent&);
typedef void (wxEvtHandler::*wxWindowCreateEventFunction)(wxWindowCreateEvent&);
typedef void (wxEvtHandler::*wxWindowDestroyEventFunction)(wxWindowDestroyEvent&);
typedef void (wxEvtHandler::*wxSetCursorEventFunction)(wxSetCursorEvent&);
typedef void (wxEvtHandler::*wxNotifyEventFunction)(wxNotifyEvent&);
typedef void (wxEvtHandler::*wxHelpEventFunction)(wxHelpEvent&);
typedef void (wxEvtHandler::*wxContextMenuEventFunction)(wxContextMenuEvent&);
typedef void (wxEvtHandler::*wxMouseCaptureChangedEventFunction)(wxMouseCaptureChangedEvent&);
typedef void (wxEvtHandler::*wxMouseCaptureLostEventFunction)(wxMouseCaptureLostEvent&);
typedef void (wxEvtHandler::*wxClipboardTextEventFunction)(wxClipboardTextEvent&);
# 4456 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/event.h"
 wxWindow* wxFindFocusDescendant(wxWindow* ancestor);
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2




# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h" 1
# 27 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
class wxFont;
# 37 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
enum wxFontFamily
{
    wxFONTFAMILY_DEFAULT = wxDEFAULT,
    wxFONTFAMILY_DECORATIVE = wxDECORATIVE,
    wxFONTFAMILY_ROMAN = wxROMAN,
    wxFONTFAMILY_SCRIPT = wxSCRIPT,
    wxFONTFAMILY_SWISS = wxSWISS,
    wxFONTFAMILY_MODERN = wxMODERN,
    wxFONTFAMILY_TELETYPE = wxTELETYPE,
    wxFONTFAMILY_MAX,
    wxFONTFAMILY_UNKNOWN = wxFONTFAMILY_MAX
};


enum wxFontStyle
{
    wxFONTSTYLE_NORMAL = wxNORMAL,
    wxFONTSTYLE_ITALIC = wxITALIC,
    wxFONTSTYLE_SLANT = wxSLANT,
    wxFONTSTYLE_MAX
};


enum wxFontWeight
{
    wxFONTWEIGHT_NORMAL = wxNORMAL,
    wxFONTWEIGHT_LIGHT = wxLIGHT,
    wxFONTWEIGHT_BOLD = wxBOLD,
    wxFONTWEIGHT_MAX
};


enum wxFontSymbolicSize
{
    wxFONTSIZE_XX_SMALL = -3,
    wxFONTSIZE_X_SMALL,
    wxFONTSIZE_SMALL,
    wxFONTSIZE_MEDIUM,
    wxFONTSIZE_LARGE,
    wxFONTSIZE_X_LARGE,
    wxFONTSIZE_XX_LARGE
};


enum wxFontFlag
{

    wxFONTFLAG_DEFAULT = 0,


    wxFONTFLAG_ITALIC = 1 << 0,
    wxFONTFLAG_SLANT = 1 << 1,


    wxFONTFLAG_LIGHT = 1 << 2,
    wxFONTFLAG_BOLD = 1 << 3,


    wxFONTFLAG_ANTIALIASED = 1 << 4,
    wxFONTFLAG_NOT_ANTIALIASED = 1 << 5,


    wxFONTFLAG_UNDERLINED = 1 << 6,
    wxFONTFLAG_STRIKETHROUGH = 1 << 7,


    wxFONTFLAG_MASK = wxFONTFLAG_ITALIC |
                      wxFONTFLAG_SLANT |
                      wxFONTFLAG_LIGHT |
                      wxFONTFLAG_BOLD |
                      wxFONTFLAG_ANTIALIASED |
                      wxFONTFLAG_NOT_ANTIALIASED |
                      wxFONTFLAG_UNDERLINED |
                      wxFONTFLAG_STRIKETHROUGH
};





class wxFontInfo
{
public:


    wxFontInfo()
        { InitPointSize(-1); }


    explicit wxFontInfo(int pointSize)
        { InitPointSize(pointSize); }
    explicit wxFontInfo(const wxSize& pixelSize) : m_pixelSize(pixelSize)
        { Init(); }



    wxFontInfo& Family(wxFontFamily family)
        { m_family = family; return *this; }
    wxFontInfo& FaceName(const wxString& faceName)
        { m_faceName = faceName; return *this; }

    wxFontInfo& Bold(bool bold = true)
        { SetFlag(wxFONTFLAG_BOLD, bold); return *this; }
    wxFontInfo& Light(bool light = true)
        { SetFlag(wxFONTFLAG_LIGHT, light); return *this; }

    wxFontInfo& Italic(bool italic = true)
        { SetFlag(wxFONTFLAG_ITALIC, italic); return *this; }
    wxFontInfo& Slant(bool slant = true)
        { SetFlag(wxFONTFLAG_SLANT, slant); return *this; }

    wxFontInfo& AntiAliased(bool antiAliased = true)
        { SetFlag(wxFONTFLAG_ANTIALIASED, antiAliased); return *this; }
    wxFontInfo& Underlined(bool underlined = true)
        { SetFlag(wxFONTFLAG_UNDERLINED, underlined); return *this; }
    wxFontInfo& Strikethrough(bool strikethrough = true)
        { SetFlag(wxFONTFLAG_STRIKETHROUGH, strikethrough); return *this; }

    wxFontInfo& Encoding(wxFontEncoding encoding)
        { m_encoding = encoding; return *this; }



    wxFontInfo& AllFlags(int flags)
        { m_flags = flags; return *this; }





    bool IsUsingSizeInPixels() const { return m_pixelSize != wxDefaultSize; }
    int GetPointSize() const { return m_pointSize; }
    wxSize GetPixelSize() const { return m_pixelSize; }
    wxFontFamily GetFamily() const { return m_family; }
    const wxString& GetFaceName() const { return m_faceName; }

    wxFontStyle GetStyle() const
    {
        return m_flags & wxFONTFLAG_ITALIC
                        ? wxFONTSTYLE_ITALIC
                        : m_flags & wxFONTFLAG_SLANT
                            ? wxFONTSTYLE_SLANT
                            : wxFONTSTYLE_NORMAL;
    }

    wxFontWeight GetWeight() const
    {
        return m_flags & wxFONTFLAG_LIGHT
                        ? wxFONTWEIGHT_LIGHT
                        : m_flags & wxFONTFLAG_BOLD
                            ? wxFONTWEIGHT_BOLD
                            : wxFONTWEIGHT_NORMAL;
    }

    bool IsAntiAliased() const
    {
        return (m_flags & wxFONTFLAG_ANTIALIASED) != 0;
    }

    bool IsUnderlined() const
    {
        return (m_flags & wxFONTFLAG_UNDERLINED) != 0;
    }

    bool IsStrikethrough() const
    {
        return (m_flags & wxFONTFLAG_STRIKETHROUGH) != 0;
    }

    wxFontEncoding GetEncoding() const { return m_encoding; }




private:


    void Init()
    {
        m_family = wxFONTFAMILY_DEFAULT;
        m_flags = wxFONTFLAG_DEFAULT;
        m_encoding = wxFONTENCODING_DEFAULT;
    }

    void InitPointSize(int pointSize)
    {
        Init();

        m_pointSize = pointSize;
        m_pixelSize = wxDefaultSize;
    }



    void SetFlag(int flag, bool on)
    {
        if ( on )
            m_flags |= flag;
        else
            m_flags &= ~flag;
    }





    int m_pointSize;
    wxSize m_pixelSize;

    wxFontFamily m_family;
    wxString m_faceName;
    int m_flags;
    wxFontEncoding m_encoding;
};





class wxNativeFontInfo;

class wxFontBase : public wxGDIObject
{
public:
# 285 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
    virtual ~wxFontBase();




    static wxFont *New(
        int pointSize,
        int family,
        int style,
        int weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
        { return New(pointSize, (wxFontFamily)family, (wxFontStyle)style,
                     (wxFontWeight)weight, underlined, face, encoding); }


    static wxFont *New(
        const wxSize& pixelSize,
        int family,
        int style,
        int weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
        { return New(pixelSize, (wxFontFamily)family, (wxFontStyle)style,
                     (wxFontWeight)weight, underlined, face, encoding); }



    static wxFont *New(
        int pointSize,
        wxFontFamily family,
        wxFontStyle style,
        wxFontWeight weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


    static wxFont *New(
        const wxSize& pixelSize,
        wxFontFamily family,
        wxFontStyle style,
        wxFontWeight weight,
        bool underlined = false,
        const wxString& face = wxEmptyString,
        wxFontEncoding encoding = wxFONTENCODING_DEFAULT);



    static wxFont *New(int pointSize,
                       wxFontFamily family,
                       int flags = wxFONTFLAG_DEFAULT,
                       const wxString& face = wxEmptyString,
                       wxFontEncoding encoding = wxFONTENCODING_DEFAULT);




    static wxFont *New(const wxSize& pixelSize,
                       wxFontFamily family,
                       int flags = wxFONTFLAG_DEFAULT,
                       const wxString& face = wxEmptyString,
                       wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


    static wxFont *New(const wxNativeFontInfo& nativeFontDesc);


    static wxFont *New(const wxString& strNativeFontDesc);


    bool operator==(const wxFont& font) const;
    bool operator!=(const wxFont& font) const { return !(*this == font); }


    virtual int GetPointSize() const = 0;
    virtual wxSize GetPixelSize() const;
    virtual bool IsUsingSizeInPixels() const;
    wxFontFamily GetFamily() const;
    virtual wxFontStyle GetStyle() const = 0;
    virtual wxFontWeight GetWeight() const = 0;
    virtual bool GetUnderlined() const = 0;
    virtual bool GetStrikethrough() const { return false; }
    virtual wxString GetFaceName() const = 0;
    virtual wxFontEncoding GetEncoding() const = 0;
    virtual const wxNativeFontInfo *GetNativeFontInfo() const = 0;

    virtual bool IsFixedWidth() const;

    wxString GetNativeFontInfoDesc() const;
    wxString GetNativeFontInfoUserDesc() const;


    virtual void SetPointSize( int pointSize ) = 0;
    virtual void SetPixelSize( const wxSize& pixelSize );
    virtual void SetFamily( wxFontFamily family ) = 0;
    virtual void SetStyle( wxFontStyle style ) = 0;
    virtual void SetWeight( wxFontWeight weight ) = 0;

    virtual void SetUnderlined( bool underlined ) = 0;
    virtual void SetStrikethrough( bool ) {}
    virtual void SetEncoding(wxFontEncoding encoding) = 0;
    virtual bool SetFaceName( const wxString& faceName );
    void SetNativeFontInfo(const wxNativeFontInfo& info)
        { DoSetNativeFontInfo(info); }

    bool SetNativeFontInfo(const wxString& info);
    bool SetNativeFontInfoUserDesc(const wxString& info);




    void SetSymbolicSize(wxFontSymbolicSize size);
    void SetSymbolicSizeRelativeTo(wxFontSymbolicSize size, int base)
    {
        SetPointSize(AdjustToSymbolicSize(size, base));
    }


    static int AdjustToSymbolicSize(wxFontSymbolicSize size, int base);




    wxString GetFamilyString() const;
    wxString GetStyleString() const;
    wxString GetWeightString() const;



    static wxFontEncoding GetDefaultEncoding() { return ms_encodingDefault; }
    static void SetDefaultEncoding(wxFontEncoding encoding);



    __attribute__((deprecated)) void SetNoAntiAliasing(bool no = true) { wxUnusedVar(no); }
    __attribute__((deprecated)) bool GetNoAntiAliasing() const { return false; }


protected:

    virtual void DoSetNativeFontInfo(const wxNativeFontInfo& info);



    virtual wxFontFamily DoGetFamily() const = 0;




    static wxFontStyle GetStyleFromFlags(int flags)
    {
        return flags & wxFONTFLAG_ITALIC
                        ? wxFONTSTYLE_ITALIC
                        : flags & wxFONTFLAG_SLANT
                            ? wxFONTSTYLE_SLANT
                            : wxFONTSTYLE_NORMAL;
    }

    static wxFontWeight GetWeightFromFlags(int flags)
    {
        return flags & wxFONTFLAG_LIGHT
                        ? wxFONTWEIGHT_LIGHT
                        : flags & wxFONTFLAG_BOLD
                            ? wxFONTWEIGHT_BOLD
                            : wxFONTWEIGHT_NORMAL;
    }

    static bool GetUnderlinedFromFlags(int flags)
    {
        return (flags & wxFONTFLAG_UNDERLINED) != 0;
    }

    static bool GetStrikethroughFromFlags(int flags)
    {
        return (flags & wxFONTFLAG_STRIKETHROUGH) != 0;
    }

private:




    static wxFontEncoding ms_encodingDefault;
};


 wxString wxToString(const wxFontBase& font);
 bool wxFromString(const wxString& str, wxFontBase* font);
# 519 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/font.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/font.h"
class wxFont : public wxFontBase
{
public:

    wxFont() { }

    wxFont(const wxFontInfo& info);


    wxFont(int size,
           int family,
           int style,
           int weight,
           bool underlined = false,
           const wxString& face = wxEmptyString,
           wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        (void)Create(size, (wxFontFamily)family, (wxFontStyle)style, (wxFontWeight)weight, underlined, face, encoding);
    }


    wxFont(int size,
           wxFontFamily family,
           wxFontStyle style,
           wxFontWeight weight,
           bool underlined = false,
           const wxString& face = wxEmptyString,
           wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        Create(size, family, style, weight, underlined, face, encoding);
    }

    bool Create(int size,
                wxFontFamily family,
                wxFontStyle style,
                wxFontWeight weight,
                bool underlined = false,
                const wxString& face = wxEmptyString,
                wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        return DoCreate(size, wxDefaultSize, false, family, style,
                        weight, underlined, face, encoding);
    }


    wxFont(const wxSize& pixelSize,
           int family,
           int style,
           int weight,
           bool underlined = false,
           const wxString& face = wxEmptyString,
           wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        (void)Create(pixelSize, (wxFontFamily)family, (wxFontStyle)style, (wxFontWeight)weight,
                     underlined, face, encoding);
    }


    wxFont(const wxSize& pixelSize,
           wxFontFamily family,
           wxFontStyle style,
           wxFontWeight weight,
           bool underlined = false,
           const wxString& face = wxEmptyString,
           wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        (void)Create(pixelSize, family, style, weight,
                     underlined, face, encoding);
    }

    wxFont(const wxNativeFontInfo& info, WXHFONT hFont = 0)
    {
        Create(info, hFont);
    }

    wxFont(const wxString& fontDesc);


    bool Create(const wxSize& pixelSize,
                wxFontFamily family,
                wxFontStyle style,
                wxFontWeight weight,
                bool underlined = false,
                const wxString& face = wxEmptyString,
                wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
    {
        return DoCreate(-1, pixelSize, true, family, style,
                        weight, underlined, face, encoding);
    }

    bool Create(const wxNativeFontInfo& info, WXHFONT hFont = 0);

    virtual ~wxFont();


    virtual int GetPointSize() const;
    virtual wxSize GetPixelSize() const;
    virtual bool IsUsingSizeInPixels() const;
    virtual wxFontStyle GetStyle() const;
    virtual wxFontWeight GetWeight() const;
    virtual bool GetUnderlined() const;
    virtual bool GetStrikethrough() const;
    virtual wxString GetFaceName() const;
    virtual wxFontEncoding GetEncoding() const;
    virtual const wxNativeFontInfo *GetNativeFontInfo() const;

    virtual void SetPointSize(int pointSize);
    virtual void SetPixelSize(const wxSize& pixelSize);
    virtual void SetFamily(wxFontFamily family);
    virtual void SetStyle(wxFontStyle style);
    virtual void SetWeight(wxFontWeight weight);
    virtual bool SetFaceName(const wxString& faceName);
    virtual void SetUnderlined(bool underlined);
    virtual void SetStrikethrough(bool strikethrough);
    virtual void SetEncoding(wxFontEncoding encoding);

    void SetFamily(int family) { SetFamily((wxFontFamily)family); } void SetStyle(int style) { SetStyle((wxFontStyle)style); } void SetWeight(int weight) { SetWeight((wxFontWeight)weight); } void SetFamily(wxDeprecatedGUIConstants family) { SetFamily((wxFontFamily)family); } void SetStyle(wxDeprecatedGUIConstants style) { SetStyle((wxFontStyle)style); } void SetWeight(wxDeprecatedGUIConstants weight) { SetWeight((wxFontWeight)weight); } wxFont& MakeBold(); wxFont& MakeItalic(); wxFont& MakeUnderlined(); wxFont& MakeStrikethrough(); wxFont& MakeLarger() { return Scale(1.2f); } wxFont& MakeSmaller() { return Scale(1/1.2f); } wxFont& Scale(float x); wxFont Bold() const; wxFont Italic() const; wxFont Underlined() const; wxFont Strikethrough() const; wxFont Larger() const { return Scaled(1.2f); } wxFont Smaller() const { return Scaled(1/1.2f); } wxFont Scaled(float x) const;

    virtual bool IsFixedWidth() const;




    virtual bool IsFree() const;
    virtual bool RealizeResource();
    virtual WXHANDLE GetResourceHandle() const;
    virtual bool FreeResource(bool force = false);


    WXHFONT GetHFONT() const;

protected:

    bool DoCreate(int size,
                  const wxSize& pixelSize,
                  bool sizeUsingPixels,
                  wxFontFamily family,
                  wxFontStyle style,
                  wxFontWeight weight,
                  bool underlined = false,
                  const wxString& face = wxEmptyString,
                  wxFontEncoding encoding = wxFONTENCODING_DEFAULT);

    virtual void DoSetNativeFontInfo(const wxNativeFontInfo& info);
    virtual wxFontFamily DoGetFamily() const;


    virtual wxGDIRefData *CreateGDIRefData() const;
    virtual wxGDIRefData *CloneGDIRefData(const wxGDIRefData *data) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 520 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h" 2
# 538 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
class wxFontList: public wxGDIObjListBase
{
public:
    wxFont *FindOrCreateFont(int pointSize,
                             wxFontFamily family,
                             wxFontStyle style,
                             wxFontWeight weight,
                             bool underline = false,
                             const wxString& face = wxEmptyString,
                             wxFontEncoding encoding = wxFONTENCODING_DEFAULT);


     wxFont *FindOrCreateFont(int pointSize, int family, int style, int weight,
                              bool underline = false,
                              const wxString& face = wxEmptyString,
                              wxFontEncoding encoding = wxFONTENCODING_DEFAULT)
        { return FindOrCreateFont(pointSize, (wxFontFamily)family, (wxFontStyle)style,
                                  (wxFontWeight)weight, underline, face, encoding); }






};

extern wxFontList* wxTheFontList;
# 580 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/font.h"
inline bool operator==(wxFontFamily s, wxDeprecatedGUIConstants t)
{ return static_cast<int>(s) == static_cast<int>(t); }
inline bool operator!=(wxFontFamily s, wxDeprecatedGUIConstants t)
{ return !(s == t); }
inline bool operator==(wxFontStyle s, wxDeprecatedGUIConstants t)
{ return static_cast<int>(s) == static_cast<int>(t); }
inline bool operator!=(wxFontStyle s, wxDeprecatedGUIConstants t)
{ return !(s == t); }
inline bool operator==(wxFontWeight s, wxDeprecatedGUIConstants t)
{ return static_cast<int>(s) == static_cast<int>(t); }
inline bool operator!=(wxFontWeight s, wxDeprecatedGUIConstants t)
{ return !(s == t); }
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
class wxColour;
# 37 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
enum {
    wxC2S_NAME = 1,
    wxC2S_CSS_SYNTAX = 2,
    wxC2S_HTML_SYNTAX = 4
};

const unsigned char wxALPHA_TRANSPARENT = 0;
const unsigned char wxALPHA_OPAQUE = 0xff;
# 56 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
 wxColour& operator << ( wxColour &object, const wxVariant &variant ); wxVariant& operator << ( wxVariant &variant, const wxColour &object );
# 74 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
class wxColourBase : public



    wxObject

{
public:

    typedef unsigned char ChannelType;

    wxColourBase() {}
    virtual ~wxColourBase() {}





    void Set(ChannelType red,
             ChannelType green,
             ChannelType blue,
             ChannelType alpha = wxALPHA_OPAQUE)
        { InitRGBA(red, green, blue, alpha); }


    bool Set(const wxString &str)
        { return FromString(str); }

    void Set(unsigned long colRGB)
    {


        Set((ChannelType)(0xFF & colRGB),
            (ChannelType)(0xFF & (colRGB >> 8)),
            (ChannelType)(0xFF & (colRGB >> 16)));
    }






    virtual ChannelType Red() const = 0;
    virtual ChannelType Green() const = 0;
    virtual ChannelType Blue() const = 0;
    virtual ChannelType Alpha() const
        { return wxALPHA_OPAQUE ; }


    virtual wxString GetAsString(long flags = wxC2S_NAME | wxC2S_CSS_SYNTAX) const;

    void SetRGB(wxUint32 colRGB)
    {
        Set((ChannelType)(0xFF & colRGB),
            (ChannelType)(0xFF & (colRGB >> 8)),
            (ChannelType)(0xFF & (colRGB >> 16)));
    }

    void SetRGBA(wxUint32 colRGBA)
    {
        Set((ChannelType)(0xFF & colRGBA),
            (ChannelType)(0xFF & (colRGBA >> 8)),
            (ChannelType)(0xFF & (colRGBA >> 16)),
            (ChannelType)(0xFF & (colRGBA >> 24)));
    }

    wxUint32 GetRGB() const
        { return Red() | (Green() << 8) | (Blue() << 16); }

    wxUint32 GetRGBA() const
        { return Red() | (Green() << 8) | (Blue() << 16) | (Alpha() << 24); }


    virtual bool IsOk() const= 0;



    bool Ok() const { return IsOk(); }
# 160 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
    static void MakeMono (unsigned char* r, unsigned char* g, unsigned char* b, bool on);
    static void MakeDisabled(unsigned char* r, unsigned char* g, unsigned char* b, unsigned char brightness = 255);
    static void MakeGrey (unsigned char* r, unsigned char* g, unsigned char* b);
    static void MakeGrey (unsigned char* r, unsigned char* g, unsigned char* b,
                                      double weight_r, double weight_g, double weight_b);
    static unsigned char AlphaBlend (unsigned char fg, unsigned char bg, double alpha);
    static void ChangeLightness(unsigned char* r, unsigned char* g, unsigned char* b, int ialpha);

    wxColour ChangeLightness(int ialpha) const;
    wxColour& MakeDisabled(unsigned char brightness = 255);
# 179 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
protected:


    void Init() { }

    virtual void
    InitRGBA(ChannelType r, ChannelType g, ChannelType b, ChannelType a) = 0;

    virtual bool FromString(const wxString& s);
# 207 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h"
};



 wxString wxToString(const wxColourBase& col);
 bool wxFromString(const wxString& str, wxColourBase* col);




# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/colour.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/colour.h"
class wxColour : public wxColourBase
{
public:


    wxColour() { Init(); } wxColour(ChannelType red, ChannelType green, ChannelType blue, ChannelType alpha = wxALPHA_OPAQUE) { Init(); Set(red, green, blue, alpha); } wxColour(unsigned long colRGB) { Init(); Set(colRGB ); } wxColour(const wxString& colourName) { Init(); Set(colourName); } wxColour(const char *colourName) { Init(); Set(colourName); } wxColour(const wchar_t *colourName) { Init(); Set(colourName); }




    virtual bool IsOk() const { return m_isInit; }

    unsigned char Red() const { return m_red; }
    unsigned char Green() const { return m_green; }
    unsigned char Blue() const { return m_blue; }
    unsigned char Alpha() const { return m_alpha ; }


    bool operator==(const wxColour& colour) const
    {
        return m_isInit == colour.m_isInit
            && m_red == colour.m_red
            && m_green == colour.m_green
            && m_blue == colour.m_blue
            && m_alpha == colour.m_alpha;
    }

    bool operator!=(const wxColour& colour) const { return !(*this == colour); }

    WXCOLORREF GetPixel() const { return m_pixel; }

public:
    WXCOLORREF m_pixel;

protected:

    void Init();

    virtual void
    InitRGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a);

private:
    bool m_isInit;
    unsigned char m_red;
    unsigned char m_blue;
    unsigned char m_green;
    unsigned char m_alpha;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 218 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/colour.h" 2
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h"
class wxBitmap;
class wxColour;
class wxRegion;






enum wxRegionContain
{
    wxOutRegion = 0,
    wxPartRegion = 1,
    wxInRegion = 2
};



enum wxRegionOp
{

    wxRGN_AND,


    wxRGN_COPY,


    wxRGN_DIFF,


    wxRGN_OR,


    wxRGN_XOR
};





class wxRegionBase : public wxGDIObject
{
public:
# 77 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h"
    bool operator==(const wxRegion& region) const { return IsEqual(region); }
    bool operator!=(const wxRegion& region) const { return !(*this == region); }






    virtual bool IsEmpty() const = 0;
    bool Empty() const { return IsEmpty(); }


    bool IsEqual(const wxRegion& region) const;


    bool GetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const
        { return DoGetBox(x, y, w, h); }
    wxRect GetBox() const
    {
        wxCoord x, y, w, h;
        return DoGetBox(x, y, w, h) ? wxRect(x, y, w, h) : wxRect();
    }


    wxRegionContain Contains(wxCoord x, wxCoord y) const
        { return DoContainsPoint(x, y); }
    wxRegionContain Contains(const wxPoint& pt) const
        { return DoContainsPoint(pt.x, pt.y); }
    wxRegionContain Contains(wxCoord x, wxCoord y, wxCoord w, wxCoord h) const
        { return DoContainsRect(wxRect(x, y, w, h)); }
    wxRegionContain Contains(const wxRect& rect) const
        { return DoContainsRect(rect); }





    virtual void Clear() = 0;


    bool Offset(wxCoord x, wxCoord y)
        { return DoOffset(x, y); }
    bool Offset(const wxPoint& pt)
        { return DoOffset(pt.x, pt.y); }


    bool Union(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
        { return DoUnionWithRect(wxRect(x, y, w, h)); }
    bool Union(const wxRect& rect)
        { return DoUnionWithRect(rect); }
    bool Union(const wxRegion& region)
        { return DoUnionWithRegion(region); }







    bool Union(const wxBitmap& bmp);
    bool Union(const wxBitmap& bmp, const wxColour& transp, int tolerance = 0);



    bool Intersect(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Intersect(const wxRect& rect);
    bool Intersect(const wxRegion& region)
        { return DoIntersect(region); }



    bool Subtract(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Subtract(const wxRect& rect);
    bool Subtract(const wxRegion& region)
        { return DoSubtract(region); }


    bool Xor(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    bool Xor(const wxRect& rect);
    bool Xor(const wxRegion& region)
        { return DoXor(region); }




    wxBitmap ConvertToBitmap() const;

protected:
    virtual bool DoIsEqual(const wxRegion& region) const = 0;
    virtual bool DoGetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const = 0;
    virtual wxRegionContain DoContainsPoint(wxCoord x, wxCoord y) const = 0;
    virtual wxRegionContain DoContainsRect(const wxRect& rect) const = 0;

    virtual bool DoOffset(wxCoord x, wxCoord y) = 0;

    virtual bool DoUnionWithRect(const wxRect& rect) = 0;
    virtual bool DoUnionWithRegion(const wxRegion& region) = 0;

    virtual bool DoIntersect(const wxRegion& region) = 0;
    virtual bool DoSubtract(const wxRegion& region) = 0;
    virtual bool DoXor(const wxRegion& region) = 0;
};
# 189 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h"
class wxRegionWithCombine : public wxRegionBase
{
public:


    bool Combine(wxCoord x, wxCoord y, wxCoord w, wxCoord h, wxRegionOp op);
    bool Combine(const wxRect& rect, wxRegionOp op);
    bool Combine(const wxRegion& region, wxRegionOp op)
        { return DoCombine(region, op); }


protected:

    virtual bool DoCombine(const wxRegion& region, wxRegionOp op) = 0;


    virtual bool DoUnionWithRect(const wxRect& rect);
    virtual bool DoUnionWithRegion(const wxRegion& region);
    virtual bool DoIntersect(const wxRegion& region);
    virtual bool DoSubtract(const wxRegion& region);
    virtual bool DoXor(const wxRegion& region);
};




# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/region.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/region.h"
class wxRegion : public wxRegionWithCombine
{
public:
    wxRegion();
    wxRegion(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
    wxRegion(const wxPoint& topLeft, const wxPoint& bottomRight);
    wxRegion(const wxRect& rect);
    wxRegion(WXHRGN hRegion);
    wxRegion(size_t n, const wxPoint *points, wxPolygonFillMode fillStyle = wxODDEVEN_RULE );

    wxRegion( const wxBitmap& bmp)
    {
        Union(bmp);
    }
    wxRegion( const wxBitmap& bmp,
              const wxColour& transColour, int tolerance = 0)
    {
        Union(bmp, transColour, tolerance);
    }


    virtual ~wxRegion();


    virtual void Clear();
    virtual bool IsEmpty() const;


    WXHRGN GetHRGN() const;

protected:
    virtual wxGDIRefData *CreateGDIRefData() const;
    virtual wxGDIRefData *CloneGDIRefData(const wxGDIRefData *data) const;

    virtual bool DoIsEqual(const wxRegion& region) const;
    virtual bool DoGetBox(wxCoord& x, wxCoord& y, wxCoord& w, wxCoord& h) const;
    virtual wxRegionContain DoContainsPoint(wxCoord x, wxCoord y) const;
    virtual wxRegionContain DoContainsRect(const wxRect& rect) const;

    virtual bool DoOffset(wxCoord x, wxCoord y);
    virtual bool DoCombine(const wxRegion& region, wxRegionOp op);

    friend class wxRegionIterator;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};

class wxRegionIterator : public wxObject
{
public:
    wxRegionIterator() { Init(); }
    wxRegionIterator(const wxRegion& region);
    wxRegionIterator(const wxRegionIterator& ri) : wxObject(ri) { Init(); *this = ri; }

    wxRegionIterator& operator=(const wxRegionIterator& ri);

    virtual ~wxRegionIterator();

    void Reset() { m_current = 0; }
    void Reset(const wxRegion& region);

    bool HaveRects() const { return (m_current < m_numRects); }

    operator bool () const { return HaveRects(); }

    wxRegionIterator& operator++();
    wxRegionIterator operator++(int);

    wxCoord GetX() const;
    wxCoord GetY() const;
    wxCoord GetW() const;
    wxCoord GetWidth() const { return GetW(); }
    wxCoord GetH() const;
    wxCoord GetHeight() const { return GetH(); }

    wxRect GetRect() const { return wxRect(GetX(), GetY(), GetW(), GetH()); }

private:

    void Init();

    long m_current;
    long m_numRects;
    wxRegion m_region;
    wxRect* m_rects;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 216 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h" 2
# 240 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/region.h"
inline bool wxRegionBase::Intersect(const wxRect& rect)
{
    return DoIntersect(wxRegion(rect));
}

inline bool wxRegionBase::Subtract(const wxRect& rect)
{
    return DoSubtract(wxRegion(rect));
}

inline bool wxRegionBase::Xor(const wxRect& rect)
{
    return DoXor(wxRegion(rect));
}




inline bool wxRegionBase::Intersect(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Intersect(wxRect(x, y, w, h));
}

inline bool wxRegionBase::Subtract(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Subtract(wxRect(x, y, w, h));
}

inline bool wxRegionBase::Xor(wxCoord x, wxCoord y, wxCoord w, wxCoord h)
{
    return Xor(wxRect(x, y, w, h));
}



inline bool wxRegionWithCombine::Combine(wxCoord x,
                                         wxCoord y,
                                         wxCoord w,
                                         wxCoord h,
                                         wxRegionOp op)
{
    return DoCombine(wxRegion(x, y, w, h), op);
}

inline bool wxRegionWithCombine::Combine(const wxRect& rect, wxRegionOp op)
{
    return DoCombine(wxRegion(rect), op);
}
# 26 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 1
# 21 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/language.h" 1
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/language.h"
enum wxLanguage
{

    wxLANGUAGE_DEFAULT,


    wxLANGUAGE_UNKNOWN,

    wxLANGUAGE_ABKHAZIAN,
    wxLANGUAGE_AFAR,
    wxLANGUAGE_AFRIKAANS,
    wxLANGUAGE_ALBANIAN,
    wxLANGUAGE_AMHARIC,
    wxLANGUAGE_ARABIC,
    wxLANGUAGE_ARABIC_ALGERIA,
    wxLANGUAGE_ARABIC_BAHRAIN,
    wxLANGUAGE_ARABIC_EGYPT,
    wxLANGUAGE_ARABIC_IRAQ,
    wxLANGUAGE_ARABIC_JORDAN,
    wxLANGUAGE_ARABIC_KUWAIT,
    wxLANGUAGE_ARABIC_LEBANON,
    wxLANGUAGE_ARABIC_LIBYA,
    wxLANGUAGE_ARABIC_MOROCCO,
    wxLANGUAGE_ARABIC_OMAN,
    wxLANGUAGE_ARABIC_QATAR,
    wxLANGUAGE_ARABIC_SAUDI_ARABIA,
    wxLANGUAGE_ARABIC_SUDAN,
    wxLANGUAGE_ARABIC_SYRIA,
    wxLANGUAGE_ARABIC_TUNISIA,
    wxLANGUAGE_ARABIC_UAE,
    wxLANGUAGE_ARABIC_YEMEN,
    wxLANGUAGE_ARMENIAN,
    wxLANGUAGE_ASSAMESE,
    wxLANGUAGE_ASTURIAN,
    wxLANGUAGE_AYMARA,
    wxLANGUAGE_AZERI,
    wxLANGUAGE_AZERI_CYRILLIC,
    wxLANGUAGE_AZERI_LATIN,
    wxLANGUAGE_BASHKIR,
    wxLANGUAGE_BASQUE,
    wxLANGUAGE_BELARUSIAN,
    wxLANGUAGE_BENGALI,
    wxLANGUAGE_BHUTANI,
    wxLANGUAGE_BIHARI,
    wxLANGUAGE_BISLAMA,
    wxLANGUAGE_BOSNIAN,
    wxLANGUAGE_BRETON,
    wxLANGUAGE_BULGARIAN,
    wxLANGUAGE_BURMESE,
    wxLANGUAGE_CAMBODIAN,
    wxLANGUAGE_CATALAN,
    wxLANGUAGE_CHINESE,
    wxLANGUAGE_CHINESE_SIMPLIFIED,
    wxLANGUAGE_CHINESE_TRADITIONAL,
    wxLANGUAGE_CHINESE_HONGKONG,
    wxLANGUAGE_CHINESE_MACAU,
    wxLANGUAGE_CHINESE_SINGAPORE,
    wxLANGUAGE_CHINESE_TAIWAN,
    wxLANGUAGE_CORSICAN,
    wxLANGUAGE_CROATIAN,
    wxLANGUAGE_CZECH,
    wxLANGUAGE_DANISH,
    wxLANGUAGE_DUTCH,
    wxLANGUAGE_DUTCH_BELGIAN,
    wxLANGUAGE_ENGLISH,
    wxLANGUAGE_ENGLISH_UK,
    wxLANGUAGE_ENGLISH_US,
    wxLANGUAGE_ENGLISH_AUSTRALIA,
    wxLANGUAGE_ENGLISH_BELIZE,
    wxLANGUAGE_ENGLISH_BOTSWANA,
    wxLANGUAGE_ENGLISH_CANADA,
    wxLANGUAGE_ENGLISH_CARIBBEAN,
    wxLANGUAGE_ENGLISH_DENMARK,
    wxLANGUAGE_ENGLISH_EIRE,
    wxLANGUAGE_ENGLISH_JAMAICA,
    wxLANGUAGE_ENGLISH_NEW_ZEALAND,
    wxLANGUAGE_ENGLISH_PHILIPPINES,
    wxLANGUAGE_ENGLISH_SOUTH_AFRICA,
    wxLANGUAGE_ENGLISH_TRINIDAD,
    wxLANGUAGE_ENGLISH_ZIMBABWE,
    wxLANGUAGE_ESPERANTO,
    wxLANGUAGE_ESTONIAN,
    wxLANGUAGE_FAEROESE,
    wxLANGUAGE_FARSI,
    wxLANGUAGE_FIJI,
    wxLANGUAGE_FINNISH,
    wxLANGUAGE_FRENCH,
    wxLANGUAGE_FRENCH_BELGIAN,
    wxLANGUAGE_FRENCH_CANADIAN,
    wxLANGUAGE_FRENCH_LUXEMBOURG,
    wxLANGUAGE_FRENCH_MONACO,
    wxLANGUAGE_FRENCH_SWISS,
    wxLANGUAGE_FRISIAN,
    wxLANGUAGE_GALICIAN,
    wxLANGUAGE_GEORGIAN,
    wxLANGUAGE_GERMAN,
    wxLANGUAGE_GERMAN_AUSTRIAN,
    wxLANGUAGE_GERMAN_BELGIUM,
    wxLANGUAGE_GERMAN_LIECHTENSTEIN,
    wxLANGUAGE_GERMAN_LUXEMBOURG,
    wxLANGUAGE_GERMAN_SWISS,
    wxLANGUAGE_GREEK,
    wxLANGUAGE_GREENLANDIC,
    wxLANGUAGE_GUARANI,
    wxLANGUAGE_GUJARATI,
    wxLANGUAGE_HAUSA,
    wxLANGUAGE_HEBREW,
    wxLANGUAGE_HINDI,
    wxLANGUAGE_HUNGARIAN,
    wxLANGUAGE_ICELANDIC,
    wxLANGUAGE_INDONESIAN,
    wxLANGUAGE_INTERLINGUA,
    wxLANGUAGE_INTERLINGUE,
    wxLANGUAGE_INUKTITUT,
    wxLANGUAGE_INUPIAK,
    wxLANGUAGE_IRISH,
    wxLANGUAGE_ITALIAN,
    wxLANGUAGE_ITALIAN_SWISS,
    wxLANGUAGE_JAPANESE,
    wxLANGUAGE_JAVANESE,
    wxLANGUAGE_KANNADA,
    wxLANGUAGE_KASHMIRI,
    wxLANGUAGE_KASHMIRI_INDIA,
    wxLANGUAGE_KAZAKH,
    wxLANGUAGE_KERNEWEK,
    wxLANGUAGE_KINYARWANDA,
    wxLANGUAGE_KIRGHIZ,
    wxLANGUAGE_KIRUNDI,
    wxLANGUAGE_KONKANI,
    wxLANGUAGE_KOREAN,
    wxLANGUAGE_KURDISH,
    wxLANGUAGE_LAOTHIAN,
    wxLANGUAGE_LATIN,
    wxLANGUAGE_LATVIAN,
    wxLANGUAGE_LINGALA,
    wxLANGUAGE_LITHUANIAN,
    wxLANGUAGE_MACEDONIAN,
    wxLANGUAGE_MALAGASY,
    wxLANGUAGE_MALAY,
    wxLANGUAGE_MALAYALAM,
    wxLANGUAGE_MALAY_BRUNEI_DARUSSALAM,
    wxLANGUAGE_MALAY_MALAYSIA,
    wxLANGUAGE_MALTESE,
    wxLANGUAGE_MANIPURI,
    wxLANGUAGE_MAORI,
    wxLANGUAGE_MARATHI,
    wxLANGUAGE_MOLDAVIAN,
    wxLANGUAGE_MONGOLIAN,
    wxLANGUAGE_NAURU,
    wxLANGUAGE_NEPALI,
    wxLANGUAGE_NEPALI_INDIA,
    wxLANGUAGE_NORWEGIAN_BOKMAL,
    wxLANGUAGE_NORWEGIAN_NYNORSK,
    wxLANGUAGE_OCCITAN,
    wxLANGUAGE_ORIYA,
    wxLANGUAGE_OROMO,
    wxLANGUAGE_PASHTO,
    wxLANGUAGE_POLISH,
    wxLANGUAGE_PORTUGUESE,
    wxLANGUAGE_PORTUGUESE_BRAZILIAN,
    wxLANGUAGE_PUNJABI,
    wxLANGUAGE_QUECHUA,
    wxLANGUAGE_RHAETO_ROMANCE,
    wxLANGUAGE_ROMANIAN,
    wxLANGUAGE_RUSSIAN,
    wxLANGUAGE_RUSSIAN_UKRAINE,
    wxLANGUAGE_SAMI,
    wxLANGUAGE_SAMOAN,
    wxLANGUAGE_SANGHO,
    wxLANGUAGE_SANSKRIT,
    wxLANGUAGE_SCOTS_GAELIC,
    wxLANGUAGE_SERBIAN,
    wxLANGUAGE_SERBIAN_CYRILLIC,
    wxLANGUAGE_SERBIAN_LATIN,
    wxLANGUAGE_SERBO_CROATIAN,
    wxLANGUAGE_SESOTHO,
    wxLANGUAGE_SETSWANA,
    wxLANGUAGE_SHONA,
    wxLANGUAGE_SINDHI,
    wxLANGUAGE_SINHALESE,
    wxLANGUAGE_SISWATI,
    wxLANGUAGE_SLOVAK,
    wxLANGUAGE_SLOVENIAN,
    wxLANGUAGE_SOMALI,
    wxLANGUAGE_SPANISH,
    wxLANGUAGE_SPANISH_ARGENTINA,
    wxLANGUAGE_SPANISH_BOLIVIA,
    wxLANGUAGE_SPANISH_CHILE,
    wxLANGUAGE_SPANISH_COLOMBIA,
    wxLANGUAGE_SPANISH_COSTA_RICA,
    wxLANGUAGE_SPANISH_DOMINICAN_REPUBLIC,
    wxLANGUAGE_SPANISH_ECUADOR,
    wxLANGUAGE_SPANISH_EL_SALVADOR,
    wxLANGUAGE_SPANISH_GUATEMALA,
    wxLANGUAGE_SPANISH_HONDURAS,
    wxLANGUAGE_SPANISH_MEXICAN,
    wxLANGUAGE_SPANISH_MODERN,
    wxLANGUAGE_SPANISH_NICARAGUA,
    wxLANGUAGE_SPANISH_PANAMA,
    wxLANGUAGE_SPANISH_PARAGUAY,
    wxLANGUAGE_SPANISH_PERU,
    wxLANGUAGE_SPANISH_PUERTO_RICO,
    wxLANGUAGE_SPANISH_URUGUAY,
    wxLANGUAGE_SPANISH_US,
    wxLANGUAGE_SPANISH_VENEZUELA,
    wxLANGUAGE_SUNDANESE,
    wxLANGUAGE_SWAHILI,
    wxLANGUAGE_SWEDISH,
    wxLANGUAGE_SWEDISH_FINLAND,
    wxLANGUAGE_TAGALOG,
    wxLANGUAGE_TAJIK,
    wxLANGUAGE_TAMIL,
    wxLANGUAGE_TATAR,
    wxLANGUAGE_TELUGU,
    wxLANGUAGE_THAI,
    wxLANGUAGE_TIBETAN,
    wxLANGUAGE_TIGRINYA,
    wxLANGUAGE_TONGA,
    wxLANGUAGE_TSONGA,
    wxLANGUAGE_TURKISH,
    wxLANGUAGE_TURKMEN,
    wxLANGUAGE_TWI,
    wxLANGUAGE_UIGHUR,
    wxLANGUAGE_UKRAINIAN,
    wxLANGUAGE_URDU,
    wxLANGUAGE_URDU_INDIA,
    wxLANGUAGE_URDU_PAKISTAN,
    wxLANGUAGE_UZBEK,
    wxLANGUAGE_UZBEK_CYRILLIC,
    wxLANGUAGE_UZBEK_LATIN,
    wxLANGUAGE_VALENCIAN,
    wxLANGUAGE_VIETNAMESE,
    wxLANGUAGE_VOLAPUK,
    wxLANGUAGE_WELSH,
    wxLANGUAGE_WOLOF,
    wxLANGUAGE_XHOSA,
    wxLANGUAGE_YIDDISH,
    wxLANGUAGE_YORUBA,
    wxLANGUAGE_ZHUANG,
    wxLANGUAGE_ZULU,
    wxLANGUAGE_KABYLE,


    wxLANGUAGE_USER_DEFINED
};
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 1
# 31 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/checkeddelete.h" 1
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 2





template <class T>
class wxScopedPtr
{
public:
    typedef T element_type;

    explicit wxScopedPtr(T * ptr = 
# 43 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
                                    __null
# 43 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
                                        ) : m_ptr(ptr) { }

    ~wxScopedPtr() { do { typedef char complete[sizeof(*m_ptr)] __attribute__ ((unused)); delete m_ptr; } while ( (void)0, 0 ); }
# 54 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
    typedef T *(wxScopedPtr<T>::*unspecified_bool_type)() const;

    operator unspecified_bool_type() const
    {
        return m_ptr ? &wxScopedPtr<T>::get : 
# 58 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
                                             __null
# 58 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
                                                 ;
    }

    void reset(T * ptr = 
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
                        __null
# 61 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
                            )
    {
        if ( ptr != m_ptr )
        {
            do { typedef char complete[sizeof(*m_ptr)] __attribute__ ((unused)); delete m_ptr; } while ( (void)0, 0 );
            m_ptr = ptr;
        }
    }

    T *release()
    {
        T *ptr = m_ptr;
        m_ptr = 
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
               __null
# 73 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
                   ;
        return ptr;
    }

    T & operator*() const
    {
        do { if ( wxTheAssertHandler && !(m_ptr != 
# 79 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
       __null
# 79 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
       ) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h", 79, __FUNCTION__, "m_ptr != __null", (const char*)
# 79 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
       __null
# 79 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return *m_ptr;
    }

    T * operator->() const
    {
        do { if ( wxTheAssertHandler && !(m_ptr != 
# 85 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
       __null
# 85 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
       ) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h", 85, __FUNCTION__, "m_ptr != __null", (const char*)
# 85 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h" 3 4
       __null
# 85 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/scopedptr.h"
       ), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 );
        return m_ptr;
    }

    T * get() const
    {
        return m_ptr;
    }

    void swap(wxScopedPtr& other)
    {
        T * const tmp = other.m_ptr;
        other.m_ptr = m_ptr;
        m_ptr = tmp;
    }

private:
    T * m_ptr;

    private: wxScopedPtr(const wxScopedPtr<T>&); wxScopedPtr& operator=(const wxScopedPtr<T>&);
};
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 2
# 50 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
class wxArrayString;
class wxTranslationsLoader;
class wxLocale;

class wxPluralFormsCalculator;
class wxPluralFormsCalculatorPtr { private: wxPluralFormsCalculator * m_ptr; wxPluralFormsCalculatorPtr(wxPluralFormsCalculatorPtr const &); wxPluralFormsCalculatorPtr & operator=(wxPluralFormsCalculatorPtr const &); public: explicit wxPluralFormsCalculatorPtr(wxPluralFormsCalculator * ptr = 
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
) : m_ptr(ptr) { } ~wxPluralFormsCalculatorPtr(); void reset(wxPluralFormsCalculator * ptr = 
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
); wxPluralFormsCalculator *release() { wxPluralFormsCalculator *ptr = m_ptr; m_ptr = 
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
; return ptr; } wxPluralFormsCalculator & operator*() const { do { if ( wxTheAssertHandler && !(m_ptr != 
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h", 55, __FUNCTION__, "m_ptr != __null", (const char*)
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return *m_ptr; } wxPluralFormsCalculator * operator->() const { do { if ( wxTheAssertHandler && !(m_ptr != 
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h", 55, __FUNCTION__, "m_ptr != __null", (const char*)
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
__null
# 55 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return m_ptr; } wxPluralFormsCalculator * get() const { return m_ptr; } void swap(wxPluralFormsCalculatorPtr & ot) { wxPluralFormsCalculator * tmp = ot.m_ptr; ot.m_ptr = m_ptr; m_ptr = tmp; } };





class wxMsgCatalog
{
public:
# 72 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
    static wxMsgCatalog *CreateFromFile(const wxString& filename,
                                        const wxString& domain);

    static wxMsgCatalog *CreateFromData(const wxScopedCharBuffer& data,
                                        const wxString& domain);


    wxString GetDomain() const { return m_domain; }


    const wxString *GetString(const wxString& sz, unsigned n = 
# 82 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
                                                              (0x7fffffff * 2U + 1U)
# 82 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
                                                                      ) const;

protected:
    wxMsgCatalog(const wxString& domain)
        : m_pNext(
# 86 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
                 __null
# 86 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
                     ), m_domain(domain)



    {}

private:

    wxMsgCatalog *m_pNext;
    friend class wxTranslations;

    wxStringToStringHashMap m_messages;
    wxString m_domain;







    wxPluralFormsCalculatorPtr m_pluralFormsCalculator;
};






class wxTranslations
{
public:
    wxTranslations();
    ~wxTranslations();


    static wxTranslations *Get();

    static void Set(wxTranslations *t);


    void SetLoader(wxTranslationsLoader *loader);

    void SetLanguage(wxLanguage lang);
    void SetLanguage(const wxString& lang);


    wxArrayString GetAvailableTranslations(const wxString& domain) const;


    wxString GetBestTranslation(const wxString& domain, wxLanguage msgIdLanguage);
    wxString GetBestTranslation(const wxString& domain,
                                const wxString& msgIdLanguage = "en");


    bool AddStdCatalog();



    bool AddCatalog(const wxString& domain);
    bool AddCatalog(const wxString& domain, wxLanguage msgIdLanguage);







    bool IsLoaded(const wxString& domain) const;


    const wxString *GetTranslatedString(const wxString& origString,
                                        const wxString& domain = wxEmptyString) const;
    const wxString *GetTranslatedString(const wxString& origString,
                                        unsigned n,
                                        const wxString& domain = wxEmptyString) const;

    wxString GetHeaderValue(const wxString& header,
                            const wxString& domain = wxEmptyString) const;




    static const wxString& GetUntranslatedString(const wxString& str);

private:

    bool LoadCatalog(const wxString& domain, const wxString& lang, const wxString& msgIdLang);


    wxMsgCatalog *FindCatalog(const wxString& domain) const;


    static void SetNonOwned(wxTranslations *t);
    friend class wxLocale;

private:
    wxString m_lang;
    wxTranslationsLoader *m_loader;

    wxMsgCatalog *m_pMsgCat;
};



class wxTranslationsLoader
{
public:
    wxTranslationsLoader() {}
    virtual ~wxTranslationsLoader() {}

    virtual wxMsgCatalog *LoadCatalog(const wxString& domain,
                                      const wxString& lang) = 0;

    virtual wxArrayString GetAvailableTranslations(const wxString& domain) const = 0;
};



class wxFileTranslationsLoader
    : public wxTranslationsLoader
{
public:
    static void AddCatalogLookupPathPrefix(const wxString& prefix);

    virtual wxMsgCatalog *LoadCatalog(const wxString& domain,
                                      const wxString& lang);

    virtual wxArrayString GetAvailableTranslations(const wxString& domain) const;
};




class wxResourceTranslationsLoader
    : public wxTranslationsLoader
{
public:
    virtual wxMsgCatalog *LoadCatalog(const wxString& domain,
                                      const wxString& lang);

    virtual wxArrayString GetAvailableTranslations(const wxString& domain) const;

protected:

    virtual wxString GetResourceType() const { return "MOFILE"; }


    virtual WXHINSTANCE GetModule() const { return 0; }
};
# 243 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
inline const wxString& wxGetTranslation(const wxString& str,
                                        const wxString& domain = wxString())
{
    wxTranslations *trans = wxTranslations::Get();
    const wxString *transStr = trans ? trans->GetTranslatedString(str, domain)
                                     : 
# 248 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
                                      __null
# 248 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
                                          ;
    if ( transStr )
        return *transStr;
    else


        return wxTranslations::GetUntranslatedString(str);
}

inline const wxString& wxGetTranslation(const wxString& str1,
                                        const wxString& str2,
                                        unsigned n,
                                        const wxString& domain = wxString())
{
    wxTranslations *trans = wxTranslations::Get();
    const wxString *transStr = trans ? trans->GetTranslatedString(str1, n, domain)
                                     : 
# 264 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h" 3 4
                                      __null
# 264 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/translation.h"
                                          ;
    if ( transStr )
        return *transStr;
    else


        return n == 1
               ? wxTranslations::GetUntranslatedString(str1)
               : wxTranslations::GetUntranslatedString(str2);
}
# 18 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h" 2




enum wxLayoutDirection
{
    wxLayout_Default,
    wxLayout_LeftToRight,
    wxLayout_RightToLeft
};
# 46 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
class wxLocale;
class wxLanguageInfoArray;
# 58 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
struct wxLanguageInfo
{
    int Language;
    wxString CanonicalName;

    wxUint32 WinLang,
             WinSublang;

    wxString Description;
    wxLayoutDirection LayoutDirection;



    wxUint32 GetLCID() const;




    wxString GetLocaleName() const;
};
# 90 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
enum wxLocaleCategory
{

    wxLOCALE_CAT_NUMBER,


    wxLOCALE_CAT_DATE,


    wxLOCALE_CAT_MONEY,



    wxLOCALE_CAT_DEFAULT,

    wxLOCALE_CAT_MAX
};





enum wxLocaleInfo
{

    wxLOCALE_THOUSANDS_SEP,


    wxLOCALE_DECIMAL_POINT,






    wxLOCALE_SHORT_DATE_FMT,
    wxLOCALE_LONG_DATE_FMT,
    wxLOCALE_DATE_TIME_FMT,
    wxLOCALE_TIME_FMT

};






enum wxLocaleInitFlags
{
    wxLOCALE_DONT_LOAD_DEFAULT = 0x0000,
    wxLOCALE_LOAD_DEFAULT = 0x0001

   ,wxLOCALE_CONV_ENCODING = 0x0002


};

class wxLocale
{
public:




    wxLocale() { DoCommonInit(); }


    wxLocale(const wxString& name,
             const wxString& shortName = wxEmptyString,
             const wxString& locale = wxEmptyString,
             bool bLoadDefault = true

             ,bool bConvertEncoding = true

             )
        {
            DoCommonInit();


            Init(name, shortName, locale, bLoadDefault, bConvertEncoding);



        }

    wxLocale(int language,
             int flags = wxLOCALE_LOAD_DEFAULT)
        {
            DoCommonInit();

            Init(language, flags);
        }


    bool Init(const wxString& name,
              const wxString& shortName = wxEmptyString,
              const wxString& locale = wxEmptyString,
              bool bLoadDefault = true

              ,bool bConvertEncoding = true

              );


    bool Init(int language = wxLANGUAGE_DEFAULT,
              int flags = wxLOCALE_LOAD_DEFAULT);


    virtual ~wxLocale();



    static int GetSystemLanguage();



    static wxFontEncoding GetSystemEncoding();



    static wxString GetSystemEncodingName();



    static wxString GetInfo(wxLocaleInfo index,
                            wxLocaleCategory cat = wxLOCALE_CAT_DEFAULT);


    bool IsOk() const { return m_pszOldLocale != 
# 218 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h" 3 4
                                                __null
# 218 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
                                                    ; }


    const wxString& GetLocale() const { return m_strLocale; }


    int GetLanguage() const { return m_language; }


    wxString GetSysName() const;




    wxString GetCanonicalName() const { return m_strShort; }






    static void AddCatalogLookupPathPrefix(const wxString& prefix)
        { wxFileTranslationsLoader::AddCatalogLookupPathPrefix(prefix); }
# 249 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
    bool AddCatalog(const wxString& domain);
    bool AddCatalog(const wxString& domain, wxLanguage msgIdLanguage);
    bool AddCatalog(const wxString& domain,
                    wxLanguage msgIdLanguage, const wxString& msgIdCharset);


    static bool IsAvailable(int lang);


    bool IsLoaded(const wxString& domain) const;




    static const wxLanguageInfo *GetLanguageInfo(int lang);



    static wxString GetLanguageName(int lang);



    static wxString GetLanguageCanonicalName(int lang);






    static const wxLanguageInfo *FindLanguageInfo(const wxString& locale);




    static void AddLanguage(const wxLanguageInfo& info);
# 296 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/intl.h"
    const wxString& GetString(const wxString& origString,
                              const wxString& domain = wxEmptyString) const
    {
        return wxGetTranslation(origString, domain);
    }

    const wxString& GetString(const wxString& origString,
                              const wxString& origString2,
                              unsigned n,
                              const wxString& domain = wxEmptyString) const
    {
        return wxGetTranslation(origString, origString2, n, domain);
    }


    const wxString& GetName() const { return m_strShort; }


    wxString GetHeaderValue(const wxString& header,
                            const wxString& domain = wxEmptyString) const;




    static void CreateLanguagesDB();
    static void DestroyLanguagesDB();

private:
    bool DoInit(const wxString& name,
                const wxString& shortName,
                const wxString& locale);



    static void InitLanguagesDB();


    void DoCommonInit();

    wxString m_strLocale,
                   m_strShort;
    int m_language;

    const char *m_pszOldLocale;
    wxLocale *m_pOldLocale;

    bool m_initialized;

    wxTranslations m_translations;

    static wxLanguageInfoArray *ms_languagesDB;

    private: wxLocale(const wxLocale&); wxLocale& operator=(const wxLocale&);
};






extern wxLocale* wxGetLocale();
# 28 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2

# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/validate.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/validate.h"
class wxWindow;
class wxWindowBase;
# 35 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/validate.h"
class wxValidator : public wxEvtHandler
{
public:
    wxValidator();
    wxValidator(const wxValidator& other)
        : wxEvtHandler()
        , m_validatorWindow(other.m_validatorWindow)
    {
    }
    virtual ~wxValidator();





    virtual wxObject *Clone() const
        { return 
# 51 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/validate.h" 3 4
                __null
# 51 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/validate.h"
                    ; }
    bool Copy(const wxValidator& val)
        { m_validatorWindow = val.m_validatorWindow; return true; }



    virtual bool Validate(wxWindow *) { return false; }


    virtual bool TransferToWindow() { return false; }


    virtual bool TransferFromWindow() { return false; }


    wxWindow *GetWindow() const { return (wxWindow *)m_validatorWindow; }
    void SetWindow(wxWindowBase *win) { m_validatorWindow = win; }



    static void SuppressBellOnError(bool suppress = true)
        { ms_isSilent = suppress; }


    static bool IsSilent() { return ms_isSilent; }





    static __attribute__((deprecated)) void SetBellOnError(bool doIt = true) { ms_isSilent = doIt; }





protected:
    wxWindowBase *m_validatorWindow;

private:
    static bool ms_isSilent;

    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxValidator& operator=(const wxValidator&);
};

extern const wxValidator wxDefaultValidator;
# 30 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/palette.h" 1
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/palette.h"
class wxPaletteBase: public wxGDIObject
{
public:
    virtual ~wxPaletteBase() { }

    virtual int GetColoursCount() const { do { if ( wxTheAssertHandler && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/palette.h", 27, __FUNCTION__, "Assert failure", L"not implemented"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); return 0; }
};


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/palette.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/palette.h"
class wxPalette : public wxPaletteBase
{
public:
    wxPalette() { }
    wxPalette(int n,
              const unsigned char *red, const unsigned char *green, const unsigned char *blue)
    {
        Create(n, red, green, blue);
    }

    bool Create(int n,
                const unsigned char *red, const unsigned char *green, const unsigned char *blue);

    virtual int GetColoursCount() const;

    int
    GetPixel(unsigned char red, unsigned char green, unsigned char blue) const;

    bool
    GetRGB(int pixel,
           unsigned char *red, unsigned char *green, unsigned char *blue) const;


    WXHPALETTE GetHPALETTE() const;
    void SetHPALETTE(WXHPALETTE pal);

protected:
    virtual wxGDIRefData *CreateGDIRefData() const;
    virtual wxGDIRefData *CloneGDIRefData(const wxGDIRefData *data) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/palette.h" 2
# 33 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2



# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h" 1
# 20 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
class wxAcceleratorTable;
class wxMenuItem;
class wxKeyEvent;






enum wxAcceleratorEntryFlags
{
    wxACCEL_NORMAL = 0x0000,
    wxACCEL_ALT = 0x0001,
    wxACCEL_CTRL = 0x0002,
    wxACCEL_SHIFT = 0x0004,



    wxACCEL_RAW_CTRL= wxACCEL_CTRL,

    wxACCEL_CMD = wxACCEL_CTRL
};





class wxAcceleratorEntry
{
public:
    wxAcceleratorEntry(int flags = 0, int keyCode = 0, int cmd = 0,
                       wxMenuItem *item = 
# 51 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h" 3 4
                                         __null
# 51 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
                                             )
        : m_flags(flags)
        , m_keyCode(keyCode)
        , m_command(cmd)
        , m_item(item)
        { }

    wxAcceleratorEntry(const wxAcceleratorEntry& entry)
        : m_flags(entry.m_flags)
        , m_keyCode(entry.m_keyCode)
        , m_command(entry.m_command)
        , m_item(entry.m_item)
        { }



    static wxAcceleratorEntry *Create(const wxString& str);

    wxAcceleratorEntry& operator=(const wxAcceleratorEntry& entry)
    {
        if (&entry != this)
            Set(entry.m_flags, entry.m_keyCode, entry.m_command, entry.m_item);
        return *this;
    }

    void Set(int flags, int keyCode, int cmd, wxMenuItem *item = 
# 76 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h" 3 4
                                                                __null
# 76 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
                                                                    )
    {
        m_flags = flags;
        m_keyCode = keyCode;
        m_command = cmd;
        m_item = item;
    }

    void SetMenuItem(wxMenuItem *item) { m_item = item; }

    int GetFlags() const { return m_flags; }
    int GetKeyCode() const { return m_keyCode; }
    int GetCommand() const { return m_command; }

    wxMenuItem *GetMenuItem() const { return m_item; }

    bool operator==(const wxAcceleratorEntry& entry) const
    {
        return m_flags == entry.m_flags &&
               m_keyCode == entry.m_keyCode &&
               m_command == entry.m_command &&
               m_item == entry.m_item;
    }

    bool operator!=(const wxAcceleratorEntry& entry) const
        { return !(*this == entry); }






    bool IsOk() const
    {
        return m_keyCode != 0;
    }
# 120 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
    wxString ToString() const { return AsPossiblyLocalizedString(true); }




    wxString ToRawString() const { return AsPossiblyLocalizedString(false); }



    bool FromString(const wxString& str);


private:
    wxString AsPossiblyLocalizedString(bool localized) const;


    static bool ParseAccel(const wxString& str, int *flags, int *keycode);


    int m_flags;
    int m_keyCode;
    int m_command;


    wxMenuItem *m_item;


    friend class wxMenu;
};
# 158 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/accel.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/accel.h"
class wxWindow;





class wxAcceleratorTable : public wxObject
{
public:

    wxAcceleratorTable() { }


    wxAcceleratorTable(const wxString& resource);


    wxAcceleratorTable(int n, const wxAcceleratorEntry entries[]);

    bool Ok() const { return IsOk(); }
    bool IsOk() const;
    void SetHACCEL(WXHACCEL hAccel);
    WXHACCEL GetHACCEL() const;


    bool Translate(wxWindow *window, WXMSG *msg) const;

private:
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 159 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h" 2
# 173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/accel.h"
extern wxAcceleratorTable wxNullAcceleratorTable;
# 37 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2
# 75 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
class wxCaret;
class wxControl;
class wxCursor;
class wxDC;
class wxDropTarget;
class wxLayoutConstraints;
class wxSizer;
class wxToolTip;
class wxWindowBase;
class wxWindow;
class wxScrollHelper;
# 96 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
struct wxVisualAttributes
{

    wxFont font;


    wxColour colFg;



    wxColour colBg;
};



enum wxWindowVariant
{
    wxWINDOW_VARIANT_NORMAL,
    wxWINDOW_VARIANT_SMALL,
    wxWINDOW_VARIANT_MINI,
    wxWINDOW_VARIANT_LARGE,
    wxWINDOW_VARIANT_MAX
};






enum wxShowEffect
{
    wxSHOW_EFFECT_NONE,
    wxSHOW_EFFECT_ROLL_TO_LEFT,
    wxSHOW_EFFECT_ROLL_TO_RIGHT,
    wxSHOW_EFFECT_ROLL_TO_TOP,
    wxSHOW_EFFECT_ROLL_TO_BOTTOM,
    wxSHOW_EFFECT_SLIDE_TO_LEFT,
    wxSHOW_EFFECT_SLIDE_TO_RIGHT,
    wxSHOW_EFFECT_SLIDE_TO_TOP,
    wxSHOW_EFFECT_SLIDE_TO_BOTTOM,
    wxSHOW_EFFECT_BLEND,
    wxSHOW_EFFECT_EXPAND,
    wxSHOW_EFFECT_MAX
};


enum
{
    wxSEND_EVENT_POST = 1
};





typedef int (*wxSortFuncFor_wxWindowList)(const wxWindow **, const wxWindow **); class wxWindowListNode : public wxNodeBase { public: wxWindowListNode(wxListBase *list = 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, wxWindowListNode *previous = 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, wxWindowListNode *next = 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, wxWindow *data = 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, const wxListKey& key = wxDefaultListKey) : wxNodeBase(list, previous, next, data, key) { } wxWindowListNode *GetNext() const { return (wxWindowListNode *)wxNodeBase::GetNext(); } wxWindowListNode *GetPrevious() const { return (wxWindowListNode *)wxNodeBase::GetPrevious(); } wxWindow *GetData() const { return (wxWindow *)wxNodeBase::GetData(); } void SetData(wxWindow *data) { wxNodeBase::SetData(data); } protected: virtual void DeleteData(); private: wxWindowListNode(const wxWindowListNode&); wxWindowListNode& operator=(const wxWindowListNode&); }; class wxWindowList : public wxListBase { public: typedef wxWindowListNode Node; class compatibility_iterator { public: compatibility_iterator(Node *ptr = 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
) : m_ptr(ptr) { } Node *operator->() const { return m_ptr; } operator Node *() const { return m_ptr; } private: Node *m_ptr; }; wxWindowList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType) { } wxWindowList(const wxWindowList& list) : wxListBase(list.GetKeyType()) { Assign(list); } wxWindowList(size_t count, wxWindow *elements[]) : wxListBase(count, (void **)elements) { } wxWindowList& operator=(const wxWindowList& list) { if (&list != this) Assign(list); return *this; } wxWindowListNode *GetFirst() const { return (wxWindowListNode *)wxListBase::GetFirst(); } wxWindowListNode *GetLast() const { return (wxWindowListNode *)wxListBase::GetLast(); } wxWindowListNode *Item(size_t index) const { return (wxWindowListNode *)wxListBase::Item(index); } wxWindow *operator[](size_t index) const { wxWindowListNode *node = Item(index); return node ? (wxWindow*)(node->GetData()) : 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
; } wxWindowListNode *Append(wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Append(object); } wxWindowListNode *Insert(wxWindowBase *object) { return (wxWindowListNode *)Insert(static_cast<wxWindowListNode *>(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
), object); } wxWindowListNode *Insert(size_t pos, wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Insert(pos, object); } wxWindowListNode *Insert(wxWindowListNode *prev, wxWindowBase *object) { return (wxWindowListNode *)wxListBase::Insert(prev, object); } wxWindowListNode *Append(long key, void *object) { return (wxWindowListNode *)wxListBase::Append(key, object); } wxWindowListNode *Append(const wxChar *key, void *object) { return (wxWindowListNode *)wxListBase::Append(key, object); } wxWindowListNode *DetachNode(wxWindowListNode *node) { return (wxWindowListNode *)wxListBase::DetachNode(node); } bool DeleteNode(wxWindowListNode *node) { return wxListBase::DeleteNode(node); } bool DeleteObject(wxWindowBase *object) { return wxListBase::DeleteObject(object); } void Erase(wxWindowListNode *it) { DeleteNode(it); } wxWindowListNode *Find(const wxWindowBase *object) const { return (wxWindowListNode *)wxListBase::Find(object); } virtual wxWindowListNode *Find(const wxListKey& key) const { return (wxWindowListNode *)wxListBase::Find(key); } bool Member(const wxWindowBase *object) const { return Find(object) != 
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
; } int IndexOf(wxWindowBase *object) const { return wxListBase::IndexOf(object); } void Sort(wxSortCompareFunction func) { wxListBase::Sort(func); } void Sort(wxSortFuncFor_wxWindowList func) { Sort((wxSortCompareFunction)func); } protected: virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next, void *data, const wxListKey& key = wxDefaultListKey) { return new wxWindowListNode(this, (wxWindowListNode *)prev, (wxWindowListNode *)next, (wxWindow *)data, key); } public: typedef size_t size_type; typedef int difference_type; typedef wxWindow* value_type; typedef wxWindowBase* base_value_type; typedef value_type& reference; typedef const value_type& const_reference; typedef base_value_type& base_reference; typedef const base_value_type& const_base_reference; class iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef iterator itor; typedef wxWindow* value_type; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; iterator(Node* node, Node* init) : m_node(node), m_init(init) {} iterator() : m_node(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
), m_init(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h", 151, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h", 151, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef const value_type& const_reference; typedef const_iterator itor; typedef value_type* ptr_type; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_iterator() : m_node(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
), m_init(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
) { } const_iterator(const iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h", 151, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return *this; } const itor operator++(int) { itor tmp = *this; do { if ( wxTheAssertHandler && !(m_node) && (wxOnAssert("..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h", 151, __FUNCTION__, "m_node", L"uninitialized iterator"), wxTrapInAssert) ) { wxTrapInAssert = false; wxTrap(); } } while ( (void)0, 0 ); m_node = m_node->GetNext(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetPrevious() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetPrevious() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class reverse_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef reverse_iterator itor; typedef value_type* ptr_type; typedef value_type& reference; Node* m_node; Node* m_init; public: typedef reference reference_type; typedef ptr_type pointer_type; reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } reverse_iterator() : m_node(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
), m_init(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this; } const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; class const_reverse_iterator { typedef wxWindowList list; public: typedef wxWindowListNode Node; typedef wxWindow* value_type; typedef const_reverse_iterator itor; typedef value_type* ptr_type; typedef const value_type& const_reference; Node* m_node; Node* m_init; public: typedef const_reference reference_type; typedef const value_type* pointer_type; const_reverse_iterator(Node* node, Node* init) : m_node(node), m_init(init) { } const_reverse_iterator() : m_node(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
), m_init(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
) { } const_reverse_iterator(const reverse_iterator& it) : m_node(it.m_node), m_init(it.m_init) { } reference_type operator*() const { return *(pointer_type)m_node->GetDataPtr(); } itor& operator++() { m_node = m_node->GetPrevious(); return *this; } const itor operator++(int) { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; } itor& operator--() { m_node = m_node ? m_node->GetNext() : m_init; return *this;} const itor operator--(int) { itor tmp = *this; m_node = m_node ? m_node->GetNext() : m_init; return tmp; } bool operator!=(const itor& it) const { return it.m_node != m_node; } bool operator==(const itor& it) const { return it.m_node == m_node; } }; explicit wxWindowList(size_type n, const_reference v = value_type()) { assign(n, v); } wxWindowList(const const_iterator& first, const const_iterator& last) { assign(first, last); } iterator begin() { return iterator(GetFirst(), GetLast()); } const_iterator begin() const { return const_iterator(GetFirst(), GetLast()); } iterator end() { return iterator(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, GetLast()); } const_iterator end() const { return const_iterator(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, GetLast()); } reverse_iterator rbegin() { return reverse_iterator(GetLast(), GetFirst()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(GetLast(), GetFirst()); } reverse_iterator rend() { return reverse_iterator(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, GetFirst()); } const_reverse_iterator rend() const { return const_reverse_iterator(
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
__null
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
, GetFirst()); } void resize(size_type n, value_type v = value_type()) { while (n < size()) pop_back(); while (n > size()) push_back(v); } size_type size() const { return GetCount(); } size_type max_size() const { return 0x7fffffff; } bool empty() const { return IsEmpty(); } reference front() { return *begin(); } const_reference front() const { return *begin(); } reference back() { iterator tmp = end(); return *--tmp; } const_reference back() const { const_iterator tmp = end(); return *--tmp; } void push_front(const_reference v = value_type()) { Insert(GetFirst(), (const_base_reference)v); } void pop_front() { DeleteNode(GetFirst()); } void push_back(const_reference v = value_type()) { Append((const_base_reference)v); } void pop_back() { DeleteNode(GetLast()); } void assign(const_iterator first, const const_iterator& last) { clear(); for(; first != last; ++first) Append((const_base_reference)*first); } void assign(size_type n, const_reference v = value_type()) { clear(); for(size_type i = 0; i < n; ++i) Append((const_base_reference)v); } iterator insert(const iterator& it, const_reference v) { if ( it == end() ) { Append((const_base_reference)v); iterator itins(end()); return --itins; } else { Insert(it.m_node, (const_base_reference)v); iterator itins(it); return --itins; } } void insert(const iterator& it, size_type n, const_reference v) { for(size_type i = 0; i < n; ++i) insert(it, v); } void insert(const iterator& it, const_iterator first, const const_iterator& last) { for(; first != last; ++first) insert(it, *first); } iterator erase(const iterator& it) { iterator next = iterator(it.m_node->GetNext(), GetLast()); DeleteNode(it.m_node); return next; } iterator erase(const iterator& first, const iterator& last) { iterator next = last; if ( next != end() ) ++next; DeleteNodes(first.m_node, last.m_node); return next; } void clear() { Clear(); } void splice(const iterator& it, wxWindowList& l, const iterator& first, const iterator& last) { insert(it, first, last); l.erase(first, last); } void splice(const iterator& it, wxWindowList& l) { splice(it, l, l.begin(), l.end() ); } void splice(const iterator& it, wxWindowList& l, const iterator& first) { if ( it != first ) { insert(it, *first); l.erase(first); } } void remove(const_reference v) { DeleteObject((const_base_reference)v); } void reverse() { Reverse(); } };





extern wxWindowList wxTopLevelWindows;


extern wxList wxPendingDelete;
# 173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
class wxWindowBase : public wxEvtHandler
{
public:





    wxWindowBase() ;

    virtual ~wxWindowBase();






    bool Close( bool force = false );






    virtual bool Destroy();

    bool DestroyChildren();


    bool IsBeingDeleted() const;







    virtual void SetLabel(const wxString& label) = 0;
    virtual wxString GetLabel() const = 0;



    virtual void SetName( const wxString &name ) { m_windowName = name; }
    virtual wxString GetName() const { return m_windowName; }



    void SetWindowVariant(wxWindowVariant variant);
    wxWindowVariant GetWindowVariant() const { return m_windowVariant; }




    virtual wxLayoutDirection GetLayoutDirection() const
        { return wxLayout_Default; }
    virtual void SetLayoutDirection(wxLayoutDirection )
        { }



    virtual wxCoord AdjustForLayoutDirection(wxCoord x,
                                             wxCoord width,
                                             wxCoord widthTotal) const;




    void SetId( wxWindowID winid ) { m_windowId = winid; }
    wxWindowID GetId() const { return m_windowId; }





    static wxWindowID NewControlId(int count = 1)
    {
        return wxIdManager::ReserveId(count);
    }



    static void UnreserveControlId(wxWindowID id, int count = 1)
    {
        wxIdManager::UnreserveId(id, count);
    }






    void SetSize( int x, int y, int width, int height,
                  int sizeFlags = (0x0001|0x0002) )
        { DoSetSize(x, y, width, height, sizeFlags); }

    void SetSize( int width, int height )
        { DoSetSize( wxDefaultCoord, wxDefaultCoord, width, height, 0x0000 ); }

    void SetSize( const wxSize& size )
        { SetSize( size.x, size.y); }

    void SetSize(const wxRect& rect, int sizeFlags = (0x0001|0x0002))
        { DoSetSize(rect.x, rect.y, rect.width, rect.height, sizeFlags); }

    void Move(int x, int y, int flags = 0x0000)
        { DoSetSize(x, y, wxDefaultCoord, wxDefaultCoord, flags); }

    void Move(const wxPoint& pt, int flags = 0x0000)
        { Move(pt.x, pt.y, flags); }

    void SetPosition(const wxPoint& pt) { Move(pt); }


    virtual void Raise() = 0;
    virtual void Lower() = 0;


    void SetClientSize( int width, int height )
        { DoSetClientSize(width, height); }

    void SetClientSize( const wxSize& size )
        { DoSetClientSize(size.x, size.y); }

    void SetClientSize(const wxRect& rect)
        { SetClientSize( rect.width, rect.height ); }





    void GetPosition( int *x, int *y ) const { DoGetPosition(x, y); }
    wxPoint GetPosition() const
    {
        int x, y;
        DoGetPosition(&x, &y);

        return wxPoint(x, y);
    }


    void GetScreenPosition(int *x, int *y) const { DoGetScreenPosition(x, y); }
    wxPoint GetScreenPosition() const
    {
        int x, y;
        DoGetScreenPosition(&x, &y);

        return wxPoint(x, y);
    }


    void GetSize( int *w, int *h ) const { DoGetSize(w, h); }
    wxSize GetSize() const
    {
        int w, h;
        DoGetSize(& w, & h);
        return wxSize(w, h);
    }

    void GetClientSize( int *w, int *h ) const { DoGetClientSize(w, h); }
    wxSize GetClientSize() const
    {
        int w, h;
        DoGetClientSize(&w, &h);

        return wxSize(w, h);
    }


    wxRect GetRect() const
    {
        int x, y, w, h;
        GetPosition(&x, &y);
        GetSize(&w, &h);

        return wxRect(x, y, w, h);
    }

    wxRect GetScreenRect() const
    {
        int x, y, w, h;
        GetScreenPosition(&x, &y);
        GetSize(&w, &h);

        return wxRect(x, y, w, h);
    }




    virtual wxPoint GetClientAreaOrigin() const;


    wxRect GetClientRect() const
    {
        return wxRect(GetClientAreaOrigin(), GetClientSize());
    }


    virtual wxSize ClientToWindowSize(const wxSize& size) const;
    virtual wxSize WindowToClientSize(const wxSize& size) const;




    wxSize GetBestSize() const;

    void GetBestSize(int *w, int *h) const
    {
        wxSize s = GetBestSize();
        if ( w )
            *w = s.x;
        if ( h )
            *h = s.y;
    }




    int GetBestHeight(int width) const;
    int GetBestWidth(int height) const;


    void SetScrollHelper( wxScrollHelper *sh ) { m_scrollHelper = sh; }
    wxScrollHelper *GetScrollHelper() { return m_scrollHelper; }



    void InvalidateBestSize();
    void CacheBestSize(const wxSize& size) const
        { const_cast<wxWindowBase *>(this)->m_bestSizeCache = size; }





    virtual wxSize GetEffectiveMinSize() const;

    __attribute__((deprecated("use GetEffectiveMinSize() instead")))
    wxSize GetBestFittingSize() const;
    __attribute__((deprecated("use GetEffectiveMinSize() instead")))
    wxSize GetAdjustedMinSize() const;



    void SetInitialSize(const wxSize& size=wxDefaultSize);

    __attribute__((deprecated("use SetInitialSize() instead")))
    void SetBestFittingSize(const wxSize& size=wxDefaultSize);





    void Centre(int dir = wxBOTH) { DoCentre(dir); }
    void Center(int dir = wxBOTH) { DoCentre(dir); }


    void CentreOnParent(int dir = wxBOTH) { DoCentre(dir); }
    void CenterOnParent(int dir = wxBOTH) { CentreOnParent(dir); }


    virtual void Fit();


    virtual void FitInside();
# 446 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual void SetSizeHints( int minW, int minH,
                               int maxW = wxDefaultCoord, int maxH = wxDefaultCoord,
                               int incW = wxDefaultCoord, int incH = wxDefaultCoord )
    { DoSetSizeHints(minW, minH, maxW, maxH, incW, incH); }

    void SetSizeHints( const wxSize& minSize,
                       const wxSize& maxSize=wxDefaultSize,
                       const wxSize& incSize=wxDefaultSize)
    { DoSetSizeHints(minSize.x, minSize.y, maxSize.x, maxSize.y, incSize.x, incSize.y); }




    __attribute__((deprecated)) virtual void SetVirtualSizeHints( int minW, int minH, int maxW = wxDefaultCoord, int maxH = wxDefaultCoord )
                                                                                              ;
    __attribute__((deprecated)) void SetVirtualSizeHints( const wxSize& minSize, const wxSize& maxSize=wxDefaultSize)
                                                                                  ;






    virtual void SetMinSize(const wxSize& minSize);
    virtual void SetMaxSize(const wxSize& maxSize);


    virtual void SetMinClientSize(const wxSize& size)
        { SetMinSize(ClientToWindowSize(size)); }
    virtual void SetMaxClientSize(const wxSize& size)
        { SetMaxSize(ClientToWindowSize(size)); }




    virtual wxSize GetMinSize() const { return wxSize(m_minWidth, m_minHeight); }
    virtual wxSize GetMaxSize() const { return wxSize(m_maxWidth, m_maxHeight); }


    virtual wxSize GetMinClientSize() const
        { return WindowToClientSize(GetMinSize()); }
    virtual wxSize GetMaxClientSize() const
        { return WindowToClientSize(GetMaxSize()); }


    int GetMinWidth() const { return GetMinSize().x; }
    int GetMinHeight() const { return GetMinSize().y; }
    int GetMaxWidth() const { return GetMaxSize().x; }
    int GetMaxHeight() const { return GetMaxSize().y; }
# 503 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    void SetVirtualSize( const wxSize &size ) { DoSetVirtualSize( size.x, size.y ); }
    void SetVirtualSize( int x, int y ) { DoSetVirtualSize( x, y ); }

    wxSize GetVirtualSize() const { return DoGetVirtualSize(); }
    void GetVirtualSize( int *x, int *y ) const
    {
        wxSize s( DoGetVirtualSize() );

        if( x )
            *x = s.GetWidth();
        if( y )
            *y = s.GetHeight();
    }





    virtual void DoSetVirtualSize( int x, int y );
    virtual wxSize DoGetVirtualSize() const;




    virtual wxSize GetBestVirtualSize() const
    {
        wxSize client( GetClientSize() );
        wxSize best( GetBestSize() );

        return wxSize( wxMax( client.x, best.x ), wxMax( client.y, best.y ) );
    }



    virtual double GetContentScaleFactor() const
    { return 1.0; }



    virtual wxSize GetWindowBorderSize() const;







    virtual bool
    InformFirstDirection(int direction, int size, int availableOtherDir);







    virtual void SendSizeEvent(int flags = 0);






    void SendSizeEventToParent(int flags = 0);


    void PostSizeEvent() { SendSizeEvent(wxSEND_EVENT_POST); }


    void PostSizeEventToParent() { SendSizeEventToParent(wxSEND_EVENT_POST); }
# 581 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual bool BeginRepositioningChildren() { return false; }
    virtual void EndRepositioningChildren() { }




    class ChildrenRepositioningGuard
    {
    public:


        explicit ChildrenRepositioningGuard(wxWindowBase* win)
            : m_win(win),
              m_callEnd(win && win->BeginRepositioningChildren())
        {
        }

        ~ChildrenRepositioningGuard()
        {
            if ( m_callEnd )
                m_win->EndRepositioningChildren();
        }

    private:
        wxWindowBase* const m_win;
        const bool m_callEnd;

        private: ChildrenRepositioningGuard(const ChildrenRepositioningGuard&); ChildrenRepositioningGuard& operator=(const ChildrenRepositioningGuard&);
    };







    virtual bool Show( bool show = true );
    bool Hide() { return Show(false); }






    virtual bool ShowWithEffect(wxShowEffect ,
                                unsigned = 0)
    {
        return Show();
    }

    virtual bool HideWithEffect(wxShowEffect ,
                                unsigned = 0)
    {
        return Hide();
    }


    virtual bool Enable( bool enable = true );
    bool Disable() { return Enable(false); }

    virtual bool IsShown() const { return m_isShown; }
# 650 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    bool IsEnabled() const;





    bool IsThisEnabled() const { return m_isEnabled; }



    virtual bool IsShownOnScreen() const;



    virtual void SetWindowStyleFlag( long style ) { m_windowStyle = style; }
    virtual long GetWindowStyleFlag() const { return m_windowStyle; }


    void SetWindowStyle( long style ) { SetWindowStyleFlag(style); }
    long GetWindowStyle() const { return GetWindowStyleFlag(); }


    bool HasFlag(int flag) const { return (m_windowStyle & flag) != 0; }
    virtual bool IsRetained() const { return HasFlag(0x00000000); }



    bool ToggleWindowStyle(int flag);



    virtual void SetExtraStyle(long exStyle) { m_exStyle = exStyle; }
    long GetExtraStyle() const { return m_exStyle; }

    bool HasExtraStyle(int exFlag) const { return (m_exStyle & exFlag) != 0; }



    __attribute__((deprecated)) virtual void MakeModal(bool modal = true);





    virtual void SetThemeEnabled(bool enableTheme) { m_themeEnabled = enableTheme; }
    virtual bool GetThemeEnabled() const { return m_themeEnabled; }






    virtual void SetFocus() = 0;


    virtual void SetFocusFromKbd() { SetFocus(); }


    static wxWindow *FindFocus();

    static wxWindow *DoFindFocus() ;




    virtual bool HasFocus() const;
# 724 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual bool AcceptsFocus() const { return true; }





    virtual bool AcceptsFocusRecursively() const { return AcceptsFocus(); }




    virtual bool AcceptsFocusFromKeyboard() const { return AcceptsFocus(); }
# 744 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual bool CanBeFocused() const { return IsShown() && IsEnabled(); }


    bool IsFocusable() const { return AcceptsFocus() && CanBeFocused(); }






    bool CanAcceptFocus() const
        { return AcceptsFocusRecursively() && CanBeFocused(); }


    bool CanAcceptFocusFromKeyboard() const
        { return AcceptsFocusFromKeyboard() && CanBeFocused(); }


    virtual void SetCanFocus(bool ) { }


    bool NavigateIn(int flags = wxNavigationKeyEvent::IsForward)
        { return DoNavigateIn(flags); }



    bool Navigate(int flags = wxNavigationKeyEvent::IsForward)
        { return m_parent && ((wxWindowBase *)m_parent)->DoNavigateIn(flags); }




    bool HandleAsNavigationKey(const wxKeyEvent& event);



    void MoveBeforeInTabOrder(wxWindow *win)
        { DoMoveInTabOrder(win, OrderBefore); }
    void MoveAfterInTabOrder(wxWindow *win)
        { DoMoveInTabOrder(win, OrderAfter); }






    const wxWindowList& GetChildren() const { return m_children; }
    wxWindowList& GetChildren() { return m_children; }


    const wxWindowList& GetWindowChildren() const { return GetChildren() ; }



    wxWindow *GetPrevSibling() const { return DoGetSibling(OrderBefore); }
    wxWindow *GetNextSibling() const { return DoGetSibling(OrderAfter); }


    wxWindow *GetParent() const { return m_parent; }
    inline wxWindow *GetGrandParent() const;


    virtual bool IsTopLevel() const;



    bool IsDescendant(wxWindowBase* win) const;


    void SetParent( wxWindowBase *parent );


    virtual bool Reparent( wxWindowBase *newParent );


    virtual void AddChild( wxWindowBase *child );
    virtual void RemoveChild( wxWindowBase *child );



    virtual bool IsClientAreaChild(const wxWindow *) const
        { return true; }






    wxWindow *FindWindow(long winid) const;
    wxWindow *FindWindow(const wxString& name) const;


    static wxWindow *FindWindowById( long winid, const wxWindow *parent = 
# 836 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                                         __null 
# 836 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                                              );
    static wxWindow *FindWindowByName( const wxString& name,
                                       const wxWindow *parent = 
# 838 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                               __null 
# 838 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                                    );
    static wxWindow *FindWindowByLabel( const wxString& label,
                                        const wxWindow *parent = 
# 840 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                                __null 
# 840 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                                     );





    wxEvtHandler *GetEventHandler() const { return m_eventHandler; }



    void SetEventHandler( wxEvtHandler *handler );



    void PushEventHandler( wxEvtHandler *handler );
    wxEvtHandler *PopEventHandler( bool deleteHandler = false );






    bool RemoveEventHandler(wxEvtHandler *handler);





    bool ProcessWindowEvent(wxEvent& event)
        { return GetEventHandler()->ProcessEvent(event); }





    bool ProcessWindowEventLocally(wxEvent& event)
        { return GetEventHandler()->ProcessEventLocally(event); }






    bool HandleWindowEvent(wxEvent& event) const;


    virtual void SetNextHandler(wxEvtHandler *handler);
    virtual void SetPreviousHandler(wxEvtHandler *handler);





protected:
# 904 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    using wxEvtHandler::ProcessEvent;
    using wxEvtHandler::ProcessEventLocally;

    using wxEvtHandler::ProcessThreadEvent;

    using wxEvtHandler::SafelyProcessEvent;
    using wxEvtHandler::ProcessPendingEvents;
    using wxEvtHandler::AddPendingEvent;
    using wxEvtHandler::QueueEvent;


public:







    virtual void SetValidator( const wxValidator &validator );
    virtual wxValidator *GetValidator() { return m_windowValidator; }







    virtual bool Validate();


    virtual bool TransferDataToWindow();
    virtual bool TransferDataFromWindow();

    virtual void InitDialog();




    virtual void SetAcceleratorTable( const wxAcceleratorTable& accel )
        { m_acceleratorTable = accel; }
    wxAcceleratorTable *GetAcceleratorTable()
        { return &m_acceleratorTable; }







    virtual bool RegisterHotKey(int hotkeyId, int modifiers, int keycode);
    virtual bool UnregisterHotKey(int hotkeyId);






    wxPoint ConvertPixelsToDialog( const wxPoint& pt ) const;
    wxPoint ConvertDialogToPixels( const wxPoint& pt ) const;
    wxSize ConvertPixelsToDialog( const wxSize& sz ) const
    {
        wxPoint pt(ConvertPixelsToDialog(wxPoint(sz.x, sz.y)));

        return wxSize(pt.x, pt.y);
    }

    wxSize ConvertDialogToPixels( const wxSize& sz ) const
    {
        wxPoint pt(ConvertDialogToPixels(wxPoint(sz.x, sz.y)));

        return wxSize(pt.x, pt.y);
    }





    virtual void WarpPointer(int x, int y) = 0;





    void CaptureMouse();
    void ReleaseMouse();


    static wxWindow *GetCapture();


    virtual bool HasCapture() const
        { return (wxWindow *)this == GetCapture(); }






    virtual void Refresh( bool eraseBackground = true,
                          const wxRect *rect = (const wxRect *) 
# 1004 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                               __null 
# 1004 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                                    ) = 0;


    void RefreshRect(const wxRect& rect, bool eraseBackground = true)
    {
        Refresh(eraseBackground, &rect);
    }


    virtual void Update() { }


    virtual void ClearBackground();


    void Freeze();


    void Thaw();


    bool IsFrozen() const { return m_freezeCount != 0; }


    virtual void PrepareDC( wxDC & ) { }


    virtual bool IsDoubleBuffered() const { return false; }



    const wxRegion& GetUpdateRegion() const { return m_updateRegion; }
    wxRegion& GetUpdateRegion() { return m_updateRegion; }


    wxRect GetUpdateClientRect() const;



    virtual bool DoIsExposed( int x, int y ) const;
    virtual bool DoIsExposed( int x, int y, int w, int h ) const;

    bool IsExposed( int x, int y ) const
        { return DoIsExposed(x, y); }
    bool IsExposed( int x, int y, int w, int h ) const
    { return DoIsExposed(x, y, w, h); }
    bool IsExposed( const wxPoint& pt ) const
        { return DoIsExposed(pt.x, pt.y); }
    bool IsExposed( const wxRect& rect ) const
        { return DoIsExposed(rect.x, rect.y, rect.width, rect.height); }
# 1065 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual wxVisualAttributes GetDefaultAttributes() const
    {
        return GetClassDefaultAttributes(GetWindowVariant());
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);





    virtual bool SetBackgroundColour(const wxColour& colour);
    void SetOwnBackgroundColour(const wxColour& colour)
    {
        if ( SetBackgroundColour(colour) )
            m_inheritBgCol = false;
    }
    wxColour GetBackgroundColour() const;
    bool InheritsBackgroundColour() const
    {
        return m_inheritBgCol;
    }
    bool UseBgCol() const
    {
        return m_hasBgCol;
    }

    virtual bool SetForegroundColour(const wxColour& colour);
    void SetOwnForegroundColour(const wxColour& colour)
    {
        if ( SetForegroundColour(colour) )
            m_inheritFgCol = false;
    }
    wxColour GetForegroundColour() const;


    virtual bool SetBackgroundStyle(wxBackgroundStyle style);
    wxBackgroundStyle GetBackgroundStyle() const
        { return m_backgroundStyle; }




    virtual bool HasTransparentBackground() { return false; }






    virtual bool IsTransparentBackgroundSupported(wxString* reason = 
# 1116 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                                    __null
# 1116 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                                        ) const;



    virtual bool SetFont(const wxFont& font) = 0;
    void SetOwnFont(const wxFont& font)
    {
        if ( SetFont(font) )
            m_inheritFont = false;
    }
    wxFont GetFont() const;



    virtual bool SetCursor( const wxCursor &cursor );
    const wxCursor& GetCursor() const { return m_cursor; }



    void SetCaret(wxCaret *caret);

    wxCaret *GetCaret() const { return m_caret; }



    virtual int GetCharHeight() const = 0;
    virtual int GetCharWidth() const = 0;



    void GetTextExtent(const wxString& string,
                       int *x, int *y,
                       int *descent = 
# 1148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                     __null
# 1148 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                         ,
                       int *externalLeading = 
# 1149 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                             __null
# 1149 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                 ,
                       const wxFont *font = 
# 1150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                           __null
# 1150 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                               ) const
    {
        DoGetTextExtent(string, x, y, descent, externalLeading, font);
    }

    wxSize GetTextExtent(const wxString& string) const
    {
        wxCoord w, h;
        GetTextExtent(string, &w, &h);
        return wxSize(w, h);
    }





    void ClientToScreen( int *x, int *y ) const
        { DoClientToScreen(x, y); }
    void ScreenToClient( int *x, int *y ) const
        { DoScreenToClient(x, y); }


    wxPoint ClientToScreen(const wxPoint& pt) const
    {
        int x = pt.x, y = pt.y;
        DoClientToScreen(&x, &y);

        return wxPoint(x, y);
    }

    wxPoint ScreenToClient(const wxPoint& pt) const
    {
        int x = pt.x, y = pt.y;
        DoScreenToClient(&x, &y);

        return wxPoint(x, y);
    }


    wxHitTest HitTest(wxCoord x, wxCoord y) const
        { return DoHitTest(x, y); }

    wxHitTest HitTest(const wxPoint& pt) const
        { return DoHitTest(pt.x, pt.y); }







    wxBorder GetBorder(long flags) const;


    wxBorder GetBorder() const { return GetBorder(GetWindowStyleFlag()); }


    virtual void UpdateWindowUI(long flags = wxUPDATE_UI_NONE);


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event) ;




    bool PopupMenu(wxMenu *menu, const wxPoint& pos = wxDefaultPosition)
        { return PopupMenu(menu, pos.x, pos.y); }
    bool PopupMenu(wxMenu *menu, int x, int y);



    int GetPopupMenuSelectionFromUser(wxMenu& menu,
                                      const wxPoint& pos = wxDefaultPosition)
        { return DoGetPopupMenuSelectionFromUser(menu, pos.x, pos.y); }
    int GetPopupMenuSelectionFromUser(wxMenu& menu, int x, int y)
        { return DoGetPopupMenuSelectionFromUser(menu, x, y); }



    virtual bool HasMultiplePages() const { return false; }






    virtual bool CanScroll(int orient) const;


    bool HasScrollbar(int orient) const;


    virtual void SetScrollbar( int orient,
                               int pos,
                               int thumbvisible,
                               int range,
                               bool refresh = true ) = 0;
    virtual void SetScrollPos( int orient, int pos, bool refresh = true ) = 0;
    virtual int GetScrollPos( int orient ) const = 0;
    virtual int GetScrollThumb( int orient ) const = 0;
    virtual int GetScrollRange( int orient ) const = 0;


    virtual void ScrollWindow( int dx, int dy,
                               const wxRect* rect = 
# 1254 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                   __null 
# 1254 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                        ) = 0;




    virtual bool ScrollLines(int ) { return false; }
    virtual bool ScrollPages(int ) { return false; }


    bool LineUp() { return ScrollLines(-1); }
    bool LineDown() { return ScrollLines(1); }
    bool PageUp() { return ScrollPages(-1); }
    bool PageDown() { return ScrollPages(1); }



    virtual void AlwaysShowScrollbars(bool = true,
                                      bool = true)
    {
    }



    virtual bool IsScrollbarAlwaysShown(int ) const
    {
        return false;
    }
# 1289 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    void SetHelpText(const wxString& text);




    __attribute__((deprecated)) void SetHelpTextForId(const wxString& text);






    virtual wxString GetHelpTextAtPoint(const wxPoint& pt,
                                        wxHelpEvent::Origin origin) const;

    wxString GetHelpText() const
    {
        return GetHelpTextAtPoint(wxDefaultPosition, wxHelpEvent::Origin_Unknown);
    }
# 1320 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    void SetToolTip( const wxString &tip );


    void SetToolTip( wxToolTip *tip ) { DoSetToolTip(tip); }

    void UnsetToolTip() { SetToolTip(
# 1325 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                    __null
# 1325 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                        ); }

    wxToolTip* GetToolTip() const { return m_tooltip; }
    wxString GetToolTipText() const;
# 1337 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    bool CopyToolTip(wxToolTip *tip);
# 1350 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual void SetDropTarget( wxDropTarget *dropTarget ) = 0;
    virtual wxDropTarget *GetDropTarget() const { return m_dropTarget; }


    virtual void DragAcceptFiles(bool accept)



    = 0

    ;







    void SetConstraints( wxLayoutConstraints *constraints );
    wxLayoutConstraints *GetConstraints() const { return m_constraints; }


    void UnsetConstraints(wxLayoutConstraints *c);
    wxWindowList *GetConstraintsInvolvedIn() const
        { return m_constraintsInvolvedIn; }
    void AddConstraintReference(wxWindowBase *otherWin);
    void RemoveConstraintReference(wxWindowBase *otherWin);
    void DeleteRelatedConstraints();
    void ResetConstraints();


    virtual void SetConstraintSizes(bool recurse = true);
    virtual bool LayoutPhase1(int *noChanges);
    virtual bool LayoutPhase2(int *noChanges);
    virtual bool DoPhase(int phase);


    virtual void SetSizeConstraint(int x, int y, int w, int h);
    virtual void MoveConstraint(int x, int y);
    virtual void GetSizeConstraint(int *w, int *h) const ;
    virtual void GetClientSizeConstraint(int *w, int *h) const ;
    virtual void GetPositionConstraint(int *x, int *y) const ;






    void SetAutoLayout( bool autoLayout ) { m_autoLayout = autoLayout; }
    bool GetAutoLayout() const { return m_autoLayout; }


    virtual bool Layout();


    void SetSizer(wxSizer *sizer, bool deleteOld = true );
    void SetSizerAndFit( wxSizer *sizer, bool deleteOld = true );

    wxSizer *GetSizer() const { return m_windowSizer; }


    void SetContainingSizer(wxSizer* sizer);
    wxSizer *GetContainingSizer() const { return m_containingSizer; }
# 1432 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual bool SetTransparent(wxByte ) { return false; }
    virtual bool CanSetTransparent() { return false; }






    void OnSysColourChanged( wxSysColourChangedEvent& event );
    void OnInitDialog( wxInitDialogEvent &event );
    void OnMiddleClick( wxMouseEvent& event );

    void OnHelp(wxHelpEvent& event);




        virtual void OnInternalIdle();



    virtual bool SendIdleEvents(wxIdleEvent& event);




    virtual WXWidget GetHandle() const = 0;

    virtual void AssociateHandle(WXWidget ) { }

    virtual void DissociateHandle() { }




    wxPalette GetPalette() const { return m_palette; }



    void SetPalette(const wxPalette& pal);


    bool HasCustomPalette() const { return m_hasCustomPalette; }


    wxWindow *GetAncestorWithCustomPalette() const;





    virtual void InheritAttributes();






    virtual bool ShouldInheritColours() const { return false; }



    virtual bool CanBeOutsideClientArea() const { return false; }



    virtual bool CanApplyThemeBorder() const { return true; }




    virtual wxWindow *GetMainWindowOfCompositeControl()
        { return (wxWindow*)this; }







    virtual bool IsTopNavigationDomain() const { return false; }


protected:



    bool CreateBase(wxWindowBase *parent,
                    wxWindowID winid,
                    const wxPoint& pos = wxDefaultPosition,
                    const wxSize& size = wxDefaultSize,
                    long style = 0,
                    const wxValidator& validator = wxDefaultValidator,
                    const wxString& name = wxPanelNameStr);

    bool CreateBase(wxWindowBase *parent,
                    wxWindowID winid,
                    const wxPoint& pos,
                    const wxSize& size,
                    long style,
                    const wxString& name);


    virtual bool TryBefore(wxEvent& event);
    virtual bool TryAfter(wxEvent& event);

    enum WindowOrder
    {
        OrderBefore,
        OrderAfter
    };


    wxWindow *DoGetSibling(WindowOrder order) const;


    virtual void DoMoveInTabOrder(wxWindow *win, WindowOrder move);


    virtual bool DoNavigateIn(int flags);



    void SatisfyConstraints();




    void SendDestroyEvent();





    virtual void DoEnable(bool ) { }




    wxWindowIDRef m_windowId;



    wxWindow *m_parent;
    wxWindowList m_children;



    int m_minWidth,
                         m_minHeight,
                         m_maxWidth,
                         m_maxHeight;



    wxEvtHandler *m_eventHandler;



    wxValidator *m_windowValidator;



    wxDropTarget *m_dropTarget;



    wxCursor m_cursor;
    wxFont m_font;
    wxColour m_backgroundColour,
                         m_foregroundColour;


    wxCaret *m_caret;



    wxRegion m_updateRegion;




    wxAcceleratorTable m_acceleratorTable;




    wxToolTip *m_tooltip;





    wxLayoutConstraints *m_constraints;


    wxWindowList *m_constraintsInvolvedIn;



    wxSizer *m_windowSizer;


    wxSizer *m_containingSizer;


    bool m_autoLayout:1;


    bool m_isShown:1;
    bool m_isEnabled:1;
    bool m_isBeingDeleted:1;


    bool m_hasBgCol:1;
    bool m_hasFgCol:1;
    bool m_hasFont:1;


    bool m_inheritBgCol:1;
    bool m_inheritFgCol:1;
    bool m_inheritFont:1;


    long m_windowStyle,
                         m_exStyle;
    wxString m_windowName;
    bool m_themeEnabled;
    wxBackgroundStyle m_backgroundStyle;

    wxPalette m_palette;
    bool m_hasCustomPalette;







    wxSize m_virtualSize;

    wxScrollHelper *m_scrollHelper;

    wxWindowVariant m_windowVariant ;



    virtual wxBorder GetDefaultBorder() const;




    virtual wxBorder GetDefaultBorderForControl() const { return wxBORDER_THEME; }



    static int WidthDefault(int w) { return w == wxDefaultCoord ? 20 : w; }
    static int HeightDefault(int h) { return h == wxDefaultCoord ? 20 : h; }




    wxSize m_bestSizeCache;

    __attribute__((deprecated("use SetInitialSize() instead.")))
    void SetBestSize(const wxSize& size);
    __attribute__((deprecated("use SetInitialSize() instead.")))
    virtual void SetInitialBestSize(const wxSize& size);
# 1716 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual void DoGetTextExtent(const wxString& string,
                                 int *x, int *y,
                                 int *descent = 
# 1718 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                               __null
# 1718 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                   ,
                                 int *externalLeading = 
# 1719 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                       __null
# 1719 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                           ,
                                 const wxFont *font = 
# 1720 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                                     __null
# 1720 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                         ) const = 0;


    virtual void DoClientToScreen( int *x, int *y ) const = 0;
    virtual void DoScreenToClient( int *x, int *y ) const = 0;

    virtual wxHitTest DoHitTest(wxCoord x, wxCoord y) const;


    virtual void DoCaptureMouse() = 0;
    virtual void DoReleaseMouse() = 0;


    virtual void DoGetPosition(int *x, int *y) const = 0;
    virtual void DoGetScreenPosition(int *x, int *y) const;
    virtual void DoGetSize(int *width, int *height) const = 0;
    virtual void DoGetClientSize(int *width, int *height) const = 0;




    virtual wxSize DoGetBestSize() const;




    virtual wxSize DoGetBestClientSize() const { return wxDefaultSize; }




    virtual int DoGetBestClientHeight(int ) const
        { return wxDefaultCoord; }
    virtual int DoGetBestClientWidth(int ) const
        { return wxDefaultCoord; }




    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002)) = 0;


    virtual void DoSetClientSize(int width, int height) = 0;

    virtual void DoSetSizeHints( int minW, int minH,
                                 int maxW, int maxH,
                                 int incW, int incH );
# 1777 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual wxSize DoGetBorderSize() const;
# 1787 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
    virtual void DoMoveWindow(int x, int y, int width, int height) = 0;




    virtual void DoCentre(int dir);


    virtual void DoSetToolTip( wxToolTip *tip );



    virtual bool DoPopupMenu(wxMenu *menu, int x, int y) = 0;





    virtual void AdjustForParentClientOrigin(int& x, int& y,
                                             int sizeFlags = 0) const;


    virtual void DoSetWindowVariant( wxWindowVariant variant ) ;



    virtual void DoFreeze() { }
    virtual void DoThaw() { }




    static void NotifyCaptureLost();

private:



    void NotifyWindowOnEnableChange(bool enabled);



    void InternalOnPopupMenu(wxCommandEvent& event);
    void InternalOnPopupMenuUpdate(wxUpdateUIEvent& event);


    int DoGetPopupMenuSelectionFromUser(wxMenu& menu, int x, int y);




    void InternalOnSize(wxSizeEvent& event);


    wxSize GetDlgUnitBase() const;




    unsigned int m_freezeCount;


    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
    private: wxWindowBase(const wxWindowBase&); wxWindowBase& operator=(const wxWindowBase&);
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};




inline wxSize wxWindowBase::GetBestFittingSize() const
{
    return GetEffectiveMinSize();
}

inline void wxWindowBase::SetBestFittingSize(const wxSize& size)
{
    SetInitialSize(size);
}

inline void wxWindowBase::SetBestSize(const wxSize& size)
{
    SetInitialSize(size);
}

inline void wxWindowBase::SetInitialBestSize(const wxSize& size)
{
    SetInitialSize(size);
}
# 1889 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h"
class wxWindow;





enum wxSystemFont
{
    wxSYS_OEM_FIXED_FONT = 10,
    wxSYS_ANSI_FIXED_FONT,
    wxSYS_ANSI_VAR_FONT,
    wxSYS_SYSTEM_FONT,
    wxSYS_DEVICE_DEFAULT_FONT,



    wxSYS_DEFAULT_PALETTE,



    wxSYS_SYSTEM_FIXED_FONT,

    wxSYS_DEFAULT_GUI_FONT,


    wxSYS_ICONTITLE_FONT = wxSYS_DEFAULT_GUI_FONT
};





enum wxSystemColour
{
    wxSYS_COLOUR_SCROLLBAR,
    wxSYS_COLOUR_DESKTOP,
    wxSYS_COLOUR_ACTIVECAPTION,
    wxSYS_COLOUR_INACTIVECAPTION,
    wxSYS_COLOUR_MENU,
    wxSYS_COLOUR_WINDOW,
    wxSYS_COLOUR_WINDOWFRAME,
    wxSYS_COLOUR_MENUTEXT,
    wxSYS_COLOUR_WINDOWTEXT,
    wxSYS_COLOUR_CAPTIONTEXT,
    wxSYS_COLOUR_ACTIVEBORDER,
    wxSYS_COLOUR_INACTIVEBORDER,
    wxSYS_COLOUR_APPWORKSPACE,
    wxSYS_COLOUR_HIGHLIGHT,
    wxSYS_COLOUR_HIGHLIGHTTEXT,
    wxSYS_COLOUR_BTNFACE,
    wxSYS_COLOUR_BTNSHADOW,
    wxSYS_COLOUR_GRAYTEXT,
    wxSYS_COLOUR_BTNTEXT,
    wxSYS_COLOUR_INACTIVECAPTIONTEXT,
    wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DDKSHADOW,
    wxSYS_COLOUR_3DLIGHT,
    wxSYS_COLOUR_INFOTEXT,
    wxSYS_COLOUR_INFOBK,
    wxSYS_COLOUR_LISTBOX,
    wxSYS_COLOUR_HOTLIGHT,
    wxSYS_COLOUR_GRADIENTACTIVECAPTION,
    wxSYS_COLOUR_GRADIENTINACTIVECAPTION,
    wxSYS_COLOUR_MENUHILIGHT,
    wxSYS_COLOUR_MENUBAR,
    wxSYS_COLOUR_LISTBOXTEXT,
    wxSYS_COLOUR_LISTBOXHIGHLIGHTTEXT,

    wxSYS_COLOUR_MAX,


    wxSYS_COLOUR_BACKGROUND = wxSYS_COLOUR_DESKTOP,
    wxSYS_COLOUR_3DFACE = wxSYS_COLOUR_BTNFACE,
    wxSYS_COLOUR_3DSHADOW = wxSYS_COLOUR_BTNSHADOW,
    wxSYS_COLOUR_BTNHILIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DHIGHLIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_3DHILIGHT = wxSYS_COLOUR_BTNHIGHLIGHT,
    wxSYS_COLOUR_FRAMEBK = wxSYS_COLOUR_BTNFACE
};





enum wxSystemMetric
{
    wxSYS_MOUSE_BUTTONS = 1,
    wxSYS_BORDER_X,
    wxSYS_BORDER_Y,
    wxSYS_CURSOR_X,
    wxSYS_CURSOR_Y,
    wxSYS_DCLICK_X,
    wxSYS_DCLICK_Y,
    wxSYS_DRAG_X,
    wxSYS_DRAG_Y,
    wxSYS_EDGE_X,
    wxSYS_EDGE_Y,
    wxSYS_HSCROLL_ARROW_X,
    wxSYS_HSCROLL_ARROW_Y,
    wxSYS_HTHUMB_X,
    wxSYS_ICON_X,
    wxSYS_ICON_Y,
    wxSYS_ICONSPACING_X,
    wxSYS_ICONSPACING_Y,
    wxSYS_WINDOWMIN_X,
    wxSYS_WINDOWMIN_Y,
    wxSYS_SCREEN_X,
    wxSYS_SCREEN_Y,
    wxSYS_FRAMESIZE_X,
    wxSYS_FRAMESIZE_Y,
    wxSYS_SMALLICON_X,
    wxSYS_SMALLICON_Y,
    wxSYS_HSCROLL_Y,
    wxSYS_VSCROLL_X,
    wxSYS_VSCROLL_ARROW_X,
    wxSYS_VSCROLL_ARROW_Y,
    wxSYS_VTHUMB_Y,
    wxSYS_CAPTION_Y,
    wxSYS_MENU_Y,
    wxSYS_NETWORK_PRESENT,
    wxSYS_PENWINDOWS_PRESENT,
    wxSYS_SHOW_SOUNDS,
    wxSYS_SWAP_BUTTONS,
    wxSYS_DCLICK_MSEC
};


enum wxSystemFeature
{
    wxSYS_CAN_DRAW_FRAME_DECORATIONS = 1,
    wxSYS_CAN_ICONIZE_FRAME,
    wxSYS_TABLET_PRESENT
};


enum wxSystemScreenType
{
    wxSYS_SCREEN_NONE = 0,

    wxSYS_SCREEN_TINY,
    wxSYS_SCREEN_PDA,
    wxSYS_SCREEN_SMALL,
    wxSYS_SCREEN_DESKTOP
};
# 173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h"
class wxSystemSettingsNative
{
public:

    static wxColour GetColour(wxSystemColour index);


    static wxFont GetFont(wxSystemFont index);


    static int GetMetric(wxSystemMetric index, wxWindow * win = 
# 183 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h" 3 4
                                                               __null
# 183 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h"
                                                                   );


    static bool HasFeature(wxSystemFeature index);
};





class wxSystemSettings : public wxSystemSettingsNative
{
public:
# 209 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/settings.h"
    static wxSystemScreenType GetScreenType();


    static void SetScreenType( wxSystemScreenType screen );


    static wxSystemScreenType ms_screen;

};
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 2
# 31 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
class wxWindow : public wxWindowBase
{
    friend class wxSpinCtrl;
    friend class wxSlider;
    friend class wxRadioBox;



public:
    wxWindow() { Init(); }

    wxWindow(wxWindow *parent,
                wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxString& name = wxPanelNameStr)
    {
        Init();
        Create(parent, id, pos, size, style, name);
    }

    virtual ~wxWindow();

    bool Create(wxWindow *parent,
                wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxString& name = wxPanelNameStr);


    virtual void SetLabel(const wxString& label);
    virtual wxString GetLabel() const;

    virtual void Raise();
    virtual void Lower();

    virtual bool BeginRepositioningChildren();
    virtual void EndRepositioningChildren();

    virtual bool Show(bool show = true);
    virtual bool ShowWithEffect(wxShowEffect effect,
                                unsigned timeout = 0)
    {
        return MSWShowWithEffect(true, effect, timeout);
    }
    virtual bool HideWithEffect(wxShowEffect effect,
                                unsigned timeout = 0)
    {
        return MSWShowWithEffect(false, effect, timeout);
    }

    virtual void SetFocus();
    virtual void SetFocusFromKbd();

    virtual bool Reparent(wxWindowBase *newParent);

    virtual void WarpPointer(int x, int y);

    virtual void Refresh( bool eraseBackground = true,
                          const wxRect *rect = (const wxRect *) 
# 92 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                               __null 
# 92 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                                    );
    virtual void Update();

    virtual void SetWindowStyleFlag(long style);
    virtual void SetExtraStyle(long exStyle);
    virtual bool SetCursor( const wxCursor &cursor );
    virtual bool SetFont( const wxFont &font );

    virtual int GetCharHeight() const;
    virtual int GetCharWidth() const;

    virtual void SetScrollbar( int orient, int pos, int thumbVisible,
                               int range, bool refresh = true );
    virtual void SetScrollPos( int orient, int pos, bool refresh = true );
    virtual int GetScrollPos( int orient ) const;
    virtual int GetScrollThumb( int orient ) const;
    virtual int GetScrollRange( int orient ) const;
    virtual void ScrollWindow( int dx, int dy,
                               const wxRect* rect = 
# 110 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                   __null 
# 110 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                        );

    virtual bool ScrollLines(int lines);
    virtual bool ScrollPages(int pages);

    virtual void SetLayoutDirection(wxLayoutDirection dir);
    virtual wxLayoutDirection GetLayoutDirection() const;
    virtual wxCoord AdjustForLayoutDirection(wxCoord x,
                                             wxCoord width,
                                             wxCoord widthTotal) const;


    virtual void SetDropTarget( wxDropTarget *dropTarget );


    virtual void DragAcceptFiles(bool accept);





    virtual bool LoadNativeDialog(wxWindow* parent, wxWindowID& id);
    virtual bool LoadNativeDialog(wxWindow* parent, const wxString& name);
    wxWindow* GetWindowChild1(wxWindowID id);
    wxWindow* GetWindowChild(wxWindowID id);




    virtual bool RegisterHotKey(int hotkeyId, int modifiers, int keycode);
    virtual bool UnregisterHotKey(int hotkeyId);
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    WXHWND GetHWND() const { return m_hWnd; }
    void SetHWND(WXHWND hWnd) { m_hWnd = hWnd; }
    virtual WXWidget GetHandle() const { return GetHWND(); }

    void AssociateHandle(WXWidget handle);
    void DissociateHandle();


    bool IsSizeDeferred() const;
# 173 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    typedef bool (*MSWMessageHandler)(wxWindow *win,
                                      WXUINT nMsg,
                                      WXWPARAM wParam,
                                      WXLPARAM lParam);


    static bool MSWRegisterMessageHandler(int msg, MSWMessageHandler handler);


    static void MSWUnregisterMessageHandler(int msg, MSWMessageHandler handler);
# 191 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    void OnPaint(wxPaintEvent& event);




public:

    void SubclassWin(WXHWND hWnd);
    void UnsubclassWin();

    WXFARPROC MSWGetOldWndProc() const { return m_oldWndProc; }
    void MSWSetOldWndProc(WXFARPROC proc) { m_oldWndProc = proc; }




    bool IsOfStandardClass() const { return m_oldWndProc != 
# 207 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                           __null
# 207 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                               ; }

    wxWindow *FindItem(long id, WXHWND hWnd = 
# 209 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                             __null
# 209 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                 ) const;
    wxWindow *FindItemByHWND(WXHWND hWnd, bool controlOnly = false) const;


    virtual bool ContainsHWND(WXHWND ) const { return false; }



    virtual bool HasToolTips() const { return GetToolTip() != 
# 217 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                             __null
# 217 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                                 ; }







    virtual WXDWORD MSWGetStyle(long flags, WXDWORD *exstyle = 
# 225 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                              __null
# 225 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                                  ) const ;





    WXDWORD MSWGetCreateWindowFlags(WXDWORD *exflags = 
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                      __null
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                          ) const
        { return MSWGetStyle(GetWindowStyle(), exflags); }




    void MSWUpdateStyle(long flagsOld, long exflagsOld);


    virtual WXHWND MSWGetParent() const;


    static const wxChar *MSWGetRegisteredClassName();





    bool MSWCreate(const wxChar *wclass,
                   const wxChar *title = 
# 250 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                        __null
# 250 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                            ,
                   const wxPoint& pos = wxDefaultPosition,
                   const wxSize& size = wxDefaultSize,
                   WXDWORD style = 0,
                   WXDWORD exendedStyle = 0);

    virtual bool MSWCommand(WXUINT param, WXWORD id);



    virtual wxWindow* CreateWindowFromHWND(wxWindow* parent, WXHWND hWnd);


    virtual void AdoptAttributesFromHWND();



    virtual void SetupColours();







    void UnpackCommand(WXWPARAM wParam, WXLPARAM lParam,
                       WXWORD *id, WXHWND *hwnd, WXWORD *cmd);
    void UnpackActivate(WXWPARAM wParam, WXLPARAM lParam,
                        WXWORD *state, WXWORD *minimized, WXHWND *hwnd);
    void UnpackScroll(WXWPARAM wParam, WXLPARAM lParam,
                      WXWORD *code, WXWORD *pos, WXHWND *hwnd);
    void UnpackCtlColor(WXWPARAM wParam, WXLPARAM lParam,
                        WXHDC *hdc, WXHWND *hwnd);
    void UnpackMenuSelect(WXWPARAM wParam, WXLPARAM lParam,
                          WXWORD *item, WXWORD *flags, WXHMENU *hmenu);
# 299 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    virtual bool MSWOnScroll(int orientation, WXWORD nSBCode,
                             WXWORD pos, WXHWND control);


    virtual bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result);


    virtual bool MSWOnDrawItem(int id, WXDRAWITEMSTRUCT *item);
    virtual bool MSWOnMeasureItem(int id, WXMEASUREITEMSTRUCT *item);


    bool HandleCreate(WXLPCREATESTRUCT cs, bool *mayCreate);
    bool HandleInitDialog(WXHWND hWndFocus);
    bool HandleDestroy();

    bool HandlePaint();
    bool HandlePrintClient(WXHDC hDC);
    bool HandleEraseBkgnd(WXHDC hDC);

    bool HandleMinimize();
    bool HandleMaximize();
    bool HandleSize(int x, int y, WXUINT flag);
    bool HandleSizing(wxRect& rect);
    bool HandleGetMinMaxInfo(void *mmInfo);
    bool HandleEnterSizeMove();
    bool HandleExitSizeMove();

    bool HandleShow(bool show, int status);
    bool HandleActivate(int flag, bool minimized, WXHWND activate);

    bool HandleCommand(WXWORD id, WXWORD cmd, WXHWND control);

    bool HandleCtlColor(WXHBRUSH *hBrush, WXHDC hdc, WXHWND hWnd);

    bool HandlePaletteChanged(WXHWND hWndPalChange);
    bool HandleQueryNewPalette();
    bool HandleSysColorChange();
    bool HandleDisplayChange();
    bool HandleCaptureChanged(WXHWND gainedCapture);
    virtual bool HandleSettingChange(WXWPARAM wParam, WXLPARAM lParam);

    bool HandleQueryEndSession(long logOff, bool *mayEnd);
    bool HandleEndSession(bool endSession, long logOff);

    bool HandleSetFocus(WXHWND wnd);
    bool HandleKillFocus(WXHWND wnd);

    bool HandleDropFiles(WXWPARAM wParam);

    bool HandleMouseEvent(WXUINT msg, int x, int y, WXUINT flags);
    bool HandleMouseMove(int x, int y, WXUINT flags);
    bool HandleMouseWheel(wxMouseWheelAxis axis,
                          WXWPARAM wParam, WXLPARAM lParam);

    bool HandleChar(WXWPARAM wParam, WXLPARAM lParam);
    bool HandleKeyDown(WXWPARAM wParam, WXLPARAM lParam);
    bool HandleKeyUp(WXWPARAM wParam, WXLPARAM lParam);

    bool HandleHotKey(WXWPARAM wParam, WXLPARAM lParam);


    int HandleMenuChar(int chAccel, WXLPARAM lParam);


    bool HandleClipboardEvent( WXUINT nMsg );

    bool HandleQueryDragIcon(WXHICON *hIcon);

    bool HandleSetCursor(WXHWND hWnd, short nHitTest, int mouseMsg);

    bool HandlePower(WXWPARAM wParam, WXLPARAM lParam, bool *vetoed);
# 380 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    virtual bool MSWHandleMessage(WXLRESULT *result,
                                  WXUINT message,
                                  WXWPARAM wParam,
                                  WXLPARAM lParam);



    virtual WXLRESULT MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam);


    virtual WXLRESULT MSWDefWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam);





    virtual bool MSWShouldPreProcessMessage(WXMSG* pMsg);


    virtual bool MSWProcessMessage(WXMSG* pMsg);


    virtual bool MSWTranslateMessage(WXMSG* pMsg);


    virtual void MSWDestroyWindow();
# 421 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    virtual void MSWAdjustBrushOrg(int* ,
                                   int* ) const
    {
    }




    virtual WXHBRUSH MSWGetCustomBgBrush() { return 0; }
# 443 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    virtual WXHBRUSH MSWGetBgBrushForChild(WXHDC hDC, wxWindow *child);



    WXHBRUSH MSWGetBgBrush(WXHDC hDC);

    enum MSWThemeColour
    {
        ThemeColourText = 0,
        ThemeColourBackground,
        ThemeColourBorder
    };



    wxColour MSWGetThemeColour(const wchar_t *themeName,
                               int themePart,
                               int themeState,
                               MSWThemeColour themeColour,
                               wxSystemColour fallback) const;





    virtual bool MSWPrintChild(WXHDC , wxWindow * )
    {
        return false;
    }




    virtual bool MSWShouldPropagatePrintChild()
    {
        return true;
    }







    virtual bool MSWHasInheritableBackground() const
    {
        return InheritsBackgroundColour();
    }
# 503 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
    void MSWSetEraseBgHook(wxWindow *child);


    bool MSWHasEraseBgHook() const;



    virtual bool MSWEraseBgHook(WXHDC ) { return false; }



    bool MSWShowWithEffect(bool show,
                           wxShowEffect effect,
                           unsigned timeout);


    void OnSysColourChanged(wxSysColourChangedEvent& event);


    void InitMouseEvent(wxMouseEvent& event, int x, int y, WXUINT flags);


    bool IsMouseInWindow() const;


    virtual bool IsDoubleBuffered() const;

    void SetDoubleBuffered(bool on);


    void GenerateMouseLeave();



    virtual void OnInternalIdle();

protected:



    virtual wxBorder GetDefaultBorderForControl() const;


    virtual wxBorder GetDefaultBorder() const;



    virtual wxBorder TranslateBorder(wxBorder border) const;


    virtual bool DoPopupMenu( wxMenu *menu, int x, int y );



    WXHWND m_hWnd;


    WXFARPROC m_oldWndProc;


    bool m_mouseInWindow:1;
    bool m_lastKeydownProcessed:1;


    int m_xThumbSize;
    int m_yThumbSize;


    virtual void DoGetTextExtent(const wxString& string,
                                 int *x, int *y,
                                 int *descent = 
# 573 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                               __null
# 573 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                   ,
                                 int *externalLeading = 
# 574 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                       __null
# 574 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                           ,
                                 const wxFont *font = 
# 575 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
                                                     __null
# 575 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                                                         ) const;
    virtual void DoClientToScreen( int *x, int *y ) const;
    virtual void DoScreenToClient( int *x, int *y ) const;
    virtual void DoGetPosition( int *x, int *y ) const;
    virtual void DoGetSize( int *width, int *height ) const;
    virtual void DoGetClientSize( int *width, int *height ) const;
    virtual void DoSetSize(int x, int y,
                           int width, int height,
                           int sizeFlags = (0x0001|0x0002));
    virtual void DoSetClientSize(int width, int height);

    virtual wxSize DoGetBorderSize() const;

    virtual void DoCaptureMouse();
    virtual void DoReleaseMouse();

    virtual void DoEnable(bool enable);

    virtual void DoFreeze();
    virtual void DoThaw();







    bool DoMoveSibling(WXHWND hwnd, int x, int y, int width, int height);





    virtual void DoMoveWindow(int x, int y, int width, int height);


    virtual void DoSetToolTip( wxToolTip *tip );



    bool HandleTooltipNotify(WXUINT code,
                             WXLPARAM lParam,
                             const wxString& ttip);





    void InitAnyKeyEvent(wxKeyEvent& event,
                         WXWPARAM wParam,
                         WXLPARAM lParam) const;






    wxKeyEvent CreateKeyEvent(wxEventType evType,
                              WXWPARAM wParam,
                              WXLPARAM lParam = 0) const;





    wxKeyEvent CreateCharEvent(wxEventType evType,
                               WXWPARAM wParam,
                               WXLPARAM lParam) const;




    bool DoEraseBackground(WXHDC hDC);







    void MSWUpdateUIState(int action, int state = 0);



    virtual void MSWGetCreateWindowCoords(const wxPoint& pos,
                                          const wxSize& size,
                                          int& x, int& y,
                                          int& w, int& h) const;

    bool MSWEnableHWND(WXHWND hWnd, bool enable);





    virtual wxWindow* MSWFindItem(long , WXHWND ) const
    {
        return 
# 672 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h" 3 4
              __null
# 672 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/window.h"
                  ;
    }

private:

    void Init();


    bool HandleMove(int x, int y);
    bool HandleMoving(wxRect& rect);
    bool HandleJoystickEvent(WXUINT msg, int x, int y, WXUINT flags);
    bool HandleNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result);





    bool MSWSafeIsDialogMessage(WXMSG* msg);



protected:

    virtual void MSWEndDeferWindowPos()
    {
        m_pendingPosition = wxDefaultPosition;
        m_pendingSize = wxDefaultSize;
    }


    WXHANDLE m_hDWP;




    wxPoint m_pendingPosition;
    wxSize m_pendingSize;


private:




    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
    private: wxWindow(const wxWindow&); wxWindow& operator=(const wxWindow&);
    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
};




class wxWindowCreationHook
{
public:
    wxWindowCreationHook(wxWindow *winBeingCreated);
    ~wxWindowCreationHook();
};
# 1890 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 2
# 1954 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
inline wxWindow *wxWindowBase::GetGrandParent() const
{
    return m_parent ? m_parent->GetParent() : 
# 1956 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h" 3 4
                                             __null
# 1956 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/window.h"
                                                 ;
}







extern wxWindow* wxFindWindowAtPointer(wxPoint& pt);


extern wxPoint wxGetMousePosition();


extern wxWindow *wxGetActiveWindow();


 wxWindow* wxGetTopLevelParent(wxWindow *win);
# 23 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h" 2

extern const char wxControlNameStr[];






enum wxEllipsizeFlags
{
    wxELLIPSIZE_FLAGS_NONE = 0,
    wxELLIPSIZE_FLAGS_PROCESS_MNEMONICS = 1,
    wxELLIPSIZE_FLAGS_EXPAND_TABS = 2,

    wxELLIPSIZE_FLAGS_DEFAULT = wxELLIPSIZE_FLAGS_PROCESS_MNEMONICS |
                                wxELLIPSIZE_FLAGS_EXPAND_TABS
};



enum wxEllipsizeMode
{
    wxELLIPSIZE_NONE,
    wxELLIPSIZE_START,
    wxELLIPSIZE_MIDDLE,
    wxELLIPSIZE_END
};





class wxControlBase : public wxWindow
{
public:
    wxControlBase() { }

    virtual ~wxControlBase();


    bool Create(wxWindow *parent, wxWindowID id,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxControlNameStr);


    int GetAlignment() const { return m_windowStyle & wxALIGN_MASK; }


    virtual void SetLabel(const wxString& label)
    {
        m_labelOrig = label;

        InvalidateBestSize();

        wxWindow::SetLabel(label);
    }



    virtual wxString GetLabel() const { return m_labelOrig; }


    virtual void SetLabelText(const wxString& text)
    {
        SetLabel(EscapeMnemonics(text));
    }


    virtual wxString GetLabelText() const { return GetLabelText(GetLabel()); }
# 112 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h"
    bool SetLabelMarkup(const wxString& markup)
    {
        return DoSetLabelMarkup(markup);
    }






    virtual bool ShouldInheritColours() const { return true; }






    virtual void Command(wxCommandEvent &event);

    virtual bool SetFont(const wxFont& font);


    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event);

    wxSize GetSizeFromTextSize(int xlen, int ylen = -1) const
        { return DoGetSizeFromTextSize(xlen, ylen); }
    wxSize GetSizeFromTextSize(const wxSize& tsize) const
        { return DoGetSizeFromTextSize(tsize.x, tsize.y); }






    static wxString GetLabelText(const wxString& label);




    static wxString RemoveMnemonics(const wxString& str);


    static wxString EscapeMnemonics(const wxString& str);






    static wxString Ellipsize(const wxString& label, const wxDC& dc,
                              wxEllipsizeMode mode, int maxWidth,
                              int flags = wxELLIPSIZE_FLAGS_DEFAULT);



    static int FindAccelIndex(const wxString& label,
                              wxString *labelOnly = 
# 168 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h" 3 4
                                                   __null
# 168 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h"
                                                       );





    static wxVisualAttributes
        GetCompositeControlsDefaultAttributes(wxWindowVariant variant);

protected:

    virtual wxBorder GetDefaultBorder() const;



    bool CreateControl(wxWindowBase *parent,
                       wxWindowID id,
                       const wxPoint& pos,
                       const wxSize& size,
                       long style,
                       const wxValidator& validator,
                       const wxString& name);





    virtual bool DoSetLabelMarkup(const wxString& markup);



    virtual wxSize DoGetSizeFromTextSize(int xlen, int ylen = -1) const;


    void InitCommandEvent(wxCommandEvent& event) const;


    static wxString DoEllipsizeSingleLine(const wxString& label, const wxDC& dc,
                                          wxEllipsizeMode mode, int maxWidth,
                                          int replacementWidth);




    static wxString RemoveMarkup(const wxString& markup);





    wxString m_labelOrig;

    private: wxControlBase(const wxControlBase&); wxControlBase& operator=(const wxControlBase&);
};
# 230 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/control.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/control.h"
class wxControl : public wxControlBase
{
public:
    wxControl() { }

    wxControl(wxWindow *parent, wxWindowID id,
              const wxPoint& pos = wxDefaultPosition,
              const wxSize& size = wxDefaultSize, long style = 0,
              const wxValidator& validator = wxDefaultValidator,
              const wxString& name = wxControlNameStr)
    {
        Create(parent, id, pos, size, style, validator, name);
    }

    bool Create(wxWindow *parent, wxWindowID id,
            const wxPoint& pos = wxDefaultPosition,
            const wxSize& size = wxDefaultSize, long style = 0,
            const wxValidator& validator = wxDefaultValidator,
            const wxString& name = wxControlNameStr);



    virtual void Command(wxCommandEvent& event) { ProcessCommand(event); }





    virtual wxVisualAttributes GetDefaultAttributes() const
    {
        return GetClassDefaultAttributes(GetWindowVariant());
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL);


    bool ProcessCommand(wxCommandEvent& event);


    virtual bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result);


    virtual bool MSWOnDraw(WXDRAWITEMSTRUCT *) { return false; }
    virtual bool MSWOnMeasure(WXMEASUREITEMSTRUCT *) { return false; }

    const wxArrayLong& GetSubcontrols() const { return m_subControls; }



    virtual WXHBRUSH MSWControlColor(WXHDC pDC, WXHWND hWnd);


    virtual WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const;

protected:

    virtual wxBorder GetDefaultBorder() const;


    virtual wxSize DoGetBestSize() const;





    virtual wxSize GetBestSpinnerSize(const bool is_vertical) const;






    bool MSWCreateControl(const wxChar *classname,
                          const wxString& label,
                          const wxPoint& pos,
                          const wxSize& size);
# 108 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/control.h"
    bool MSWCreateControl(const wxChar *classname,
                          WXDWORD style,
                          const wxPoint& pos = wxDefaultPosition,
                          const wxSize& size = wxDefaultSize,
                          const wxString& label = wxEmptyString,
                          WXDWORD exstyle = (WXDWORD)-1);



    WXHBRUSH MSWControlColorDisabled(WXHDC pDC);




    virtual WXHBRUSH DoMSWControlColor(WXHDC pDC, wxColour colBg, WXHWND hWnd);


    virtual wxWindow *MSWFindItem(long id, WXHWND hWnd) const;



    wxArrayLong m_subControls;

private:
    private: wxControl(const wxControl&); wxControl& operator=(const wxControl&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();
};
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/control.h" 2
# 23 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 2
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h" 1
# 15 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
typedef long wxTextPos;

class wxArrayString;
class wxTextCompleter;
class wxTextEntryHintData;
class wxWindow;
# 29 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
class wxTextEntryBase
{
public:
    wxTextEntryBase() { m_eventsBlock = 0; m_hintData = 
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h" 3 4
                                                       __null
# 32 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
                                                           ; }
    virtual ~wxTextEntryBase();






    virtual void SetValue(const wxString& value)
        { DoSetValue(value, SetValue_SendEvent); }
    virtual void ChangeValue(const wxString& value);




    virtual void WriteText(const wxString& text) = 0;
    virtual void AppendText(const wxString& text);

    virtual wxString GetValue() const;
    virtual wxString GetRange(long from, long to) const;
    bool IsEmpty() const { return GetLastPosition() <= 0; }





    virtual void Replace(long from, long to, const wxString& value);
    virtual void Remove(long from, long to) = 0;
    virtual void Clear() { SetValue(wxString()); }
    void RemoveSelection();





    virtual void Copy() = 0;
    virtual void Cut() = 0;
    virtual void Paste() = 0;

    virtual bool CanCopy() const;
    virtual bool CanCut() const;
    virtual bool CanPaste() const;




    virtual void Undo() = 0;
    virtual void Redo() = 0;

    virtual bool CanUndo() const = 0;
    virtual bool CanRedo() const = 0;






    virtual void SetInsertionPoint(long pos) = 0;
    virtual void SetInsertionPointEnd() { SetInsertionPoint(-1); }
    virtual long GetInsertionPoint() const = 0;
    virtual long GetLastPosition() const = 0;





    virtual void SetSelection(long from, long to) = 0;
    virtual void SelectAll() { SetSelection(-1, -1); }
    virtual void SelectNone()
        { const long pos = GetInsertionPoint(); SetSelection(pos, pos); }
    virtual void GetSelection(long *from, long *to) const = 0;
    bool HasSelection() const;
    virtual wxString GetStringSelection() const;
# 118 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
    bool AutoComplete(const wxArrayString& choices)
        { return DoAutoCompleteStrings(choices); }

    bool AutoCompleteFileNames()
        { return DoAutoCompleteFileNames(1); }

    bool AutoCompleteDirectories()
        { return DoAutoCompleteFileNames(2); }




    bool AutoComplete(wxTextCompleter *completer)
        { return DoAutoCompleteCustom(completer); }





    virtual bool IsEditable() const = 0;
    virtual void SetEditable(bool editable) = 0;




    virtual void SetMaxLength(unsigned long ) { }
# 153 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
    virtual bool SetHint(const wxString& hint);
    virtual wxString GetHint() const;
# 164 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
    bool SetMargins(const wxPoint& pt)
        { return DoSetMargins(pt); }
    bool SetMargins(wxCoord left, wxCoord top = -1)
        { return DoSetMargins(wxPoint(left, top)); }
    wxPoint GetMargins() const
        { return DoGetMargins(); }
# 179 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
    static bool SendTextUpdatedEvent(wxWindow *win);


    bool SendTextUpdatedEvent()
    {
        return SendTextUpdatedEvent(GetEditableWindow());
    }




    void SendTextUpdatedEventIfAllowed()
    {
        if ( EventsAllowed() )
            SendTextUpdatedEvent();
    }





    void ForwardEnableTextChangedEvents(bool enable)
    {



        if ( enable )
            ResumeTextChangedEvents();
        else
            SuppressTextChangedEvents();
    }

protected:


    enum
    {
        SetValue_NoEvent = 0,
        SetValue_SendEvent = 1,
        SetValue_SelectionOnly = 2
    };

    virtual void DoSetValue(const wxString& value, int flags);
    virtual wxString DoGetValue() const = 0;



    virtual wxWindow *GetEditableWindow() = 0;


    virtual bool DoSetMargins(const wxPoint& pt);
    virtual wxPoint DoGetMargins() const;





    virtual bool DoAutoCompleteStrings(const wxArrayString& )
        { return false; }
    virtual bool DoAutoCompleteFileNames(int )
        { return false; }
    virtual bool DoAutoCompleteCustom(wxTextCompleter *completer);





    class EventsSuppressor
    {
    public:
        EventsSuppressor(wxTextEntryBase *text, bool suppress = true)
            : m_text(text),
              m_suppress(suppress)
        {
            if ( m_suppress )
                m_text->SuppressTextChangedEvents();
        }

        ~EventsSuppressor()
        {
            if ( m_suppress )
                m_text->ResumeTextChangedEvents();
        }

    private:
        wxTextEntryBase *m_text;
        bool m_suppress;
    };

    friend class EventsSuppressor;

private:


    void SuppressTextChangedEvents()
    {
        if ( !m_eventsBlock++ )
            EnableTextChangedEvents(false);
    }

    void ResumeTextChangedEvents()
    {
        if ( !--m_eventsBlock )
            EnableTextChangedEvents(true);
    }







    virtual void EnableTextChangedEvents(bool ) { }


    bool EventsAllowed() const { return m_eventsBlock == 0; }



    unsigned m_eventsBlock;


    wxTextEntryHintData *m_hintData;



    friend class wxTextEntryHintData;
};
# 319 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/textentry.h" 1
# 13 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/textentry.h"
class wxTextAutoCompleteData;





class wxTextEntry : public wxTextEntryBase
{
public:
    wxTextEntry();
    virtual ~wxTextEntry();


    virtual void WriteText(const wxString& text);
    virtual void Remove(long from, long to);

    virtual void Copy();
    virtual void Cut();
    virtual void Paste();

    virtual void Undo();
    virtual void Redo();
    virtual bool CanUndo() const;
    virtual bool CanRedo() const;

    virtual void SetInsertionPoint(long pos);
    virtual long GetInsertionPoint() const;
    virtual long GetLastPosition() const;

    virtual void SetSelection(long from, long to)
        { DoSetSelection(from, to); }
    virtual void GetSelection(long *from, long *to) const;

    virtual bool IsEditable() const;
    virtual void SetEditable(bool editable);

    virtual void SetMaxLength(unsigned long len);


    virtual bool SetHint(const wxString& hint);
    virtual wxString GetHint() const;


protected:
    virtual wxString DoGetValue() const;




    enum
    {
        SetSel_NoScroll = 0,
        SetSel_Scroll = 1
    };
    virtual void DoSetSelection(long from, long to, int flags = SetSel_Scroll);


    virtual bool DoSetMargins(const wxPoint& pt);
    virtual wxPoint DoGetMargins() const;




    virtual bool DoAutoCompleteStrings(const wxArrayString& choices);

    virtual bool DoAutoCompleteFileNames(int flags);

    virtual bool DoAutoCompleteCustom(wxTextCompleter *completer);


private:

    virtual WXHWND GetEditHWND() const = 0;




    wxTextAutoCompleteData *GetOrCreateCompleter();



    wxTextAutoCompleteData *m_autoCompleteData;


    friend class wxTextAutoCompleteData;

};
# 320 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textentry.h" 2
# 24 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 2
# 33 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h" 1
# 13 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/beforestd.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h" 2




# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream" 3






# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream" 3
namespace std
{

# 60 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 19 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 1
# 16 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 17 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/afterstd.h" 2
# 22 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h" 2


# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/winundef.h" 1
# 25 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/ioswrap.h" 2
# 34 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 2






# 39 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
class wxTextCtrl;
class wxTextCtrlBase;







typedef long wxTextCoord;





extern const char wxTextCtrlNameStr[];



const wxTextCoord wxOutOfRangeTextCoord = -1;
const wxTextCoord wxInvalidTextCoord = -2;
# 135 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
enum wxTextCtrlHitTestResult
{
    wxTE_HT_UNKNOWN = -2,
    wxTE_HT_BEFORE,
    wxTE_HT_ON_TEXT,
    wxTE_HT_BELOW,
    wxTE_HT_BEYOND
};
# 151 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
enum wxTextAttrAlignment
{
    wxTEXT_ALIGNMENT_DEFAULT,
    wxTEXT_ALIGNMENT_LEFT,
    wxTEXT_ALIGNMENT_CENTRE,
    wxTEXT_ALIGNMENT_CENTER = wxTEXT_ALIGNMENT_CENTRE,
    wxTEXT_ALIGNMENT_RIGHT,
    wxTEXT_ALIGNMENT_JUSTIFIED
};


enum wxTextAttrFlags
{
    wxTEXT_ATTR_TEXT_COLOUR = 0x00000001,
    wxTEXT_ATTR_BACKGROUND_COLOUR = 0x00000002,

    wxTEXT_ATTR_FONT_FACE = 0x00000004,
    wxTEXT_ATTR_FONT_POINT_SIZE = 0x00000008,
    wxTEXT_ATTR_FONT_PIXEL_SIZE = 0x10000000,
    wxTEXT_ATTR_FONT_WEIGHT = 0x00000010,
    wxTEXT_ATTR_FONT_ITALIC = 0x00000020,
    wxTEXT_ATTR_FONT_UNDERLINE = 0x00000040,
    wxTEXT_ATTR_FONT_STRIKETHROUGH = 0x08000000,
    wxTEXT_ATTR_FONT_ENCODING = 0x02000000,
    wxTEXT_ATTR_FONT_FAMILY = 0x04000000,
    wxTEXT_ATTR_FONT_SIZE =
        ( wxTEXT_ATTR_FONT_POINT_SIZE | wxTEXT_ATTR_FONT_PIXEL_SIZE ),
    wxTEXT_ATTR_FONT =
        ( wxTEXT_ATTR_FONT_FACE | wxTEXT_ATTR_FONT_SIZE | wxTEXT_ATTR_FONT_WEIGHT |
            wxTEXT_ATTR_FONT_ITALIC | wxTEXT_ATTR_FONT_UNDERLINE | wxTEXT_ATTR_FONT_STRIKETHROUGH | wxTEXT_ATTR_FONT_ENCODING | wxTEXT_ATTR_FONT_FAMILY ),

    wxTEXT_ATTR_ALIGNMENT = 0x00000080,
    wxTEXT_ATTR_LEFT_INDENT = 0x00000100,
    wxTEXT_ATTR_RIGHT_INDENT = 0x00000200,
    wxTEXT_ATTR_TABS = 0x00000400,
    wxTEXT_ATTR_PARA_SPACING_AFTER = 0x00000800,
    wxTEXT_ATTR_PARA_SPACING_BEFORE = 0x00001000,
    wxTEXT_ATTR_LINE_SPACING = 0x00002000,
    wxTEXT_ATTR_CHARACTER_STYLE_NAME = 0x00004000,
    wxTEXT_ATTR_PARAGRAPH_STYLE_NAME = 0x00008000,
    wxTEXT_ATTR_LIST_STYLE_NAME = 0x00010000,

    wxTEXT_ATTR_BULLET_STYLE = 0x00020000,
    wxTEXT_ATTR_BULLET_NUMBER = 0x00040000,
    wxTEXT_ATTR_BULLET_TEXT = 0x00080000,
    wxTEXT_ATTR_BULLET_NAME = 0x00100000,

    wxTEXT_ATTR_BULLET =
        ( wxTEXT_ATTR_BULLET_STYLE | wxTEXT_ATTR_BULLET_NUMBER | wxTEXT_ATTR_BULLET_TEXT |
          wxTEXT_ATTR_BULLET_NAME ),


    wxTEXT_ATTR_URL = 0x00200000,
    wxTEXT_ATTR_PAGE_BREAK = 0x00400000,
    wxTEXT_ATTR_EFFECTS = 0x00800000,
    wxTEXT_ATTR_OUTLINE_LEVEL = 0x01000000,





    wxTEXT_ATTR_CHARACTER =
        (wxTEXT_ATTR_FONT|wxTEXT_ATTR_EFFECTS|
            wxTEXT_ATTR_BACKGROUND_COLOUR|wxTEXT_ATTR_TEXT_COLOUR|wxTEXT_ATTR_CHARACTER_STYLE_NAME|wxTEXT_ATTR_URL),

    wxTEXT_ATTR_PARAGRAPH =
        (wxTEXT_ATTR_ALIGNMENT|wxTEXT_ATTR_LEFT_INDENT|wxTEXT_ATTR_RIGHT_INDENT|wxTEXT_ATTR_TABS|
            wxTEXT_ATTR_PARA_SPACING_BEFORE|wxTEXT_ATTR_PARA_SPACING_AFTER|wxTEXT_ATTR_LINE_SPACING|
            wxTEXT_ATTR_BULLET|wxTEXT_ATTR_PARAGRAPH_STYLE_NAME|wxTEXT_ATTR_LIST_STYLE_NAME|wxTEXT_ATTR_OUTLINE_LEVEL|wxTEXT_ATTR_PAGE_BREAK),

    wxTEXT_ATTR_ALL = (wxTEXT_ATTR_CHARACTER|wxTEXT_ATTR_PARAGRAPH)
};




enum wxTextAttrBulletStyle
{
    wxTEXT_ATTR_BULLET_STYLE_NONE = 0x00000000,
    wxTEXT_ATTR_BULLET_STYLE_ARABIC = 0x00000001,
    wxTEXT_ATTR_BULLET_STYLE_LETTERS_UPPER = 0x00000002,
    wxTEXT_ATTR_BULLET_STYLE_LETTERS_LOWER = 0x00000004,
    wxTEXT_ATTR_BULLET_STYLE_ROMAN_UPPER = 0x00000008,
    wxTEXT_ATTR_BULLET_STYLE_ROMAN_LOWER = 0x00000010,
    wxTEXT_ATTR_BULLET_STYLE_SYMBOL = 0x00000020,
    wxTEXT_ATTR_BULLET_STYLE_BITMAP = 0x00000040,
    wxTEXT_ATTR_BULLET_STYLE_PARENTHESES = 0x00000080,
    wxTEXT_ATTR_BULLET_STYLE_PERIOD = 0x00000100,
    wxTEXT_ATTR_BULLET_STYLE_STANDARD = 0x00000200,
    wxTEXT_ATTR_BULLET_STYLE_RIGHT_PARENTHESIS = 0x00000400,
    wxTEXT_ATTR_BULLET_STYLE_OUTLINE = 0x00000800,

    wxTEXT_ATTR_BULLET_STYLE_ALIGN_LEFT = 0x00000000,
    wxTEXT_ATTR_BULLET_STYLE_ALIGN_RIGHT = 0x00001000,
    wxTEXT_ATTR_BULLET_STYLE_ALIGN_CENTRE = 0x00002000,

    wxTEXT_ATTR_BULLET_STYLE_CONTINUATION = 0x00004000
};




enum wxTextAttrEffects
{
    wxTEXT_ATTR_EFFECT_NONE = 0x00000000,
    wxTEXT_ATTR_EFFECT_CAPITALS = 0x00000001,
    wxTEXT_ATTR_EFFECT_SMALL_CAPITALS = 0x00000002,
    wxTEXT_ATTR_EFFECT_STRIKETHROUGH = 0x00000004,
    wxTEXT_ATTR_EFFECT_DOUBLE_STRIKETHROUGH = 0x00000008,
    wxTEXT_ATTR_EFFECT_SHADOW = 0x00000010,
    wxTEXT_ATTR_EFFECT_EMBOSS = 0x00000020,
    wxTEXT_ATTR_EFFECT_OUTLINE = 0x00000040,
    wxTEXT_ATTR_EFFECT_ENGRAVE = 0x00000080,
    wxTEXT_ATTR_EFFECT_SUPERSCRIPT = 0x00000100,
    wxTEXT_ATTR_EFFECT_SUBSCRIPT = 0x00000200
};




enum wxTextAttrLineSpacing
{
    wxTEXT_ATTR_LINE_SPACING_NORMAL = 10,
    wxTEXT_ATTR_LINE_SPACING_HALF = 15,
    wxTEXT_ATTR_LINE_SPACING_TWICE = 20
};





class wxTextAttr
{
public:

    wxTextAttr() { Init(); }
    wxTextAttr(const wxTextAttr& attr) { Init(); Copy(attr); }
    wxTextAttr(const wxColour& colText,
               const wxColour& colBack = wxNullColour,
               const wxFont& font = wxNullFont,
               wxTextAttrAlignment alignment = wxTEXT_ALIGNMENT_DEFAULT);


    void Init();


    void Copy(const wxTextAttr& attr);


    void operator= (const wxTextAttr& attr);


    bool operator== (const wxTextAttr& attr) const;





    bool EqPartial(const wxTextAttr& attr, bool weakTest = true) const;


    bool GetFontAttributes(const wxFont& font, int flags = wxTEXT_ATTR_FONT);


    void SetTextColour(const wxColour& colText) { m_colText = colText; m_flags |= wxTEXT_ATTR_TEXT_COLOUR; }
    void SetBackgroundColour(const wxColour& colBack) { m_colBack = colBack; m_flags |= wxTEXT_ATTR_BACKGROUND_COLOUR; }
    void SetAlignment(wxTextAttrAlignment alignment) { m_textAlignment = alignment; m_flags |= wxTEXT_ATTR_ALIGNMENT; }
    void SetTabs(const wxArrayInt& tabs) { m_tabs = tabs; m_flags |= wxTEXT_ATTR_TABS; }
    void SetLeftIndent(int indent, int subIndent = 0) { m_leftIndent = indent; m_leftSubIndent = subIndent; m_flags |= wxTEXT_ATTR_LEFT_INDENT; }
    void SetRightIndent(int indent) { m_rightIndent = indent; m_flags |= wxTEXT_ATTR_RIGHT_INDENT; }

    void SetFontSize(int pointSize) { m_fontSize = pointSize; m_flags &= ~wxTEXT_ATTR_FONT_SIZE; m_flags |= wxTEXT_ATTR_FONT_POINT_SIZE; }
    void SetFontPointSize(int pointSize) { m_fontSize = pointSize; m_flags &= ~wxTEXT_ATTR_FONT_SIZE; m_flags |= wxTEXT_ATTR_FONT_POINT_SIZE; }
    void SetFontPixelSize(int pixelSize) { m_fontSize = pixelSize; m_flags &= ~wxTEXT_ATTR_FONT_SIZE; m_flags |= wxTEXT_ATTR_FONT_PIXEL_SIZE; }
    void SetFontStyle(wxFontStyle fontStyle) { m_fontStyle = fontStyle; m_flags |= wxTEXT_ATTR_FONT_ITALIC; }
    void SetFontWeight(wxFontWeight fontWeight) { m_fontWeight = fontWeight; m_flags |= wxTEXT_ATTR_FONT_WEIGHT; }
    void SetFontFaceName(const wxString& faceName) { m_fontFaceName = faceName; m_flags |= wxTEXT_ATTR_FONT_FACE; }
    void SetFontUnderlined(bool underlined) { m_fontUnderlined = underlined; m_flags |= wxTEXT_ATTR_FONT_UNDERLINE; }
    void SetFontStrikethrough(bool strikethrough) { m_fontStrikethrough = strikethrough; m_flags |= wxTEXT_ATTR_FONT_STRIKETHROUGH; }
    void SetFontEncoding(wxFontEncoding encoding) { m_fontEncoding = encoding; m_flags |= wxTEXT_ATTR_FONT_ENCODING; }
    void SetFontFamily(wxFontFamily family) { m_fontFamily = family; m_flags |= wxTEXT_ATTR_FONT_FAMILY; }


    void SetFont(const wxFont& font, int flags = (wxTEXT_ATTR_FONT & ~wxTEXT_ATTR_FONT_PIXEL_SIZE)) { GetFontAttributes(font, flags); }

    void SetFlags(long flags) { m_flags = flags; }

    void SetCharacterStyleName(const wxString& name) { m_characterStyleName = name; m_flags |= wxTEXT_ATTR_CHARACTER_STYLE_NAME; }
    void SetParagraphStyleName(const wxString& name) { m_paragraphStyleName = name; m_flags |= wxTEXT_ATTR_PARAGRAPH_STYLE_NAME; }
    void SetListStyleName(const wxString& name) { m_listStyleName = name; SetFlags(GetFlags() | wxTEXT_ATTR_LIST_STYLE_NAME); }
    void SetParagraphSpacingAfter(int spacing) { m_paragraphSpacingAfter = spacing; m_flags |= wxTEXT_ATTR_PARA_SPACING_AFTER; }
    void SetParagraphSpacingBefore(int spacing) { m_paragraphSpacingBefore = spacing; m_flags |= wxTEXT_ATTR_PARA_SPACING_BEFORE; }
    void SetLineSpacing(int spacing) { m_lineSpacing = spacing; m_flags |= wxTEXT_ATTR_LINE_SPACING; }
    void SetBulletStyle(int style) { m_bulletStyle = style; m_flags |= wxTEXT_ATTR_BULLET_STYLE; }
    void SetBulletNumber(int n) { m_bulletNumber = n; m_flags |= wxTEXT_ATTR_BULLET_NUMBER; }
    void SetBulletText(const wxString& text) { m_bulletText = text; m_flags |= wxTEXT_ATTR_BULLET_TEXT; }
    void SetBulletFont(const wxString& bulletFont) { m_bulletFont = bulletFont; }
    void SetBulletName(const wxString& name) { m_bulletName = name; m_flags |= wxTEXT_ATTR_BULLET_NAME; }
    void SetURL(const wxString& url) { m_urlTarget = url; m_flags |= wxTEXT_ATTR_URL; }
    void SetPageBreak(bool pageBreak = true) { SetFlags(pageBreak ? (GetFlags() | wxTEXT_ATTR_PAGE_BREAK) : (GetFlags() & ~wxTEXT_ATTR_PAGE_BREAK)); }
    void SetTextEffects(int effects) { m_textEffects = effects; SetFlags(GetFlags() | wxTEXT_ATTR_EFFECTS); }
    void SetTextEffectFlags(int effects) { m_textEffectFlags = effects; }
    void SetOutlineLevel(int level) { m_outlineLevel = level; SetFlags(GetFlags() | wxTEXT_ATTR_OUTLINE_LEVEL); }

    const wxColour& GetTextColour() const { return m_colText; }
    const wxColour& GetBackgroundColour() const { return m_colBack; }
    wxTextAttrAlignment GetAlignment() const { return m_textAlignment; }
    const wxArrayInt& GetTabs() const { return m_tabs; }
    long GetLeftIndent() const { return m_leftIndent; }
    long GetLeftSubIndent() const { return m_leftSubIndent; }
    long GetRightIndent() const { return m_rightIndent; }
    long GetFlags() const { return m_flags; }

    int GetFontSize() const { return m_fontSize; }
    wxFontStyle GetFontStyle() const { return m_fontStyle; }
    wxFontWeight GetFontWeight() const { return m_fontWeight; }
    bool GetFontUnderlined() const { return m_fontUnderlined; }
    bool GetFontStrikethrough() const { return m_fontStrikethrough; }
    const wxString& GetFontFaceName() const { return m_fontFaceName; }
    wxFontEncoding GetFontEncoding() const { return m_fontEncoding; }
    wxFontFamily GetFontFamily() const { return m_fontFamily; }

    wxFont GetFont() const;

    const wxString& GetCharacterStyleName() const { return m_characterStyleName; }
    const wxString& GetParagraphStyleName() const { return m_paragraphStyleName; }
    const wxString& GetListStyleName() const { return m_listStyleName; }
    int GetParagraphSpacingAfter() const { return m_paragraphSpacingAfter; }
    int GetParagraphSpacingBefore() const { return m_paragraphSpacingBefore; }

    int GetLineSpacing() const { return m_lineSpacing; }
    int GetBulletStyle() const { return m_bulletStyle; }
    int GetBulletNumber() const { return m_bulletNumber; }
    const wxString& GetBulletText() const { return m_bulletText; }
    const wxString& GetBulletFont() const { return m_bulletFont; }
    const wxString& GetBulletName() const { return m_bulletName; }
    const wxString& GetURL() const { return m_urlTarget; }
    int GetTextEffects() const { return m_textEffects; }
    int GetTextEffectFlags() const { return m_textEffectFlags; }
    int GetOutlineLevel() const { return m_outlineLevel; }


    bool HasTextColour() const { return m_colText.IsOk() && HasFlag(wxTEXT_ATTR_TEXT_COLOUR) ; }
    bool HasBackgroundColour() const { return m_colBack.IsOk() && HasFlag(wxTEXT_ATTR_BACKGROUND_COLOUR) ; }
    bool HasAlignment() const { return (m_textAlignment != wxTEXT_ALIGNMENT_DEFAULT) && HasFlag(wxTEXT_ATTR_ALIGNMENT) ; }
    bool HasTabs() const { return HasFlag(wxTEXT_ATTR_TABS) ; }
    bool HasLeftIndent() const { return HasFlag(wxTEXT_ATTR_LEFT_INDENT); }
    bool HasRightIndent() const { return HasFlag(wxTEXT_ATTR_RIGHT_INDENT); }
    bool HasFontWeight() const { return HasFlag(wxTEXT_ATTR_FONT_WEIGHT); }
    bool HasFontSize() const { return HasFlag(wxTEXT_ATTR_FONT_SIZE); }
    bool HasFontPointSize() const { return HasFlag(wxTEXT_ATTR_FONT_POINT_SIZE); }
    bool HasFontPixelSize() const { return HasFlag(wxTEXT_ATTR_FONT_PIXEL_SIZE); }
    bool HasFontItalic() const { return HasFlag(wxTEXT_ATTR_FONT_ITALIC); }
    bool HasFontUnderlined() const { return HasFlag(wxTEXT_ATTR_FONT_UNDERLINE); }
    bool HasFontStrikethrough() const { return HasFlag(wxTEXT_ATTR_FONT_STRIKETHROUGH); }
    bool HasFontFaceName() const { return HasFlag(wxTEXT_ATTR_FONT_FACE); }
    bool HasFontEncoding() const { return HasFlag(wxTEXT_ATTR_FONT_ENCODING); }
    bool HasFontFamily() const { return HasFlag(wxTEXT_ATTR_FONT_FAMILY); }
    bool HasFont() const { return HasFlag(wxTEXT_ATTR_FONT); }

    bool HasParagraphSpacingAfter() const { return HasFlag(wxTEXT_ATTR_PARA_SPACING_AFTER); }
    bool HasParagraphSpacingBefore() const { return HasFlag(wxTEXT_ATTR_PARA_SPACING_BEFORE); }
    bool HasLineSpacing() const { return HasFlag(wxTEXT_ATTR_LINE_SPACING); }
    bool HasCharacterStyleName() const { return HasFlag(wxTEXT_ATTR_CHARACTER_STYLE_NAME) && !m_characterStyleName.IsEmpty(); }
    bool HasParagraphStyleName() const { return HasFlag(wxTEXT_ATTR_PARAGRAPH_STYLE_NAME) && !m_paragraphStyleName.IsEmpty(); }
    bool HasListStyleName() const { return HasFlag(wxTEXT_ATTR_LIST_STYLE_NAME) || !m_listStyleName.IsEmpty(); }
    bool HasBulletStyle() const { return HasFlag(wxTEXT_ATTR_BULLET_STYLE); }
    bool HasBulletNumber() const { return HasFlag(wxTEXT_ATTR_BULLET_NUMBER); }
    bool HasBulletText() const { return HasFlag(wxTEXT_ATTR_BULLET_TEXT); }
    bool HasBulletName() const { return HasFlag(wxTEXT_ATTR_BULLET_NAME); }
    bool HasURL() const { return HasFlag(wxTEXT_ATTR_URL); }
    bool HasPageBreak() const { return HasFlag(wxTEXT_ATTR_PAGE_BREAK); }
    bool HasTextEffects() const { return HasFlag(wxTEXT_ATTR_EFFECTS); }
    bool HasTextEffect(int effect) const { return HasFlag(wxTEXT_ATTR_EFFECTS) && ((GetTextEffectFlags() & effect) != 0); }
    bool HasOutlineLevel() const { return HasFlag(wxTEXT_ATTR_OUTLINE_LEVEL); }

    bool HasFlag(long flag) const { return (m_flags & flag) != 0; }
    void RemoveFlag(long flag) { m_flags &= ~flag; }
    void AddFlag(long flag) { m_flags |= flag; }


    bool IsCharacterStyle() const { return HasFlag(wxTEXT_ATTR_CHARACTER); }
    bool IsParagraphStyle() const { return HasFlag(wxTEXT_ATTR_PARAGRAPH); }


    bool IsDefault() const
    {
        return GetFlags() == 0;
    }




    bool Apply(const wxTextAttr& style, const wxTextAttr* compareWith = 
# 444 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 3 4
                                                                       __null
# 444 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
                                                                           );





    static wxTextAttr Merge(const wxTextAttr& base, const wxTextAttr& overlay)
    {
        return Combine(overlay, base, 
# 452 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 3 4
                                     __null
# 452 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
                                         );
    }


    void Merge(const wxTextAttr& overlay)
    {
        *this = Merge(*this, overlay);
    }




    static wxTextAttr Combine(const wxTextAttr& attr,
                              const wxTextAttr& attrDef,
                              const wxTextCtrlBase *text);


    static bool TabsEq(const wxArrayInt& tabs1, const wxArrayInt& tabs2);


    static bool RemoveStyle(wxTextAttr& destStyle, const wxTextAttr& style);


    static bool CombineBitlists(int& valueA, int valueB, int& flagsA, int flagsB);


    static bool BitlistsEqPartial(int valueA, int valueB, int flags);


    static bool SplitParaCharStyles(const wxTextAttr& style, wxTextAttr& parStyle, wxTextAttr& charStyle);

private:
    long m_flags;


    wxArrayInt m_tabs;
    int m_leftIndent;
    int m_leftSubIndent;


    int m_rightIndent;
    wxTextAttrAlignment m_textAlignment;

    int m_paragraphSpacingAfter;
    int m_paragraphSpacingBefore;
    int m_lineSpacing;
    int m_bulletStyle;
    int m_bulletNumber;
    int m_textEffects;
    int m_textEffectFlags;
    int m_outlineLevel;
    wxString m_bulletText;
    wxString m_bulletFont;
    wxString m_bulletName;
    wxString m_urlTarget;
    wxFontEncoding m_fontEncoding;


    wxColour m_colText,
                        m_colBack;
    int m_fontSize;
    wxFontStyle m_fontStyle;
    wxFontWeight m_fontWeight;
    wxFontFamily m_fontFamily;
    bool m_fontUnderlined;
    bool m_fontStrikethrough;
    wxString m_fontFaceName;


    wxString m_characterStyleName;


    wxString m_paragraphStyleName;


    wxString m_listStyleName;
};





class wxTextAreaBase
{
public:
    wxTextAreaBase() { }
    virtual ~wxTextAreaBase() { }




    virtual int GetLineLength(long lineNo) const = 0;
    virtual wxString GetLineText(long lineNo) const = 0;
    virtual int GetNumberOfLines() const = 0;





    bool LoadFile(const wxString& file, int fileType = 0)
        { return DoLoadFile(file, fileType); }
    bool SaveFile(const wxString& file = wxEmptyString,
                  int fileType = 0);




    virtual bool IsModified() const = 0;
    virtual void MarkDirty() = 0;
    virtual void DiscardEdits() = 0;
    void SetModified(bool modified)
    {
        if ( modified )
            MarkDirty();
        else
            DiscardEdits();
    }
# 577 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
    virtual bool SetStyle(long start, long end, const wxTextAttr& style) = 0;
    virtual bool GetStyle(long position, wxTextAttr& style) = 0;
    virtual bool SetDefaultStyle(const wxTextAttr& style) = 0;
    virtual const wxTextAttr& GetDefaultStyle() const { return m_defaultStyle; }
# 589 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
    virtual long XYToPosition(long x, long y) const = 0;
    virtual bool PositionToXY(long pos, long *x, long *y) const = 0;



    wxPoint PositionToCoords(long pos) const;


    virtual void ShowPosition(long pos) = 0;





    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const;
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const;
    virtual wxString GetValue() const = 0;
    virtual void SetValue(const wxString& value) = 0;

protected:

    virtual bool DoLoadFile(const wxString& file, int fileType);
    virtual bool DoSaveFile(const wxString& file, int fileType);



    virtual bool IsValidPosition(long pos) const = 0;



    virtual wxPoint DoPositionToCoords(long pos) const;



    wxString m_filename;


    wxTextAttr m_defaultStyle;


    private: wxTextAreaBase(const wxTextAreaBase&); wxTextAreaBase& operator=(const wxTextAreaBase&);
};






class wxTextCtrlIface : public wxTextAreaBase,
                                         public wxTextEntryBase
{
public:
    wxTextCtrlIface() { }


    virtual wxString GetValue() const
    {
       return wxTextEntryBase::GetValue();
    }
    virtual void SetValue(const wxString& value)
    {
       wxTextEntryBase::SetValue(value);
    }

protected:
    virtual bool IsValidPosition(long pos) const
    {
        return pos >= 0 && pos <= GetLastPosition();
    }

private:
    private: wxTextCtrlIface(const wxTextCtrlIface&); wxTextCtrlIface& operator=(const wxTextCtrlIface&);
};





class wxTextCtrlBase : public wxControl,

                                   public std:: streambuf,

                                   public wxTextAreaBase,
                                   public wxTextEntry
{
public:



    wxTextCtrlBase() { }
    virtual ~wxTextCtrlBase() { }



    bool IsSingleLine() const { return !HasFlag(0x0020); }
    bool IsMultiLine() const { return !IsSingleLine(); }



    wxTextCtrl& operator<<(const wxString& s);
    wxTextCtrl& operator<<(int i);
    wxTextCtrl& operator<<(long i);
    wxTextCtrl& operator<<(float f) { return *this << double(f); }
    wxTextCtrl& operator<<(double d);
    wxTextCtrl& operator<<(char c) { return *this << wxString(c); }
    wxTextCtrl& operator<<(wchar_t c) { return *this << wxString(c); }



    virtual bool EmulateKeyPress(const wxKeyEvent& event);



    virtual void DoUpdateWindowUI(wxUpdateUIEvent& event);

    virtual bool ShouldInheritColours() const { return false; }



    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const
    {
        return wxTextAreaBase::HitTest(pt, pos);
    }

    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const
    {
        return wxTextAreaBase::HitTest(pt, col, row);
    }



    virtual bool SetStyle(long start, long end, const wxTextAttr& style);
    virtual bool GetStyle(long position, wxTextAttr& style);
    virtual bool SetDefaultStyle(const wxTextAttr& style);


    virtual wxString GetValue() const
    {
       return wxTextEntry::GetValue();
    }
    virtual void SetValue(const wxString& value)
    {
       wxTextEntry::SetValue(value);
    }


    virtual bool SetHint(const wxString& hint);


    virtual wxVisualAttributes GetDefaultAttributes() const
    {
        return GetClassDefaultAttributes(GetWindowVariant());
    }

    static wxVisualAttributes
    GetClassDefaultAttributes(wxWindowVariant variant = wxWINDOW_VARIANT_NORMAL)
    {
        return GetCompositeControlsDefaultAttributes(variant);
    }

protected:


    int overflow(int i);



    virtual bool IsValidPosition(long pos) const
    {
        return pos >= 0 && pos <= GetLastPosition();
    }


    virtual wxWindow *GetEditableWindow() { return this; }

    private: wxTextCtrlBase(const wxTextCtrlBase&); wxTextCtrlBase& operator=(const wxTextCtrlBase&);
    public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const;
};
# 783 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
# 1 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/textctrl.h" 1
# 14 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/textctrl.h"
class wxTextCtrl : public wxTextCtrlBase
{
public:



    wxTextCtrl() { Init(); }
    wxTextCtrl(wxWindow *parent, wxWindowID id,
               const wxString& value = wxEmptyString,
               const wxPoint& pos = wxDefaultPosition,
               const wxSize& size = wxDefaultSize,
               long style = 0,
               const wxValidator& validator = wxDefaultValidator,
               const wxString& name = wxTextCtrlNameStr)
    {
        Init();

        Create(parent, id, value, pos, size, style, validator, name);
    }
    virtual ~wxTextCtrl();

    bool Create(wxWindow *parent, wxWindowID id,
                const wxString& value = wxEmptyString,
                const wxPoint& pos = wxDefaultPosition,
                const wxSize& size = wxDefaultSize,
                long style = 0,
                const wxValidator& validator = wxDefaultValidator,
                const wxString& name = wxTextCtrlNameStr);




    virtual wxString GetValue() const;
    virtual wxString GetRange(long from, long to) const;

    virtual bool IsEmpty() const;

    virtual void WriteText(const wxString& text);
    virtual void AppendText(const wxString& text);
    virtual void Clear();

    virtual int GetLineLength(long lineNo) const;
    virtual wxString GetLineText(long lineNo) const;
    virtual int GetNumberOfLines() const;

    virtual void SetMaxLength(unsigned long len);

    virtual void GetSelection(long *from, long *to) const;

    virtual void Redo();
    virtual bool CanRedo() const;

    virtual void SetInsertionPointEnd();
    virtual long GetInsertionPoint() const;
    virtual wxTextPos GetLastPosition() const;




    virtual bool IsModified() const;
    virtual void MarkDirty();
    virtual void DiscardEdits();


    virtual bool EmulateKeyPress(const wxKeyEvent& event);





    virtual bool SetStyle(long start, long end, const wxTextAttr& style);
    virtual bool SetDefaultStyle(const wxTextAttr& style);
    virtual bool GetStyle(long position, wxTextAttr& style);





    virtual long XYToPosition(long x, long y) const;
    virtual bool PositionToXY(long pos, long *x, long *y) const;

    virtual void ShowPosition(long pos);
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt, long *pos) const;
    virtual wxTextCtrlHitTestResult HitTest(const wxPoint& pt,
                                            wxTextCoord *col,
                                            wxTextCoord *row) const
    {
        return wxTextCtrlBase::HitTest(pt, col, row);
    }


    bool ShowNativeCaret(bool show = true);
    bool HideNativeCaret() { return ShowNativeCaret(false); }





    virtual void SetDropTarget(wxDropTarget *dropTarget);


    virtual void SetWindowStyleFlag(long style);

    virtual void Command(wxCommandEvent& event);
    virtual bool MSWCommand(WXUINT param, WXWORD id);
    virtual WXHBRUSH MSWControlColor(WXHDC hDC, WXHWND hWnd);


    virtual bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result);

    int GetRichVersion() const { return m_verRichEdit; }
    bool IsRich() const { return m_verRichEdit != 0; }



    virtual bool SetBackgroundColour(const wxColour& colour);
    virtual bool SetForegroundColour(const wxColour& colour);
    virtual bool SetFont(const wxFont& font);







    bool IsInkEdit() const { return false; }


    virtual void AdoptAttributesFromHWND();

    virtual bool AcceptsFocusFromKeyboard() const;


    virtual bool CanApplyThemeBorder() const;


    void OnDropFiles(wxDropFilesEvent& event);
    void OnChar(wxKeyEvent& event);

    void OnCut(wxCommandEvent& event);
    void OnCopy(wxCommandEvent& event);
    void OnPaste(wxCommandEvent& event);
    void OnUndo(wxCommandEvent& event);
    void OnRedo(wxCommandEvent& event);
    void OnDelete(wxCommandEvent& event);
    void OnSelectAll(wxCommandEvent& event);

    void OnUpdateCut(wxUpdateUIEvent& event);
    void OnUpdateCopy(wxUpdateUIEvent& event);
    void OnUpdatePaste(wxUpdateUIEvent& event);
    void OnUpdateUndo(wxUpdateUIEvent& event);
    void OnUpdateRedo(wxUpdateUIEvent& event);
    void OnUpdateDelete(wxUpdateUIEvent& event);
    void OnUpdateSelectAll(wxUpdateUIEvent& event);



    void OnContextMenu(wxContextMenuEvent& event);





    wxMenu *MSWCreateContextMenu();




    void OnSetFocus(wxFocusEvent& event);


    virtual WXLRESULT MSWWindowProc(WXUINT nMsg, WXWPARAM wParam, WXLPARAM lParam);

    virtual bool MSWShouldPreProcessMessage(WXMSG* pMsg);
    virtual WXDWORD MSWGetStyle(long style, WXDWORD *exstyle) const;

protected:

    void Init();

    virtual bool DoLoadFile(const wxString& file, int fileType);






    bool MSWCreateText(const wxString& value,
                       const wxPoint& pos,
                       const wxSize& size);

    virtual void DoSetValue(const wxString &value, int flags = 0);

    virtual wxPoint DoPositionToCoords(long pos) const;



    bool HasSpaceLimit(unsigned int *len) const;






    bool AdjustSpaceLimit();
# 231 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/msw/textctrl.h"
    void DoWriteText(const wxString& text,
                     int flags = SetValue_SendEvent | SetValue_SelectionOnly);


    void DoSetSelection(long from, long to, int flags);



    long GetLengthOfLineContainingPos(long pos) const;


    bool SendUpdateEvent();

    virtual wxSize DoGetBestSize() const;
    virtual wxSize DoGetSizeFromTextSize(int xlen, int ylen = -1) const;







    bool MSWSetCharFormat(const wxTextAttr& attr, long from = -1, long to = -1);




    bool MSWSetParaFormat(const wxTextAttr& attr, long from, long to);






    int m_verRichEdit;




    int m_updatesCount;

private:
    virtual void EnableTextChangedEvents(bool enable)
    {
        m_updatesCount = enable ? -1 : -2;
    }



    virtual WXHWND GetEditHWND() const { return m_hWnd; }

    void OnKeyDown(wxKeyEvent& event);

    private: static const wxEventTableEntry sm_eventTableEntries[]; protected: static const wxEventTable sm_eventTable; virtual const wxEventTable* GetEventTable() const; static wxEventHashTable sm_eventHashTable; virtual wxEventHashTable& GetEventHashTable() const;
    private: wxTextCtrl(const wxTextCtrl&); wxTextCtrl& operator=(const wxTextCtrl&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

    wxMenu* m_privateContextMenu;

    bool m_isNativeCaretShown;





};
# 784 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h" 2
# 802 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
class wxTextUrlEvent;

extern const wxEventTypeTag< wxCommandEvent > wxEVT_TEXT;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TEXT_ENTER;
extern const wxEventTypeTag< wxTextUrlEvent > wxEVT_TEXT_URL;
extern const wxEventTypeTag< wxCommandEvent > wxEVT_TEXT_MAXLEN;

class wxTextUrlEvent : public wxCommandEvent
{
public:
    wxTextUrlEvent(int winid, const wxMouseEvent& evtMouse,
                   long start, long end)
        : wxCommandEvent(wxEVT_TEXT_URL, winid),
          m_evtMouse(evtMouse), m_start(start), m_end(end)
        { }
    wxTextUrlEvent(const wxTextUrlEvent& event)
        : wxCommandEvent(event),
          m_evtMouse(event.m_evtMouse),
          m_start(event.m_start),
          m_end(event.m_end) { }


    const wxMouseEvent& GetMouseEvent() const { return m_evtMouse; }


    long GetURLStart() const { return m_start; }


    long GetURLEnd() const { return m_end; }

    virtual wxEvent *Clone() const { return new wxTextUrlEvent(*this); }

protected:

    wxMouseEvent m_evtMouse;


    long m_start,
         m_end;

private:
    private: wxTextUrlEvent& operator=(const wxTextUrlEvent&); public: static wxClassInfo ms_classInfo; virtual wxClassInfo *GetClassInfo() const; static wxObject* wxCreateObject();

public:

    wxTextUrlEvent() : m_evtMouse(), m_start(0), m_end(0) { }
};

typedef void (wxEvtHandler::*wxTextUrlEventFunction)(wxTextUrlEvent&);
# 874 "..\\wxMSW-3.0.5_gcc810_x64_Dev\\include/wx/textctrl.h"
class wxStreamToTextRedirector
{
private:
    void Init(wxTextCtrl *text)
    {
        m_sbufOld = m_ostr.rdbuf();
        m_ostr.rdbuf(text);
    }

public:
    wxStreamToTextRedirector(wxTextCtrl *text)
        : m_ostr(std:: cout)
    {
        Init(text);
    }

    wxStreamToTextRedirector(wxTextCtrl *text, std:: ostream *ostr)
        : m_ostr(*ostr)
    {
        Init(text);
    }

    ~wxStreamToTextRedirector()
    {
        m_ostr.rdbuf(m_sbufOld);
    }

private:

    std:: ostream& m_ostr;


    std:: streambuf *m_sbufOld;
};
# 7 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\GeradorTabular.h" 2

class GeradorTabular
{
    public:
        GeradorTabular(wxTextCtrl *textoTabela);
        virtual void gerarTabela(CalculadorAtmosferico *calculador, double velocidade, TIPO_TRAJETORIA trajetoria = TIPO_TRAJETORIA::MERGULHANTE, double passo = 0.1, double precisao = 5) = 0;
        void setParar(bool parar){this->parar = parar;}
    protected:

        wxTextCtrl *textoTabela;
        bool parar;


    private:
};
# 5 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.h" 2


class GeradorTabularI : public GeradorTabular
{
    public:
        GeradorTabularI(wxTextCtrl *textoTabela);
        void gerarTabela(CalculadorAtmosferico *calculador, double velocidade, TIPO_TRAJETORIA trajetoria, double passo, double precisao) override;

    protected:

    private:
};
# 2 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp" 2
# 1 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 1




# 1 "..\\..\\CalculadorNumerico/projetil/projetil.h" 1
# 6 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/projetil/ProjetilDAO.h" 1


# 1 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h" 1
# 35 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 1 3 4
# 1 "C:/Program Files/CodeBlocks/MinGW/x86_64-w64-mingw32/include/stdarg.h" 1 3 4
# 2 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/stdarg.h" 2 3 4
# 36 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h" 2





extern "C" {
# 158 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 extern const char sqlite3_version[];
 const char *sqlite3_libversion(void);
 const char *sqlite3_sourceid(void);
 int sqlite3_libversion_number(void);
# 186 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_compileoption_used(const char *zOptName);
 const char *sqlite3_compileoption_get(int N);
# 226 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_threadsafe(void);
# 242 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3 sqlite3;
# 271 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;

typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
# 327 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_close(sqlite3*);
 int sqlite3_close_v2(sqlite3*);






typedef int (*sqlite3_callback)(void*,int,char**, char**);
# 399 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
# 653 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
# 751 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);

  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
  void (*xShmBarrier)(sqlite3_file*);
  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);

  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);


};
# 1063 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_mutex sqlite3_mutex;
# 1073 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_api_routines sqlite3_api_routines;
# 1232 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);




  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);




  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);





};
# 1410 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_initialize(void);
 int sqlite3_shutdown(void);
 int sqlite3_os_init(void);
 int sqlite3_os_end(void);
# 1446 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_config(int, ...);
# 1465 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_db_config(sqlite3*, int op, ...);
# 1530 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
# 2029 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_extended_result_codes(sqlite3*, int onoff);
# 2091 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
# 2101 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);
# 2154 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_changes(sqlite3*);
# 2178 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_total_changes(sqlite3*);
# 2215 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_interrupt(sqlite3*);
# 2250 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_complete(const char *sql);
 int sqlite3_complete16(const void *sql);
# 2312 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);
# 2335 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_busy_timeout(sqlite3*, int ms);
# 2410 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
 void sqlite3_free_table(char **result);
# 2524 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 char *sqlite3_mprintf(const char*,...);
 char *sqlite3_vmprintf(const char*, va_list);
 char *sqlite3_snprintf(int,char*,const char*, ...);
 char *sqlite3_vsnprintf(int,char*,const char*, va_list);
# 2617 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_malloc(int);
 void *sqlite3_malloc64(sqlite3_uint64);
 void *sqlite3_realloc(void*, int);
 void *sqlite3_realloc64(void*, sqlite3_uint64);
 void sqlite3_free(void*);
 sqlite3_uint64 sqlite3_msize(void*);
# 2647 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_int64 sqlite3_memory_used(void);
 sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
# 2671 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_randomness(int N, void *P);
# 2761 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
# 2869 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_trace(sqlite3*,
   void(*xTrace)(void*,const char*), void*);
 void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
# 2960 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_trace_v2(
  sqlite3*,
  unsigned uMask,
  int(*xCallback)(unsigned,void*,void*,void*),
  void *pCtx
);
# 2999 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
# 3228 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
 int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
 int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
# 3282 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
 int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
 sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
# 3328 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_errcode(sqlite3 *db);
 int sqlite3_extended_errcode(sqlite3 *db);
 const char *sqlite3_errmsg(sqlite3*);
 const void *sqlite3_errmsg16(sqlite3*);
 const char *sqlite3_errstr(int);
# 3358 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_stmt sqlite3_stmt;
# 3400 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_limit(sqlite3*, int id, int newVal);
# 3553 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
 int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
# 3613 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_sql(sqlite3_stmt *pStmt);
 char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
# 3650 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
# 3671 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_stmt_busy(sqlite3_stmt*);
# 3712 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_value sqlite3_value;
# 3726 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_context sqlite3_context;
# 3835 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
 int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
 int sqlite3_bind_double(sqlite3_stmt*, int, double);
 int sqlite3_bind_int(sqlite3_stmt*, int, int);
 int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
 int sqlite3_bind_null(sqlite3_stmt*, int);
 int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
 int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
 int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
 int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
 int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
# 3869 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_bind_parameter_count(sqlite3_stmt*);
# 3897 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
# 3914 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
# 3924 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_clear_bindings(sqlite3_stmt*);
# 3940 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_column_count(sqlite3_stmt *pStmt);
# 3969 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_column_name(sqlite3_stmt*, int N);
 const void *sqlite3_column_name16(sqlite3_stmt*, int N);
# 4018 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_column_database_name(sqlite3_stmt*,int);
 const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_table_name(sqlite3_stmt*,int);
 const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
 const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
# 4055 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_column_decltype(sqlite3_stmt*,int);
 const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
# 4137 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_step(sqlite3_stmt*);
# 4158 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_data_count(sqlite3_stmt *pStmt);
# 4348 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
 double sqlite3_column_double(sqlite3_stmt*, int iCol);
 int sqlite3_column_int(sqlite3_stmt*, int iCol);
 sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
 const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
 const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
 int sqlite3_column_type(sqlite3_stmt*, int iCol);
 sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
# 4385 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_finalize(sqlite3_stmt *pStmt);
# 4412 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_reset(sqlite3_stmt *pStmt);
# 4512 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
 int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
 int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void(*xDestroy)(void*)
);
# 4578 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_aggregate_count(sqlite3_context*);
 int sqlite3_expired(sqlite3_stmt*);
 int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
 int sqlite3_global_recover(void);
 void sqlite3_thread_cleanup(void);
 int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                      void*,sqlite3_int64);
# 4633 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const void *sqlite3_value_blob(sqlite3_value*);
 int sqlite3_value_bytes(sqlite3_value*);
 int sqlite3_value_bytes16(sqlite3_value*);
 double sqlite3_value_double(sqlite3_value*);
 int sqlite3_value_int(sqlite3_value*);
 sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
 const unsigned char *sqlite3_value_text(sqlite3_value*);
 const void *sqlite3_value_text16(sqlite3_value*);
 const void *sqlite3_value_text16le(sqlite3_value*);
 const void *sqlite3_value_text16be(sqlite3_value*);
 int sqlite3_value_type(sqlite3_value*);
 int sqlite3_value_numeric_type(sqlite3_value*);
# 4660 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 unsigned int sqlite3_value_subtype(sqlite3_value*);
# 4676 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
 void sqlite3_value_free(sqlite3_value*);
# 4722 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
# 4737 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_user_data(sqlite3_context*);
# 4749 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
# 4808 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_get_auxdata(sqlite3_context*, int N);
 void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
# 4826 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef void (*sqlite3_destructor_type)(void*);
# 4945 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_blob64(sqlite3_context*,const void*,
                           sqlite3_uint64,void(*)(void*));
 void sqlite3_result_double(sqlite3_context*, double);
 void sqlite3_result_error(sqlite3_context*, const char*, int);
 void sqlite3_result_error16(sqlite3_context*, const void*, int);
 void sqlite3_result_error_toobig(sqlite3_context*);
 void sqlite3_result_error_nomem(sqlite3_context*);
 void sqlite3_result_error_code(sqlite3_context*, int);
 void sqlite3_result_int(sqlite3_context*, int);
 void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
 void sqlite3_result_null(sqlite3_context*);
 void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
 void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                           void(*)(void*), unsigned char encoding);
 void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
 void sqlite3_result_zeroblob(sqlite3_context*, int n);
 int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
# 4980 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_result_subtype(sqlite3_context*,unsigned int);
# 5062 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
 int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
 int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
# 5112 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
 int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
# 5195 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_sleep(int);
# 5253 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 extern char *sqlite3_temp_directory;
# 5290 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 extern char *sqlite3_data_directory;
# 5314 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_get_autocommit(sqlite3*);
# 5327 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
# 5344 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);
# 5354 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
# 5370 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
# 5419 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
 void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
# 5471 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
# 5512 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_enable_shared_cache(int);
# 5528 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_release_memory(int);
# 5542 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_db_release_memory(sqlite3*);
# 5595 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
# 5606 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_soft_heap_limit(int N);
# 5676 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
# 5732 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
# 5764 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
# 5802 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_auto_extension(void(*xEntryPoint)(void));
# 5814 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));







 void sqlite3_reset_auto_extension(void);
# 5836 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
# 5857 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);


  int (*xSavepoint)(sqlite3_vtab *pVTab, int);
  int (*xRelease)(sqlite3_vtab *pVTab, int);
  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);
};
# 5988 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct sqlite3_index_info {

  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;

  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;

  sqlite3_int64 estimatedRows;

  int idxFlags;

  sqlite3_uint64 colUsed;
};
# 6069 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
 int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
# 6101 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;

};
# 6125 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;

};
# 6138 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
# 6157 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
# 6181 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_blob sqlite3_blob;
# 6266 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
# 6299 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
# 6322 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_close(sqlite3_blob *);
# 6338 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_bytes(sqlite3_blob *);
# 6367 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
# 6409 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
# 6440 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
 int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
 int sqlite3_vfs_unregister(sqlite3_vfs*);
# 6558 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_mutex *sqlite3_mutex_alloc(int);
 void sqlite3_mutex_free(sqlite3_mutex*);
 void sqlite3_mutex_enter(sqlite3_mutex*);
 int sqlite3_mutex_try(sqlite3_mutex*);
 void sqlite3_mutex_leave(sqlite3_mutex*);
# 6629 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
# 6672 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_mutex_held(sqlite3_mutex*);
 int sqlite3_mutex_notheld(sqlite3_mutex*);
# 6713 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
# 6748 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
# 6767 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_test_control(int op, ...);
# 6831 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
 int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
);
# 6957 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
# 7100 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
# 7155 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_pcache sqlite3_pcache;
# 7167 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;
  void *pExtra;
};
# 7332 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};






typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
# 7381 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_backup sqlite3_backup;
# 7569 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
 int sqlite3_backup_step(sqlite3_backup *p, int nPage);
 int sqlite3_backup_finish(sqlite3_backup *p);
 int sqlite3_backup_remaining(sqlite3_backup *p);
 int sqlite3_backup_pagecount(sqlite3_backup *p);
# 7695 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
# 7710 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_stricmp(const char *, const char *);
 int sqlite3_strnicmp(const char *, const char *, int);
# 7728 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_strglob(const char *zGlob, const char *zStr);
# 7751 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);
# 7774 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_log(int iErrCode, const char *zFormat, ...);
# 7810 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void *sqlite3_wal_hook(
  sqlite3*,
  int(*)(void *,sqlite3*,const char*,int),
  void*
);
# 7845 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
# 7867 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
# 7961 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
);
# 7997 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_vtab_config(sqlite3*, int op, ...);
# 8050 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_vtab_on_conflict(sqlite3 *);
# 8155 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,
  int idx,
  int iScanStatusOp,
  void *pOut
);
# 8171 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
# 8203 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_db_cacheflush(sqlite3*);
# 8317 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_system_errno(sqlite3*);
# 8345 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct sqlite3_snapshot {
  unsigned char hidden[48];
} sqlite3_snapshot;
# 8392 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_snapshot_get(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot **ppSnapshot
);
# 8430 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_snapshot_open(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot *pSnapshot
);
# 8447 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 void sqlite3_snapshot_free(sqlite3_snapshot*);
# 8471 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_snapshot_cmp(
  sqlite3_snapshot *p1,
  sqlite3_snapshot *p2
);
# 8496 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
# 8507 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
}
# 8530 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
extern "C" {


typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;
typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;







  typedef double sqlite3_rtree_dbl;
# 8551 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
 int sqlite3_rtree_geometry_callback(
  sqlite3 *db,
  const char *zGeom,
  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
  void *pContext
);






struct sqlite3_rtree_geometry {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void *);
};







 int sqlite3_rtree_query_callback(
  sqlite3 *db,
  const char *zQueryFunc,
  int (*xQueryFunc)(sqlite3_rtree_query_info*),
  void *pContext,
  void (*xDestructor)(void*)
);
# 8595 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct sqlite3_rtree_query_info {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void*);
  sqlite3_rtree_dbl *aCoord;
  unsigned int *anQueue;
  int nCoord;
  int iLevel;
  int mxLevel;
  sqlite3_int64 iRowid;
  sqlite3_rtree_dbl rParentScore;
  int eParentWithin;
  int eWithin;
  sqlite3_rtree_dbl rScore;

  sqlite3_value **apSqlParam;
};
# 8624 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
}
# 9946 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
extern "C" {
# 9956 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct Fts5ExtensionApi Fts5ExtensionApi;
typedef struct Fts5Context Fts5Context;
typedef struct Fts5PhraseIter Fts5PhraseIter;

typedef void (*fts5_extension_function)(
  const Fts5ExtensionApi *pApi,
  Fts5Context *pFts,
  sqlite3_context *pCtx,
  int nVal,
  sqlite3_value **apVal
);

struct Fts5PhraseIter {
  const unsigned char *a;
  const unsigned char *b;
};
# 10188 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
struct Fts5ExtensionApi {
  int iVersion;

  void *(*xUserData)(Fts5Context*);

  int (*xColumnCount)(Fts5Context*);
  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

  int (*xTokenize)(Fts5Context*,
    const char *pText, int nText,
    void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int)
  );

  int (*xPhraseCount)(Fts5Context*);
  int (*xPhraseSize)(Fts5Context*, int iPhrase);

  int (*xInstCount)(Fts5Context*, int *pnInst);
  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

  sqlite3_int64 (*xRowid)(Fts5Context*);
  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);

  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*xGetAuxdata)(Fts5Context*, int bClear);

  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);
};
# 10422 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct Fts5Tokenizer Fts5Tokenizer;
typedef struct fts5_tokenizer fts5_tokenizer;
struct fts5_tokenizer {
  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*,
      void *pCtx,
      int flags,
      const char *pText, int nText,
      int (*xToken)(
        void *pCtx,
        int tflags,
        const char *pToken,
        int nToken,
        int iStart,
        int iEnd
      )
  );
};
# 10459 "..\\..\\CalculadorNumerico/projetil/../sql/sqlite3.h"
typedef struct fts5_api fts5_api;
struct fts5_api {
  int iVersion;


  int (*xCreateTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_tokenizer *pTokenizer,
    void (*xDestroy)(void*)
  );


  int (*xFindTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void **ppContext,
    fts5_tokenizer *pTokenizer
  );


  int (*xCreateFunction)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_extension_function xFunction,
    void (*xDestroy)(void*)
  );
};






}
# 4 "..\\..\\CalculadorNumerico/projetil/ProjetilDAO.h" 2
# 1 "..\\..\\CalculadorNumerico/projetil/../projetil/projetil.h" 1
# 5 "..\\..\\CalculadorNumerico/projetil/ProjetilDAO.h" 2

class ProjetilDAO
{
    public:
        static ProjetilDAO* getInstance();
        static void clearInstance();
        Projetil geraProjetil(Projetil &projetil);
    private:
        ProjetilDAO();
        ~ProjetilDAO();
        static int callback(void *data, int argc, char **argv, char **azColName);
        sqlite3 *db;
        Projetil proj;
        static ProjetilDAO* instance;
        const char *idStr = "_id", *diametroStr = "diametro", *nomeStr = "nome", *massaStr = "massa", *ixStr = "ix",
                    *tabelaCoeficientesStr = "tabela_coeficientes", *quadradosPadraoStr = "quadrados_padrao",
                     *massaQuadradoStr = "massa_quadrado", *tipoForcasStr = "tipo_forcas";
};
# 7 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosfera.h" 1
# 8 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosferaconstante.h" 1



# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosfera.h" 1
# 5 "..\\..\\CalculadorNumerico/atmosfera/atmosferaconstante.h" 2




class AtmosferaConstante : public Atmosfera
{
public:
    AtmosferaConstante();
    double temperatura(double altitude);
    double velocidadeSom(double altitude);
    double densidade(double altitude);
    std::string toString(){return "Constante";}
};
# 9 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosferaicao.h" 1
# 10 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosferaisa.h" 1
# 11 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/atmosfera/atmosferausstandard.h" 1
# 12 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/coeficientes/coeficientesdao.h" 1




# 1 "..\\..\\CalculadorNumerico/coeficientes/../sql/sqlite3.h" 1
# 6 "..\\..\\CalculadorNumerico/coeficientes/coeficientesdao.h" 2
# 1 "..\\..\\CalculadorNumerico/coeficientes/../projetil/projetil.h" 1
# 7 "..\\..\\CalculadorNumerico/coeficientes/coeficientesdao.h" 2
# 1 "..\\..\\CalculadorNumerico/coeficientes/coeficienteAerodinamico.h" 1



# 1 "..\\..\\CalculadorNumerico/coeficientes/../padroes/baseobject.h" 1
# 5 "..\\..\\CalculadorNumerico/coeficientes/coeficienteAerodinamico.h" 2

enum class TIPO_COEFICIENTE {DRAG, DRAG_LINEAR, DRAG2, MAGNUS_FORCE, LIFT, OVERTURNING_MOMENT, OVERTURNING_MOMENT_CUBICO, SPIN_DAMPING_MOMENT};
using namespace std;
class CoeficienteAerodinamico: public BaseObject
{
    public:
        CoeficienteAerodinamico(){}
        CoeficienteAerodinamico(TIPO_COEFICIENTE tipo);
        virtual ~CoeficienteAerodinamico();

        TIPO_COEFICIENTE tipo;
        vector<double> getVelocidades(){return velocidades;}
        vector<double> getValores(){return valores;}

        vector<double> *getPointerVelocidades(){return &velocidades;}
        vector<double> *getPointerValores(){return &valores;}

        double getValor(double velocidade);
        void limpar();

    protected:
        vector<double> velocidades;
        vector<double> valores;
    private:
};
# 8 "..\\..\\CalculadorNumerico/coeficientes/coeficientesdao.h" 2




class CoeficientesDAO
{
    public:
       static CoeficientesDAO* getInstance();
       static void clearInstance();
       void setProjetil(TIPO_PROJETIL tipoProjetil);
       Projetil getProjetil(){return this->proj;}
       CoeficienteAerodinamico geraCoeficiente(CoeficienteAerodinamico &coeficiente);

    private:
        CoeficientesDAO();
        ~CoeficientesDAO();
        static int callback(void *data, int argc, char **argv, char **azColName);
        static CoeficientesDAO* instance;
        sqlite3 *db;
        Projetil proj;
        const char *idStr = "_id", *velStr = "velocidade";
};
# 13 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/coeficientes/CoeficienteDrag.h" 1






class CoeficienteDrag : public CoeficienteAerodinamico
{
    public:
        CoeficienteDrag();
    protected:
    private:

};
# 14 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/coeficientes/CoeficienteDragLinear.h" 1






class CoeficienteDragLinear: public CoeficienteAerodinamico
{
    public:
        CoeficienteDragLinear();


    protected:

    private:

};
# 15 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassa.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/calculadorAtmosferico.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassa.h" 2

# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/CoeficienteDrag.h" 1
# 7 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassa.h" 2


class CalculadorPontoMassa: public CalculadorAtmosferico
{
public:


    public:
        CalculadorPontoMassa();
        vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE);

        void setProjetil(Projetil projetil);



    protected:

        double acx( double vx, double vy, double vz, double altitude, double distancia);
        double acy( double vx, double vy, double vz, double altitude);
        double acz( double vx, double vy, double vz, double altitude, double distancia);
        CoeficienteDrag coefDrag;





};
# 16 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassa.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteDrag2.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteAerodinamico.h" 1
# 5 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteDrag2.h" 2
class CoeficienteDrag2: public CoeficienteAerodinamico
{
    public:
        CoeficienteDrag2();

    protected:

    private:
};
# 6 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteMagnusForce.h" 1





class CoeficienteMagnusForce: public CoeficienteAerodinamico
{
    public:
        CoeficienteMagnusForce();

    protected:

    private:
};
# 7 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteNormal.h" 1




class CoeficienteLift: public CoeficienteAerodinamico
{
    public:
        CoeficienteLift();

    protected:

    private:
};
# 8 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteOverturningMoment.h" 1




class CoeficienteOverturningMoment: public CoeficienteAerodinamico
{
    public:
        CoeficienteOverturningMoment();

    protected:

    private:
};
# 9 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteOverturningMomentCubico.h" 1




class CoeficienteOverturningMomentCubico: public CoeficienteAerodinamico
{
    public:
        CoeficienteOverturningMomentCubico();

    protected:

    private:
};
# 10 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteSpinDampingMoment.h" 1




class CoeficienteSpinDampingMoment: public CoeficienteAerodinamico
{
    public:
        CoeficienteSpinDampingMoment();

    protected:

    private:
};
# 11 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordeforma.h" 1



# 1 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordeajuste.h" 1


# 1 "C:/temp/ballisticKernelCpp/CalculadorNumerico/padroes/baseobject.h" 1
# 4 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordeajuste.h" 2




enum class TIPO_FATOR {FATOR_DE_FORMA, FATOR_DE_LIFT, FATOR_DE_YAW_DRAG};
class FatorDeAjuste : public BaseObject
{
    public:
        FatorDeAjuste();
        virtual ~FatorDeAjuste();

        TIPO_FATOR getTipo(){return tipo;}
        void setTipo(TIPO_FATOR tipo){this->tipo = tipo;}
        double getValor(){ return valor; }
        void setValor(double valor){ this->valor = valor; }
        std::vector<double> *getPointerVelocidades(){return &velocidades;}
        std::vector<std::vector<double>> *getPointerPolinomios(){return &polinomios;}
        double calculaValorFator(double angulo, double velocidade);
        double calculaValorPolinomio(double angulo, std::vector<double> polinomio);
        void limpar();
        std::vector<double> velocidades;
        std::vector<std::vector<double>> polinomios;
    private:
        double valor;
        TIPO_FATOR tipo;
};

std::vector<std::vector<double>> generateCubicSpline(FatorDeAjuste *fat,double angulo);
# 5 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordeforma.h" 2


class FatorDeForma : public FatorDeAjuste
{
    public:
        FatorDeForma();
    protected:
    private:

};
# 12 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordelift.h" 1






class FatorDeLift : public FatorDeAjuste
{
    public:
        FatorDeLift();
    protected:
    private:

};
# 13 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/../fatoresdeajuste/fatordeyawdrag.h" 1






class FatorDeYawDrag : public FatorDeAjuste
{
    public:
        FatorDeYawDrag();
    protected:
    private:

};
# 14 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado.h" 2
class CalculadorPontoMassaModificado:public CalculadorPontoMassa
{
    public:
        CalculadorPontoMassaModificado();
        vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE);
        ElementosDisparo solucaoReversa(double alcance, double vo, double desnivel, TIPO_TRAJETORIA trajetoria, double passo, double precisao, double angulo_inicial = 1.0, RAMO ramo = DESCENDENTE);
        void setUsaFatores(bool usaFatores){this->usaFatores = usaFatores;}
        void setUsaFatoresConsultados(bool usaFatoresConsultados){this->usaFatoresConsultados = usaFatoresConsultados;}
        bool getUsaFatores(){return usaFatores;}
        bool getUsaFatoresConsultados(){return usaFatoresConsultados;}
        void setFatores(double angulo, double vo);
        void setProjetil(Projetil projetil);
        double getTwist(){return twist;}
        void setTwist(double twist){this->twist = twist;}
        FatorDeForma fatForma;
        FatorDeYawDrag fatYawDrag;
        FatorDeLift fatLift;

    protected:

        double acx( double vx, double vy, double vz, double arx, double ary, double arz, double altitude, double distancia, double arTotal, double spinRate);
        double acy( double vx, double vy, double vz, double arx, double ary, double arz, double altitude, double arTotal, double spinRate);
        double acz( double vx, double vy, double vz, double arx, double ary, double arz, double altitude, double distancia, double arTotal, double spinRate);

        double ar(double vx, double vy, double vz, double ax, double ay, double az, double altitude, double arTotal, double spinRate);
        double ar_x(double vx, double vy, double vz, double ax, double ay, double az, double altitude, double arTotal, double spinRate);
        double ar_y(double vx, double vy, double vz, double ax, double ay, double az, double altitude, double arTotal, double spinRate);
        double ar_z(double vx, double vy, double vz, double ax, double ay, double az, double altitude, double arTotal, double spinRate);



        CoeficienteDrag2 coefDrag2;
        CoeficienteMagnusForce coefMagnusForce;
        CoeficienteLift coefLift;
        CoeficienteOverturningMoment coefOverturningMoment;

        CoeficienteSpinDampingMoment coefSpinDampingMoment;
        int twist;

        double getDragTotal(double velMach, double ar);
        double getLiftTotal(double velMach, double ar);
        double getOverturningMomentTotal(double velMach, double ar);


    private:

        double ar0(double vx, double vy);
        bool usaFatores;
        bool usaFatoresConsultados;
};
# 17 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado1990.h" 1




# 1 "..\\..\\CalculadorNumerico/calculador/CalculadorPontoMassaModificado.h" 1
# 6 "..\\..\\CalculadorNumerico/calculador/calculadorPontoMassaModificado1990.h" 2


class CalculadorPontoMassaModificado1990 : public CalculadorPontoMassaModificado
{
    public:
        CalculadorPontoMassaModificado1990();
        vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE);


    protected:
        double ar_x(double vx, double vy, double vz, double altitude, double lateral, double arTotal, double spinRate);
        double ar_y(double vx, double vy, double vz, double distancia, double altitude, double lateral, double arTotal, double spinRate);
        double ar_z(double vx, double vy, double vz, double distancia, double altitude, double arTotal, double spinRate);


    private:
};
# 18 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/calculadorArrastoLinear.h" 1




# 1 "..\\..\\CalculadorNumerico/calculador/../coeficientes/coeficienteDragLinear.h" 1
# 6 "..\\..\\CalculadorNumerico/calculador/calculadorArrastoLinear.h" 2


class CalculadorArrastoLinear : public CalculadorAtmosferico
{
    public:
        CalculadorArrastoLinear();
        vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE);
        void setProjetil(Projetil projetil);
        void setDrag(double drag){dragAtual = drag;}
        double getDrag(){return dragAtual;}


    protected:

        double acx( double vx, double vy, double vz, double altitude, double distancia);
        double acy( double vx, double vy, double vz, double altitude);
        double acz( double vx, double vy, double vz, double altitude, double distancia);


    private:
        CoeficienteDragLinear coefDragLinear;
        double dragAtual;
};
# 19 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/calculador/calculadorVacuo.h" 1







class CalculadorVacuo:public Calculador
{
    public:
        CalculadorVacuo();


        vector <ElementosVoo> solucaoDireta(double angulo, double vo, double desnivel, double passo, bool registrarElementosIntermediarios = true, RAMO ramo = DESCENDENTE);
        ElementosDisparo solucaoReversa(double alcance, double vo, double desnivel, TIPO_TRAJETORIA trajetoria, double passo, double precisao, double angulo_inicial = 1.0, RAMO ramo = DESCENDENTE);

    protected:

    private:
};
# 20 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "..\\..\\CalculadorNumerico/fatoresdeajuste/calculadorFator.h" 1


# 1 "..\\..\\CalculadorNumerico/fatoresdeajuste/../projetil/projetil.h" 1
# 4 "..\\..\\CalculadorNumerico/fatoresdeajuste/calculadorFator.h" 2
# 1 "..\\..\\CalculadorNumerico/fatoresdeajuste/../calculador/calculadorPontoMassaModificado.h" 1
# 5 "..\\..\\CalculadorNumerico/fatoresdeajuste/calculadorFator.h" 2


# 1 "..\\..\\CalculadorNumerico/fatoresdeajuste/../sql/sqlite3.h" 1
# 8 "..\\..\\CalculadorNumerico/fatoresdeajuste/calculadorFator.h" 2
class CalculadorFator{
public:
    CalculadorFator(){calcPM.setUsaFatores(true); passo = 0.01; calcPM.setTwist(18);}
    void calculaValor(int posicao);
    void clearAll();
    void setVelocidade(double velocidade){this->velocidade = velocidade;}
    void setElevacoes(std::vector<double> elevacoes){this->elevacoes = elevacoes;}
    void setAlcances(std::vector<double> alcances){this->alcances = alcances;}
    void setDerivas(std::vector<double> derivas){this->derivas = derivas;}
    void setPasso(double passo){this->passo = passo;}
    void setTwist(int twist){calcPM.setTwist(twist);}
    void calculaPolinomios();
    bool inserirPolimonios();
    void setProjetil(Projetil projetil){calcPM.setProjetil(projetil); this->projetil = projetil;}
    std::vector<double> polinomioLift, polinomioForma, fatLift, fatForma;
    double velocidade;
private:
    std::vector<double> calculaPolinomio(std::vector<double> &fator);
    std::pair<double,double> metodoNewton(double &fatForma, double &fatLift, int posicao);

    std::vector<double> elevacoes, alcances, derivas;
    CalculadorPontoMassaModificado calcPM;
    sqlite3 *db;
    Projetil projetil;
    double passo;
};
# 21 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
# 1 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/configuracao.h" 1


# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3





# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 1 3
# 58 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
       
# 59 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
# 69 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 1 3
# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3

# 67 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3
namespace std
{


  namespace rel_ops
  {
# 85 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 2 3
# 82 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
namespace std
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
# 148 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }
# 293 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
  template<size_t... _Indexes> struct _Index_tuple { };
# 302 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };
# 397 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/utility" 3

}
# 39 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 1 3
# 32 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
       
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
# 43 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
namespace std
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline






    void

    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }
# 305 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/array" 3
  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }


}

namespace std
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/uses_allocator.h" 1 3
# 35 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/uses_allocator.h" 3
namespace std
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };







  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };
# 156 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/uses_allocator.h" 3
  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 2 3
# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/invoke.h" 1 3
# 33 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/invoke.h" 3
       
# 34 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/invoke.h" 3







namespace std
{

# 52 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 2 3

namespace std
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };
# 889 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1278 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }
# 1382 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline





    void

    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1632 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3
  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1711 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/tuple" 3

}
# 4 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/configuracao.h" 2

# 1 "..\\..\\CalculadorNumerico/calculador/calculador.h" 1
# 6 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/configuracao.h" 2


# 7 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/configuracao.h"
enum TIPO_CALCULADOR {VACUO, DRAG_LINEAR, PONTO_MASSA, PONTO_MASSA_MODIFICADO, PONTO_MASSA_MODIFICADO_1990};
enum TIPO_ATMOSFERA {ICAO, ISA, US_STANDARD, CONSTANTE};

class Configuracao
{
    public:
        Configuracao();
        static Configuracao* getInstance();
        double getAnguloDisparo(){return anguloDisparo;}
        void setAnguloDiparo(double angulo){ anguloDisparo = angulo;}
        double getAnguloInicial(){return anguloInicial;}
        void setAnguloInicial(double angulo){ anguloInicial = angulo;}
        double getAlcance(){return alcance;}
        void setAlcance(double alcance){this->alcance = alcance;}
        double getDeltaPesoFormFactor(){return this->deltaPesoFormFactor;}
        void setDeltaPesoFormFactor(double formFactor){deltaPesoFormFactor = formFactor;}
        double getDesnivel(){return desnivel;}
        void setDesnivel(double desnivel){this->desnivel = desnivel;}
        double getDesvioProvavelDirecaoFatorAjuste(){return desvioProvavelDirecaoFatorAjuste;}
        void setDesvioProvavelDirecaoFatorAjuste(double fator){desvioProvavelDirecaoFatorAjuste = fator;}
        double getDesvioProvavelElevacao(){return desvioProvavelElevacao;}
        void setDesvioProvavelElevacao(double desvio){ desvioProvavelElevacao = desvio;}
        double getDesvioProvavelArrasto(){return desvioProvavelArrasto;}
        void setDesvioProvavelArrasto(double desvio){desvioProvavelArrasto = desvio;}
        double getDesvioProvavelVelocidade(){return desvioProvavelVelocidade;}
        void setDesvioProvavelVelocidade(double desvio){desvioProvavelVelocidade = desvio;}
        std::tuple<double, double> getDeltaVoTemperaturaPropelelente(){return deltaVoTemperatura;}
        double getDeltaVoTemperaturaPropelelente(int indice);
        void setDeltaVoTemperaturaPropelelente(int indice, double valor);
        double getMassaPropelente(){return massaPropelente;}
        std::tuple<double, double> getTemperaturaPropelelente( ){return temperaturaPropelente;}
        void setMassaPropelente(double massa){massaPropelente = massa;}
        double getTemperaturaPropelelente(int indice);
        void setTemperaturaPropelelente(int indice, double valor);
        TIPO_TRAJETORIA getTrajetoria(){return trajetoria;}
        void setTrajetoria(TIPO_TRAJETORIA trajetoria){this->trajetoria = trajetoria;}
        double getPasso(){return passo;}
        void setPasso(double passo){this->passo = passo;}
        double getPrecisao(){return precisao;}
        void setPrecisao(double precisao){this->precisao = precisao;}
        double getVelocidadeInicial(){return velocidadeInicial;}
        void setVelocidadeInicial (double velocidade){velocidadeInicial = velocidade;}
        TIPO_ATMOSFERA getTipoAtmosfera(){return tipoAtmosfera;}
        void setTipoAtmosfera(TIPO_ATMOSFERA tipoAtmosfera){this->tipoAtmosfera = tipoAtmosfera;}
        TIPO_CALCULADOR getTipoCalculador(){return tipoCalculador;}
        void setTipoCalculador(TIPO_CALCULADOR tipoCalculador){this->tipoCalculador = tipoCalculador;}
        int getTwist(){return twist;}
        void setTwist(int twist){this->twist = twist;}
        int getDragLinear(){return dragLinear;}
        void setDragLinear(int dragLinear){this->dragLinear = dragLinear;}
        double getLatitude(){return latitude;}
        void setLatitude(double latitude){this->latitude = latitude;}
        double getLancamento(){return lancamento;}
        void setLancamento(double lancamento){this->lancamento = lancamento;}


        bool isExibirNumeroLinhaBoletim(){return exibirNumeroLinhaBoletim;}
        void setExibirNumeroLinhaBoletim(bool exibirNumeroLinhaBoletim){this->exibirNumeroLinhaBoletim = exibirNumeroLinhaBoletim;}
        bool isExibirValoresQuaseConvergentes(){return exibirValoresQuaseConvergentes;}
        void setExibirValoresQuaseConvergentes(bool exibirValoresQuaseConvergentes){this->exibirValoresQuaseConvergentes = exibirValoresQuaseConvergentes;}
        bool isUsarCoriolis(){return usarCoriolis;}
        void setUsarCoriolis(bool usarCoriolis){this->usarCoriolis = usarCoriolis;}
        bool isUsarCorrecaoLatitude(){return usarCorrecaoLatitude;}
        void setUsarCorrecaoLatitude(bool usarCorrecaoLatitude){this->usarCorrecaoLatitude = usarCorrecaoLatitude;}
        bool isUsarFatores(){return usarFatores;}
        void setUsarFatores(bool usarFatores){this->usarFatores = usarFatores;}


    protected:

    private:
        static Configuracao* instance;
        double anguloDisparo;
        double alcance;
        double desnivel;
        double anguloInicial;
        double deltaPesoFormFactor;
        double desvioProvavelElevacao;
        double desvioProvavelArrasto;
        double desvioProvavelDirecaoFatorAjuste;
        double desvioProvavelVelocidade;
        std::tuple<double, double> deltaVoTemperatura;
        bool exibirValoresQuaseConvergentes;
        bool exibirNumeroLinhaBoletim;
        double latitude;
        double lancamento;
        double massaPropelente;
        std::tuple<double, double> temperaturaPropelente;
        double velocidadeInicial;
        TIPO_TRAJETORIA trajetoria;
        double passo;
        TIPO_ATMOSFERA tipoAtmosfera;
        TIPO_CALCULADOR tipoCalculador;
        int twist;
        int dragLinear;
        double precisao;
        bool usarCoriolis;
        bool usarCorrecaoLatitude;
        bool usarFatores;
};
# 22 "C:/temp/ballisticKernelCpp/interfaceGrafica/calculadorBalisiticaGraficoWindows/globais.h" 2
extern TIPO_PROJETIL tipoPjt;
extern ProjetilDAO* projDAO;
extern Projetil projetil;

extern CoeficientesDAO* coefDAO;
extern CoeficienteDragLinear coefDragLienar;
extern CoeficienteDrag coefDrag;
extern CalculadorVacuo calcVacuo;
extern CalculadorArrastoLinear calcLinear;
extern CalculadorPontoMassa calcPM;
extern CalculadorPontoMassaModificado calcPontoMassaModificado;
extern CalculadorPontoMassaModificado1990 calcPontoMassaModificado1990;

extern CalculadorFator calcfat;

extern Configuracao* config;

string getPjtDescricao(Projetil projetil);
void initGlobais();
# 3 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp" 2
# 1 "..\\..\\MathArt/mathart.h" 1



# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/math.h" 1 3
# 5 "..\\..\\MathArt/mathart.h" 2

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 1 3
# 36 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
       
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3





# 41 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
namespace std
{

namespace __cxx11 {
# 64 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 166 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret(_M_string.get_allocator());
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret.assign(this->pbase(), this->pptr());
     else
       __ret.assign(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 190 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 243 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 357 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 380 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 416 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 434 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 485 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 524 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 560 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 578 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 629 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 668 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 703 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 719 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 770 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/sstream.tcc" 1 3
# 37 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/sstream.tcc" 3
       
# 38 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/sstream.tcc" 3

namespace std
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 828 "C:/Program Files/CodeBlocks/MinGW/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/sstream" 2 3
# 7 "..\\..\\MathArt/mathart.h" 2
# 23 "..\\..\\MathArt/mathart.h"

# 23 "..\\..\\MathArt/mathart.h"
class MathArt
{
    public:
        MathArt();
    static int arred(double valor)
    {

        if((valor - floor(valor) - 0.5)> 0.0)
         return ((int) ceil(valor));
     else
         return ((int) floor(valor));
    }


    template <typename T>
    static std::string to_string_with_precision(const T a_value, int n = 6)
    {
        std::ostringstream out;
        out.precision(n);
        out << std::fixed << a_value;
        return out.str();
    }

    static std::tuple <double, double> polinomioInterpoladorTabelaE(std::tuple <double, double> temperaturaPropelente, std::tuple<double, double> deltaVelocidade) ;

    private:


};
# 4 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp" 2
# 1 "..\\..\\CalculadorNumerico/excecoes/ExceptionConvergence.h" 1




# 1 "..\\..\\CalculadorNumerico/excecoes/../calculador/elementosdisparo.h" 1
# 6 "..\\..\\CalculadorNumerico/excecoes/ExceptionConvergence.h" 2


class ExceptionConvergence : public exception
{
    public:
        ExceptionConvergence(ElementosDisparo elementos){elementosDisparo = elementos;};
        const char * what () const throw ()
        {
            return "Nao convergiu para alcance desejado.";
        }
        ElementosDisparo getElementosDisparo(){return elementosDisparo;}


    private:
        ElementosDisparo elementosDisparo;
};
# 5 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp" 2
# 1 "..\\..\\CalculadorNumerico/excecoes/ExceptionYawRepose.h" 1







class ExceptionYawRepose : public exception
{
    public:
        ExceptionYawRepose(ElementosDisparo elementos){elementosDisparo = elementos;};
        const char * what () const throw ()
        {
            return "Nao convergiu para alcance desejado.";
        }
        ElementosDisparo getElementosDisparo(){return elementosDisparo;}


    private:
        ElementosDisparo elementosDisparo;
};
# 6 "C:\\temp\\ballisticKernelCpp\\interfaceGrafica\\calculadorBalisiticaGraficoWindows\\tabelaDialog\\geradorTabularI.cpp" 2


GeradorTabularI::GeradorTabularI(wxTextCtrl *textoTabela):GeradorTabular(textoTabela)
{

}




void GeradorTabularI::gerarTabela(CalculadorAtmosferico *calculador, double velocidade, TIPO_TRAJETORIA trajetoria, double passo, double precisao)
{
    ElementosVoo elementosVoo;
 ElementosDisparo elementosDisparo;
 int limite = (int) (calculador->limite(velocidade, passo)).sx;
    limite /= 100;
    limite *= 100;

    int inicio = trajetoria == TIPO_TRAJETORIA::MERGULHANTE ? 100 : limite -100;
    int fim = trajetoria == TIPO_TRAJETORIA::MERGULHANTE ? limite : 100;


    textoTabela->AppendText("Tabela I ");
    textoTabela->AppendText(std::to_string(MathArt::arred(velocidade)) + " m/s  " + (trajetoria == TIPO_TRAJETORIA::MERGULHANTE ? "Mergulhante" : "Vertical") + "\n\n");
    textoTabela->AppendText("\t\t\t" + wxString::FromDouble(fabs(config->getLatitude()), 1) + " graus de latitude norte\n");
    textoTabela->AppendText("\t\t\tAzimute para o alvo em mils\n\n");
    for(int i = 0; i<= 3200; i += 400)
        textoTabela->AppendText( "\t" + std::to_string(i) );
    textoTabela->AppendText("\n");
    for(int i = 6400; i >= 3200; i -= 400)
        textoTabela->AppendText( "\t" + std::to_string(i));
    textoTabela->AppendText("\n\n");



    int passoLoop = 100;
    if(trajetoria == TIPO_TRAJETORIA::MERGULHANTE)
        elementosDisparo.setElementosDisparo(0.0, 0.0, true);
    else
    {
        elementosDisparo.setElementosDisparo(1000.0, 0.0, true);
        passoLoop *=-1;
    }




    calculador->setChecarLimite(false);
    bool statusUsarCoriolis = config->isUsarCoriolis();
    double statusLancamento = config->getLancamento();
    double statusLatitude = config->getLatitude();

    int alcance;
    for(alcance = inicio; ((alcance <= fim) && (inicio < fim)) || ((alcance > fim) && (inicio > fim) ); alcance += passoLoop)
    {
        calculador->setLancamento(0);
        calculador->setLatitude(fabs(config->getLatitude()));
        calculador->setCoriolis(false);
        try
        {
            elementosDisparo = calculador->solucaoReversa((double)alcance, velocidade, 0.0, trajetoria, passo, precisao, elementosDisparo.getElevacao());
        }
        catch (ExceptionConvergence& ex)
        {
            break;
        }
        catch(ExceptionYawRepose& ex)
        {
            textoTabela->AppendText("\nLimite de validade do Modelo.\n");
            break;
        }


        elementosVoo = calculador->solucaoDiretaUltimoElemento(elementosDisparo.getElevacao(), velocidade, 0.0, passo);

        textoTabela->AppendText(std::to_string(alcance) + "\t");
        calculador->setCoriolis(true);
        calculador->setLatitude(fabs(config->getLatitude()));
        for(int lanc = 0; lanc <= 3200; lanc += 400)
        {
            string preSinal = "", posSinal = "";
            calculador->setLancamento((double) lanc);
            ElementosVoo elementosVooAzimutal = calculador->solucaoDiretaUltimoElemento(elementosDisparo.getElevacao(), velocidade, 0.0, passo);
            double delta = (elementosVoo.sz - elementosVooAzimutal.sz)/alcance;
            delta = 3200.0/3.141592653589793238463*atan(delta);
            if (delta > 0)
            {
                preSinal = "D";
                posSinal = "E";
            }
            else
            {
                if(delta < 0)
                {
                    preSinal = "E";
                    posSinal = "D";
                }

            }

            textoTabela->AppendText(preSinal + wxString::FromDouble(fabs(delta), 1) + posSinal + "\t");
        }
        textoTabela->AppendText("\n");

        wxYield();

        if(parar)

            break;
   }

    calculador->setLancamento(statusLancamento);
    calculador->setLatitude(statusLatitude);
    calculador->setCoriolis(statusUsarCoriolis);
    calculador->setChecarLimite(true);


        textoTabela->AppendText("\n");
    for(int i = 3200; i>= 0; i -= 400)
        textoTabela->AppendText( "\t" + std::to_string(i) );
    textoTabela->AppendText("\n");
    for(int i = 3200; i <= 6400; i += 400)
        textoTabela->AppendText( "\t" + std::to_string(i));
    textoTabela->AppendText("\n\n");
    textoTabela->AppendText("\t\t\tAzimute para o alvo em mils\n");
    textoTabela->AppendText("\t\t\t" + wxString::FromDouble(fabs(config->getLatitude()), 1) + " graus de latitude sul\n\n");

    textoTabela->AppendText("\tNotas - 1. Ao registrar do topo, use o sinal antes do nmero\n");
    textoTabela->AppendText("\t\t2. Ao registrar do fundo, use o sinal depois do nmero.\n");
    textoTabela->AppendText("\t\t3. D significa correo  direita, E  esquerda.\n");
    textoTabela->AppendText("\t\t4. O azimute  medido no sentido horrio a partir do norte.\n");

    textoTabela->AppendText("\n\n");


    textoTabela->AppendText("Fim.\n");



}
